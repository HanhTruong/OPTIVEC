<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<title>OptiVec: Handbook</title></head>
<body bgcolor="#ffffff" text="#000000" link="#0000ff" vlink="#0000ff" alink="#ff0000">
<TABLE CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >
<TR><TD><IMG SRC="optivec.gif" BORDER=0 WIDTH=280>&nbsp;
</TD><TD><h1><I><b><font size="+4">OptiVec</font></b></I><P>
Version 3</h1>
<BR><h2>for C/C++ and for Pascal/Delphi</h2>
</td></tr><tr><TD>
<I>OptiCode</I>
<BR>Dr. Martin Sander Software Development
<BR>Steinachstr. 9A
<BR>D-69198 Schriesheim
<BR>Germany
<BR><a href="http://www.optivec.com">http://www.optivec.com</a>
<BR>e-mail: <A HREF="mailto:support@optivec.com">support@optivec.com</A> or
<BR><A HREF="mailto:sales@optivec.com">sales@optivec.com</A>
</TD><TD><h1>Part I. A: Handbook</h1>
</TD></TR></TABLE>
<P>This HANDBOOK describes the basic principles of the <I>OptiVec</I> libraries and gives an overview over <I>VectorLib</I>, the first part of <I>OptiVec</I>. The new object-oriented interface, <I>VecObj</I>, is described in <a href="#chap3">chapter 3</a>. The other parts have their own descriptions in separate files, see <a href="MATRIX.HTM">MATRIX.HTM</a> and <a href="CMATH.HTM">CMATH.HTM</a>.

<BR><a href="#chap1_2">Chapter 1.2</a> of this Handbook contains the licence terms for the Shareware version, <a href="#chap1_3_2">Chapter 1.3</a> for the Registered version.
<BR>&nbsp;
<BR><I>OptiCode</I>™ and <I>OptiVec</I>™ are trademarks of Dr. Martin Sander Software Dev. Other brand and product names mentioned in this handbook for identification purposes are trademarks or registered trademarks of their respective holders.
<BR>&nbsp;
<table width="100%"><tr><td width="10%"></TD>
<td><b>German-speaking users:</b>
<BR>Um die Kosten f&uuml;r das Herunterladen der Shareware-Version &uuml;ber das Internet f&uuml;r alle so gering wie m&ouml;glich zu halten, enth&auml;lt diese nur die englische Dokumentation. Sie finden die deutsche Beschreibung separat unter <a href="http://www.optivec.com/download/OVDOCD.ZIP">http://www.optivec.com/download/OVDOCD.ZIP</a>.</td></tr>
</table>

<a name="TOC"></a>
<H1>Contents</H1>
<a href="#chap1">1. Introduction</a>
<table width="100%">
<tr valign="top"><td width="3%"></TD><td><a href="#chap1_1">1.1 Why Vectorized Programming Pays Off on the PC</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap1_2">1.2 License Terms for the Shareware Version</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap1_3">1.3 Registered Versions</a></td></tr></table>
<table width="100%">
<tr valign="top"><td width="6%">&nbsp;</TD><td><a href="#chap1_3_1">1.3.1 Registered Versions: Ordering</a></td></tr>
<tr valign="top"><td>&nbsp;</TD><td><a href="#chap1_3_2">1.3.2 License Terms for the Registered Versions</a></td></tr></table>
<table width="100%">
<tr valign="top"><td width="3%"></TD><td><a href="#chap1_4">1.4 Getting Started</a></td></tr></table>
<a href="#chap2">2. The Elements of <I>OptiVec</I> Routines</a>
<table width="100%">
<tr valign="top"><td width="3%"></TD><td><a href="#chap2_1">2.1 Synonyms for Some Data Types</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap2_2">2.2 Complex Numbers: The Data Types fComplex, dComplex, eComplex, fPolar, dPolar, and ePolar</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap2_3">2.3 Vectors and Arrays: The Data Types fVector, dVector, eVector, cfVector, pfVector, iVector, uVector, etc.</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap2_4">2.4 Real-number Functions: The Prefixes <I>VF_,&nbsp; VD_</I>, and <I>VE_</I></a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap2_5">2.5 Complex-Number Functions: The Prefixes <I>VCF_,&nbsp; VCD_,&nbsp; VCE_,&nbsp; VPF_,&nbsp; VPD_</I>, and <I>VPE_</I></a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap2_6"> 2.6 Functions of the Integer Data Types: The Prefixes <I>VI_,&nbsp; VBI_,&nbsp; VSI_,&nbsp; VU_</I>, etc.</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap2_7">2.7 Common Functions of Several Data Types: The Prefix <I>V_</I></a></td></tr></table>
<a href="#chap3">3. C++ only: <I>VecObj</I>, the Object-Oriented Interface for <I>VectorLib</I></a>
<BR><a href="#chap4">4. <I>VectorLib</I> Functions and Routines: A Short Overview</a>
<table width="100%">
<tr valign="top"><td width="3%"></TD><td><a href="#chap4_1">4.1 Generation, Initialization and De-Allocation of Vectors</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_2">4.2 Index-oriented Manipulations</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_3">4.3 Data-Type Interconversions</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_4">4.4 More about Integer Arithmetics</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_5">4.5 Basic Functions of Complex Vectors</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_6">4.6 Mathematical Functions</a></td></tr></table>
<table width="100%">
<tr valign="top"><td width="6%"></TD><td><a href="#chap4_6_1">4.6.1 Rounding</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_6_2">4.6.2 Comparisons</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_6_3">4.6.3 Direct Bit-Manipulation</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_6_4">4.6.4 Basic Arithmetics, Accumulations</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_6_5">4.6.5 Geometrical Vector Arithmetics</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_6_6">4.6.6 Powers</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_6_7">4.6.7 Exponentials and Hyperbolic Functions</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_6_8">4.6.8 Logarithms</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_6_9">4.6.9 Trigonometric Functions</a></td></tr></table>
<table width="100%">
<tr valign="top"><td width="3%"></TD><td><a href="#chap4_7">4.7 Analysis</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_8">4.8 Signal Processing: Fourier Transforms and Related Topics</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_9">4.9 Statistical Functions and Building Blocks</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_10">4.10 Data Fitting</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_11">4.11 Input and Output</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap4_12">4.12 Graphics</a></td></tr></table>
<a href="#chap5">5. Error Handling</a>
<table width="100%">
<tr valign="top"><td width="3%"></TD><td><a href="#chap5_1">5.1 General Remarks</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap5_2">5.2 Integer Errors</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap5_3">5.3 Floating-Point Errors</a></td></tr></table>
<table width="100%">
<tr valign="top"><td width="6%"></TD><td><a href="#chap5_3_1">5.3.1 C/C++ specific</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap5_3_2">5.3.2 Pascal/Delphi specific</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap5_3_3">5.3.3 Error Types (Both C/C++ and Pascal/Delphi)</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap5_3_4">5.3.4 Differences between Borland C++ 4.0 and earlier BC++ versions</a></td></tr></table>
<table width="100%">
<tr valign="top"><td width="3%"></TD><td><a href="#chap5_4">5.4 The Treatment of Denormal Numbers</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap5_5">5.5 Advanced Error Handling: Writing Messages into a File</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap5_6">5.6 <I>OptiVec</I> Error Messages</a></td></tr></table>
<a href="#chap6">6. Trouble-Shooting</a>
<table width="100%">
<tr valign="top"><td width="3%"></TD><td><a href="#chap6_1">6.1 General Problems</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap6_2">6.2 Problems with Windows 3.x?</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap6_3">6.3 Problems with 32-bit Windows?</a></td></tr>
<tr valign="top"><td></TD><td><a href="#chap6_4">6.4 Problems with Borland's 16-bit Linker?</a></td></tr>
</table>
<a href="#chap7">7. The Include-Files and Units of <I>OptiVec</I></a>
<BR>
<BR>P a r t I. B : File <a href="FUNCREF.HTM">FUNCREF.HTM</a> contains:
<BR>&nbsp;
<BR><a href="FUNCREF.HTM#chap8">8. Alphabetical Reference of Vector Functions</a>
<BR><a href="FUNCREF.HTM#chap9">9. Scalar (non-vectorized) Functions</a>

<P><a name="chap1"></a>
<H1><HR width="100%">1. Introduction</H1>
<P><I>OptiVec</I> offers a powerful set of routines for numerically demanding applications, making the philosophy of vectorized programming available for C/C++ and Pascal/Delphi languages. It serves to overcome the limitations of loop management of conventional compilers – which proved to be one of the largest obstacles in the programmer's way towards efficient coding for scientific and data analysis applications.
<P>In comparison to the old vector language APL, <I>OptiVec</I> has the advantage of being incorporated into the modern and versatile languages C/C++ and Pascal/Delphi. Recent versions of C++ and Fortran do already offer some sort of
vector processing, by virtue of iterator classes using templates (C++) and field functions (Fortran90). Both of these, however, are basically a convenient means of letting the compiler write the loop for you and then compile it to the usual inefficient code. The same is true for most implementations of the popular BLAS (Basic Linear Algebra Subroutine) libraries.
In comparison to these approaches, <I>OptiVec</I> is superior mainly with respect to execution speed &#150; on the average by a factor of 2-3, in some cases even up to 8. The performance is no longer limited by the quality of your compiler, but rather by the real speed of the processor!
<P>There is a certain overlap in the range of functions offered by <I>OptiVec</I> and by BLAS, LINPACK, and other libraries and source-code collections. However, the latter must be compiled, and, consequently, their performance is determined mainly by the quality of the compiler chosen. To the best of our knowledge, <I>OptiVec</I>, was the first product on the market offering a comprehensive vectorized-functions library realized in a true Assembler implementation.
<UL>
<LI>All operators and mathematical functions of C/C++ and Pascal/Delphi are implemented in vectorized form; additionally many more mathematical functions are included which normally would have to be calculated by more or less complicated combinations of existing functions. Not only the execution speed, but also the accuracy of the results is greatly improved.
<LI>A wide range of optimized matrix functions like matrix arithmetics, algebra, decompositions, data fitting, etc. is offered by <a href="MATRIX.HTM"><I>MatrixLib</I></a>.
<BR>TensorLib is planned as a future extension of these concepts for general multidimensional arrays.
<LI>Fast Fourier Transform techniques (both one- and two-dimensional) allow for efficient convolutions, correlation analyses, spectral filtering, and so on.
<LI>Building blocks for statistical data analysis are supplied.
<LI>Derivatives, integrals, interpolation schemes are included.
<LI>Graphical representation of data offers a convenient way of monitoring the results of vectorized calculations.
<LI>Each function exists for every data type for which this is reasonable. The data type is signalled by the prefix of the function name. No implicit name mangling or other specific C++ features are used in the C/C++ version, which makes <I>OptiVec</I> usable in plain-C as well as in C++ programs. Moreover, the names and the syntax of nearly all functions are the same in C/C++ and Pascal/Delphi languages.
<LI>The input and output vectors/matrices of <I>VectorLib</I> and <I>MatrixLib</I> routines may be of variable size and it is possible to process only a part (e.g., the first 100 elements, or every 10th element) of a vector, which is another important advantage over other approaches, where only whole arrays are processed.
<LI>A new object-oriented interface for C++, named <I>VecObj</I>, encapsulates all vector functions, offering even easier use and increased memory safety.
<LI>Using <I>OptiVec</I> routines instead of loops can make your source code much more compact and far better readable.
<LI>Besides the vectorized complex-number functions, <I><a href="CMATH.HTM">CMATH</a></I> is included. This is a comprehensive library of complex operations and functions, both in cartesian and polar coordinates. In comparison to complex class libraries shipped with C++ compilers, <I>CMATH</I> is generally much faster, more complete, more accurate and numerically stable. Moreover, <I>CMATH</I> does not require C++, but may be used with simple C (then with data-type specific function prefixes).
</UL>
<P>The wide range of routines and functions covered by <I>OptiVec</I>, the high numerical efficiency and increased ease of programming make this package a powerful programming tool for scientific and data analysis applications, competing with (and often beating) many high-priced integrated systems, but imbedded into your favourite programming language.

<P>This documentation describes the <I>OptiVec</I> implementations for
<UL>
<LI>Borland C++ (Version 3.0 or higher, including all versions of Borland C++ Builder) for DOS, Windows 3.x or 32-bit Windows. The library for the memory model FLAT for Windows95/98/2000/NT requires Borland C++, version 4.0 or higher.
<LI>Microsoft Visual C++ (Version 5.0 or higher) for Windows95/98/2000/NT on PC platforms.
<LI>Borland Delphi 2, 4, 5, or 6 on 32-bit Windows
<LI>Borland (Turbo) Pascal 7.0 for DOS
</UL>
<BR>Please note that only the &quot;outside appearance&quot; and thus the documentation is the same for these different
compilers. The libraries themselves are compiler-specific; each library can be used only with one compiler and, in the case of C/C++, with one memory model or one target:
<OL>
<LI><U>Shareware version for Borland C++:</U>
<BR>Depending on your choice when ordering or downloading, you have got either of the following three library versions:
<UL><LI>Memory model FLAT for Windows95/98/NT, statically linked runtime library
<LI>LARGE for DOS, or
<LI>LARGE for Windows 3.x.
</UL>
All of them require, at least, a 386 computer equipped with a 387 coprocessor. This means: no emulation, no 486SX, but preferably 486DX, Pentium or higher. As of now, the P6 libraries (for Pentium III or higher) are included only with the registered version.
<P><LI><U>Registered version for Borland C++:</U>
<BR>The full (registered) version for Borland C++ contains libraries for all memory models of DOS, 16-bit Windows and 32-bit Windows. These libraries, in turn, are shipped in four versions: one for P6 (Pentium III or higher) computers, the second for 486DX and Pentium, the third for 386 with 387, and &#150; still available &#150; the fourth for 286 with or without coprocessor, i.e. with emulation. The P6 version can only be used with BC++ 5.x, BCB 5 or higher, but not with BCB 1-4, because the linker shipped with the latter BCB versions does not correctly link P6 code.

<P><LI><U>Microsoft Visual C++:</U>
<BR>The Shareware version has 486DX/Pentium libraries for &quot;single-thread debug&quot; and &quot;multi-thread debug&quot;. The full (registered) version for Microsoft Visual C++ contains additional libraries for &quot;multi-thread DLL debug&quot; and the three corresponding release libraries. There is no actual debug information enclosed in the <I>OptiVec</I> &quot;debug&quot; libraries, but they have to be used with the debug libraries of Visual C++. In addition, libraries optimized for Pentium III or higher are included in the full version.

<P><LI><U>Borland Delphi 2, 4, 5, or 6:</U>
The Shareware version requires, at least, a 386 computer equipped with a 387 coprocessor. This means:
no emulation, no 486SX, but preferrably 486DX, Pentium or higher. The Registered version has separately optimized libraries for 486/Pentium, and for 386+387.

<P><LI><U>Borland Pascal 7.0:</U>
The Shareware version is for the real-mode DOS target and requires, at least, a 386 computer equipped with a 387 coprocessor. The registered version of <I>OptiVec</I> for Borland Pascal has separate units for 486/Pentium, 386+387, and 286, both for real-mode and protected-mode DOS.
</OL>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap1_1"></a>
<H2>1.1 Why Vectorized Programming Pays Off on the PC</H2>
To process one-dimensional data arrays or &quot;vectors&quot;, a programmer would normally write a loop over all vector elements. Similarly, two- or higher-dimensional arrays (&quot;matrices&quot; or &quot;tensors&quot;) are usually processed through nested loops over the indices in all dimensions. The alternative to this classic style of programming are vector and matrix functions.
<BR>Vector functions act on whole arrays/vectors instead of single scalar arguments. They are the most consequent form of &quot;vectorization&quot;, i.e., organisation of program code (by clever compilers or by the programmer himself) in such a way as to optimize vector treatment.

<P>Vectorization has always been the magic formula for supercomputers with their multi-processor parallel architectures. On these architectures, one tries to spread the computational effort equally over the available processors, thus maximizing execution speed. The so-called &quot;divide and conquer&quot; algorithms break down more complicated numerical tasks into small loops over array elements. Sophisticated compilers then find out the most efficient way how to distribute the array elements among the processors. Many supercomputer compilers also come with a large set of pre-defined proprietary vector and matrix functions for many basic tasks. These vectorized functions offer the best way to achieve maximum throughput.

<p>Obviously, the massive parallel processing of, say, a Cray is not possible on most PCs with their one and only CPU. (Even high-end workstations feature still modest 2 or 4-CPU configurations.) Consequently, at first sight, it might seem useless to apply the principle of vectorized programming to the PC. Actually, however, there are many vector-specific optimizations possible, even for computers with only one CPU. Most of these optimizations are not available to present compilers. Rather, one has to go down to the machine-code level. <b>Hand-optimized, Assembler-written vector functions outperform compiled loops by a factor of two to three, on the average.</b> This means that vectorization, properly done, is indeed worth the effort, also for PC programs. 

<p>Here are the most important optimization strategies, employed in <I>OptiVec</I> to boost the performance:

<P><B>Prefetch of chunks of vector elements</B><BR>Beginning with the Pentium III processor, Intel introduced the very useful feature of explicit memory prefetch. With these commands, it is possible to "tell" the processor to fetch data from memory sufficiently in advance, so that no time is waisted waiting for them when they are actually needed.

<P><B>Cache control</B><BR>The Pentium III processor offers the possibility to mark data as "temporal" (will be used again) or "non-temporal" (used only once), while they are fetched or stored. In <I>OptiVec</I> functions, it is assumed that input vectors (and matrices) will not be used again, whereas the output vectors are likely to become the input for some ensuing procedure. Consequently, the cache is bypassed while loading input data, but the output data are written into the cache. Of course, this approach breaks down if the vectors or matrices become too large to fit into the cache. For these cases, a large-vector version of the <I>OptiVec</I> libraries is available which bypasses the cache also while writing the output vectors. For simple arithmetic functions, up to 20% in speed are gained as compared to the small-and-medium-size version. On the other hand, as this large-vector version effectively switches the cache off, a drastic performance penalty (up to a factor of three or four!) will result, if it is used for smaller systems. For the same reason, you should carefully check if your problem could perhaps be split up into smaller vectors, before resorting to the large-vector version. This would allow to achieve the much higher performance resulting from efficient data caching.

<P><B>Use of SIMD commands</B><BR>You might wonder why this strategy is not listed first. The SSE or "Streaming Single-Instruction-Multiple-Data Extensions" of Pentium III and Pentium 4 provide explicit support for vectorized programming with floating-point data in <B>float / single</B> or <B>double</B> precision (the latter only for Pentium 4). At first sight, therefore, they should revolutionize vector programming. Given today's processor and data bus speeds, however, many of the simple arithmetic operations have become data transfer limited, and the use of SIMD commands does not make the large difference (with respect to well-written FPU code) which it could make otherwise. In most cases, the advantage of treating four <B>float</B>s in a single command melts down to a 20-30% increase in speed (which is not that bad, anyway!). For more complicated operations, on the other hand, SIMD commands often cannot be employed, either because conditional branches have to be taken for each vector element individually, or because the "extra" accuracy and range, available by traditional FPU commands (with their internal <B>extended</B> accuracy), allows to simplify algorithms so much that the FPU code is still faster. As a consequence, we use SIMD commands only where a real speed gain is possible without affecting the accuracy. 

<P><B>Preload of floating-point constants</B><BR>Floating-point constants, employed in the evaluation of mathematical functions, are loaded onto the floating-point number stack outside of the actual loop and stay as long as they are needed. This saves a large amount of loading/unloading operations which are necessary if a mathematical function is called for each element of a vector separately.

<P><B>Full FPU stack usage</B><BR>Where necessary, all eight coprocessor registers are employed. (For present compilers, it is already an excellent achievement to master the bookkeeping for only four coprocessor registers.)

<P><B>Superscalar scheduling</B><BR>By careful &quot;pairing&quot; of commands whose results do not depend upon each other, the two integer pipes and the two <FONT FACE="Courier New">fadd/fmul</FONT> units of the Pentium/PentiumXX are used as efficiently as possible.<BR>In most instances, computers equipped with 386/387 or 486DX CPUs just will not care about these optimizations which they cannot profit from. In those cases, however, where the performance on these older CPUs suffers significantly from the Pentium-optimized scheduling, it is applied only in the &quot;4&quot; version of <I>OptiVec</I> (back-compatible to 486DX), but not in the &quot;3&quot; version (back-compatible to 386/387).

<P><B>Loop-unrolling</B><BR>Where optimum pairing of commands cannot be achieved for single elements, vectors are often processed in chunks of two, four, or even more elements. This allows to fully exploit the parallel-processing capabilities of the Pentium and its successors. Moreover, the relative amount of time spent for loop management is significantly reduced. In connection with data-prefetching, described above, the depth of the unrolled loops is most often adapted to the cache line size of 32 bytes.

<P><B>Simplified addressing</B><BR>The addressing of vector elements is still a major source of inefficiency with present compilers. Switching forth and back between input and output vectors, a large number of redundant addressing operations is performed. The strict (and easy!) definitions of all <I>OptiVec</I> functions allow to reduce these operations to a minimum.

<P><B>Replacement of floating-point by integer commands</B><BR>For any operations with floating-point numbers that can also be performed using integer commands (like copying, swapping, or comparing to preset values), the faster method is consistently employed.

<P><B>Strict precision control</B><BR>C compilers convert a <B>float</B> into a <B>double</B> &#150; Borland Pascal/Delphi even into <B>extended</B> &#150; before passing it to a mathematical function. This approach was useful at times when disk memory was too great a problem to include separate functions for each data type in the .LIB files, but it is simply inefficient on modern PCs. Consequently, no such implicit conversions are present in <I>OptiVec</I> routines. Here, a function of a <B>float</B> is calculated to <B>float</B> (i.e. single) precision, wasting no time for the calculation of more digits than necessary &#150; which would be discarded anyway. Additionally, you can call <font face="courier new"><a href="FUNCREF.HTM#setFPAccuracy">V_setFPAccuracy</a>( 1 );</font> to actively switch the FPU to single precision, if that is enough for a given application. Thereby, execution can be significantly sped up from Pentium CPUs on. For details and precautions, see <I><a href="FUNCREF.HTM#setFPAccuracy">V_setFPAccuracy</a></I>.

<P><B> All-inline coding</B><BR>All external function calls are eliminated from the inner loops of the vector processing. This saves the execution time necessary for the &quot;<FONT FACE="Courier New">call / ret</FONT>&quot; pairs and for loading the parameters onto the stack.

<P><B>Cache-line matching of local variables</B><BR>
The Level-1 cache of the Pentium and its presently available successors is organized in lines of 32 bytes each. Many <I>OptiVec</I> functions need double-precision or extended-precision real local variables on the stack (mainly for integer/floating-point conversions or for range checking). Present compilers align the stack on 4-byte boundaries, which means there is a 1-in-4 chance that the 8 bytes of a <B>double</B> or the 10 bytes of an <B>extended</B>, stored on the stack, will cross a 32-byte boundary. This, in turn, would lead to a cache line-break penalty, deteriorating the performance. Consequently, those <I>OptiVec</I> functions where this is an issue, use special procedures to align their local variables on 8-byte (for <B>double</B>s) or 16-byte boundaries (for <B>extended</B>s).

<P><B>Unprotected and reduced-range functions</B><BR>
<I>OptiVec</I> offers alternative forms of some mathematical functions, where you have the choice between the fully protected variant with error handling and another, unprotected variant without. In the case of the integer power functions, for example, the absence of error checking allows the unprotected versions to be vectorized much more efficiently. Similarly, the sine and cosine functions can be coded more efficiently for arguments that the user can guarantee to lie in the range -2<FONT FACE="Symbol">p</FONT> and +2<FONT FACE="Symbol">p</FONT>. In these special cases, the execution time may be reduced by up to 40%, depending on the hardware environment. This increased speed has always to be balanced against the increased risk, though: If any input element outside the valid range is encountered, the unprotected and reduced-range functions will crash without warning.

<P><B>Multithread support</B><BR>
All the above being said about single-CPU PCs, there are high-end workstations and servers on the market, equipped with 2 or 4 PentiumXX chips. While multi-tasking and multi-threading is possible also on single-CPU PCs, multi-processor configurations allow the operating system to distribute threads among the available processors, doubling or quadrupling the overall performance. For that, any functions running in parallel must be prevented from interfering with each other through read/write operations on global variables. With very few exceptions (namely the plotting functions, which have to use global variables to store the current window and coordinate system settings), all other <I>OptiVec</I> functions may run in parallel. <I>OptiVec</I> functions do not initiate threads themselves, though, as the overhead involved in multi-threading would significantly affect the performance on single-CPU machines. If you have a multi-CPU computer, you have to explicitly launch the threads you wish to run in parallel. For example, one thread might take the lower half of the vector(s) you wish to process, while a second thread takes the upper half &#150; until a point is reached, where both must be combined.
<BR>Be extremely careful with multi-threading, if you are using the P6 version of <I>OptiVec</I>: The earlier releases of 32-bit Windows do not save the XMM registers (employed in the SIMD commands) during task switches. 
</P>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap1_2"></a>
<H2>1.2 Licence Terms for the Shareware Version</H2>
The following licence terms apply to the Shareware version of <I>OptiVec</I>.
For the licence terms of the Registered version, please see paragraph <a href="#chap1_3_2">1.3</a>.
<B><P>This is the Shareware version of <I>OptiVec</I> (&quot;SOFTWARE&quot;).
<BR>It may be used under the following licence terms:
<OL>
<LI>You may test the SOFTWARE free of charge for a period of up to 90 days on one computer. 
<LI>Applications, created with the Shareware version of this SOFTWARE, will run only on the same computer on which this SOFTWARE has been installed. They cannot and may not be distributed to others. After the end of the trial period, they will cease functioning.
<LI>If you want to continue using this SOFTWARE after testing, and/or if you wish to distribute programs containing functions of this SOFTWARE, you have to purchase the registered version (see <a href="#chap1_3">chapter 1.3</a>).
<LI>This SOFTWARE is provided on an &quot;as is&quot; basis. Any explicit or implicit warranties for the SOFTWARE are excluded.
<LI>Despite thorough testing of the SOFTWARE, errors and bugs cannot be excluded with certainty. No claims as to merchantability or fitness for a particular purpose are made.
<LI>You may not use the SOFTWARE in any environment or situation where personal injury or excessive damage to anyone's property (including your own) could arise from malfunctioning of the SOFTWARE.
<LI>You may not decompile, disassemble, or otherwise reverse engineer the SOFTWARE into a machine-readable form. You may, however, inspect the functions it contains by means of debuggers like those included in the Borland and Microsoft compilers.
</OL></B>
Copyright for the SOFTWARE and its documentation &copy; 1996-2002 <I>OptiCode</I> &#150; Dr. Martin Sander Software Dev.
<BR>All rights reserved, including those of translation into foreign languages.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap1_3"></a>
<H2>1.3 Registered Versions</H2>
<P><a name="chap1_3_1"></a>
<H2>1.3.1 Registered Versions: Ordering</H2>
In order to make this product affordable also for those who will not themselves make money using it, we offer an <U>educational edition</U> at a strongly reduced rate, in addition to the full <U>commercial edition</U>. The contents of these two editions is identical. The only difference lies in the restrictions of use: The <U>educational edition</U> may not be used for commercial / business / government purposes, but is restricted to private and educational use. 
<P>Purchasing the full (registered) version gives you the right to use it on as many computers at a time as the number of units you bought.
<P>The right to distribute applications employing functions of <I>OptiVec</I> is included in the <U>commercial-version</U> licence. <B>No run-time licence are needed for your customers! </B> Corporate site and world-wide licences are available upon request.

<P>The full versions (both the commercial and the educational editions) of <I>OptiVec</I>
<UL><LI>support all memory models of Windows95/98, NT, 3.x, and DOS (Borland C++)<BR>
<LI>single-thread, multi-thread, multi-thread DLL debug and release (Microsoft Visual C++)<BR>
<LI>Delphi 2, 4, 5, and 6 (Borland Delphi)<BR>
<LI>the real-mode DOS and DPMI targets (Borland Pascal 7.0)<BR>
<LI>Borland C++ and Pascal only: 
<BR>have individually optimized libraries for each degree of processor backward-compatibility:
<BR>P6 (requiring Pentium III; C++ only)
<BR>486DX/Pentium+ (optimized for Pentium II)
<BR>386+ (387 coprocessor required)
<BR>286+ (no coprocessor required).<BR>
<LI>(C/C++ versions only:) come with free printed documentation (which, however, is updated much less frequently than the electronic documentation).<BR>
<LI>entitle you to two years of free updates (by downloading from our web site)<BR>
<LI>can be ordered the following ways:
<BR><a href="#International">a) International orders</a> (credit-card or US cheque) by Internet, mail, FAX, or phone
<BR><a href="#EU">b) Orders within the European Union</a> (pre-paid or upon invoice)
</UL>
<a name="International"></a>
<h3>a) International Orders: Pricing</h3>
<H4><I>OptiVec</I> for Borland C/C++,&nbsp;&nbsp;Microsoft Visual C++,&nbsp;&nbsp;or Borland Delphi<BR>
(CD-ROM, printed handbook available for the C/C++ versions in English or German)</H4> 
          $&nbsp;&nbsp;&nbsp;&nbsp;89 for 1 unit of the educational edition&nbsp;
<BR>$&nbsp;&nbsp;199 for 1 unit of the commercial edition
<BR>$&nbsp;&nbsp;649 for 5 units (only through SWREG)
<BR>$ 1199 for 10 units (only through SWREG)
<BR>Add $ 5 for S&amp;H (postal) and applicable VAT.
<H4><I>CMATH</I> for Borland C/C++,&nbsp;&nbsp;Microsoft Visual C++,&nbsp;&nbsp;or Borland Delphi separately<BR>
 (CD-ROM, manual in English)</H4> $&nbsp;&nbsp;&nbsp;39 for 1 unit of the educational edition
<BR>$&nbsp;&nbsp;&nbsp;60 for 1 unit of the commercial edition
<BR>$ 200 for 5 units (only through SWREG)
<BR>$ 350 for 10 units (only through SWREG)
<BR>Add $ 5 for S&amp;H (postal) and applicable VAT.

<H4><I>OptiVec</I> for Borland (Turbo) Pascal<BR></H4> $ 35 for 1 unit + $ 5 for S&amp;H
<H4><I>CMATH</I> for Borland (Turbo) Pascal separately</H4> $ 25 for 1 unit + $ 5 for S&amp;H

<h3>International: Ordering Options</h3>
For your protection, we handle credit-card orders through two specialized secure services:&nbsp;
<P><U><B>SWREG:</B></U>
<BR>When ordering online through SWREG, please use the product-specific links below:
<BR><A HREF="http://www.swreg.org/soft_shop/47/shopscr3.html" TARGET="_blank"> <I>OptiVec</I> for C/C++</A>
<BR><A HREF="http://www.swreg.org/soft_shop/47/shopscr4.html" TARGET="_blank"> <I>OptiVec</I> for Pascal/Delphi</A>
<BR>Please choose the exact version and delivery options in the simple pulldown menu on the respective page.

<P><U><B>ShareIt:</B></U>
<BR>When ordering online through ShareIt, please use the product-specific links below:
<BR><A HREF="http://www.shareit.com/programs/101557.htm" TARGET="_blank"> <I>OptiVec</I> for Borland C/C++ (English)</A>
<BR><A HREF="http://www.shareit.com/deutsch/programs/101556.htm" TARGET="_blank"><I>OptiVec</I> f&uuml;r Borland C/C++ (Deutsch)</A>
<BR><A HREF="http://www.shareit.com/programs/101353.htm" TARGET="_blank"><I>CMATH</I> for Borland C/C++</A>
<BR><A HREF="http://www.shareit.com/programs/103421.htm" TARGET="_blank"> <I>OptiVec</I> for Microsoft Visual C++</A>
<BR><A HREF="http://www.shareit.com/programs/103422.htm" TARGET="_blank"><I>CMATH</I> for Microsoft Visual C++</A>
<BR><A HREF="http://www.shareit.com/programs/103843.htm" TARGET="_blank"> <I>OptiVec</I> for Borland Delphi</A>
<BR><A HREF="http://www.shareit.com/programs/103844.htm" TARGET="_blank"><I>CMATH</I> for Borland Delphi</A>
<BR><A HREF="http://www.shareit.com/programs/103423.htm" TARGET="_blank"> <I>OptiVec</I> for Borland (Turbo) Pascal</A>
<BR><A HREF="http://www.shareit.com/programs/103424.htm" TARGET="_blank"><I>CMATH</I> for Borland (Turbo) Pascal</A>

<P>You may also order by e-mail to register@shareit.com.
<BR>US customers can also call 1-800-903-4152 (only for orders, please).
<BR>US check and cash orders can be sent with this <A HREF="ORDFORM2.HTM">order form</A> to ShareIt!'s US office at
<BR>ShareIt! Inc.
<BR>P.O. Box 97841
<BR>Pittsburgh, PA 15227-0241
<BR>USA
<P>Note the program No.:&nbsp;
<TABLE>
<TR><TD></TD><TD>commercial&nbsp;&nbsp;</TD><TD>educational</TD></TR>
<TR><TD><I>OptiVec</I> for Borland C/C++ (English)</TD><TD>101557</TD><TD>102654</TD></TR>
<TR><TD><I>OptiVec</I> f&uuml;r Borland C/C++ (Deutsch)&nbsp;</TD><TD>101556</TD><TD>149813</TD></TR>
<TR><TD><I>CMATH</I> for Borland C/C++</TD><TD>101353</TD><TD>102655</TD></TR>
<TR><TD><I>OptiVec</I> for Microsoft Visual C++</TD><TD>103421</TD><TD>149811</TD></TR>
<TR><TD><I>CMATH</I> for Microsoft Visual C++</TD><TD>103422</TD><TD>103441</TD></TR>
<TR><TD><I>OptiVec</I> for Borland (Turbo) Pascal</TD><TD>103423</TD><TD>&nbsp;</TD></TR>
<TR><TD><I>CMATH</I> for Borland (Turbo) Pascal</TD><TD>103424</TD><TD>&nbsp;</TD></TR>
<TR><TD><I>OptiVec</I> for Borland Delphi</TD><TD>103443</TD><TD>103859</TD></TR>
<TR><TD><I>CMATH</I> for Borland Delphi</TD><TD>103844</TD><TD>103860</TD></TR>
</TABLE>

<a name="'EU"></a>
<h3>b) Orders in the European Union</h3>
If you can pay in Euro and order directly from the author, the pricing is
<H4><I>OptiVec</I> for Borland C/C++,&nbsp;&nbsp;Microsoft Visual C++,&nbsp;&nbsp;or Borland Delphi<BR>
(CD-ROM, printed handbook available for the C/C++ versions in English or German)</H4>
          EUR&nbsp;&nbsp;&nbsp;&nbsp;89 for 1 unit of the educational edition
<BR>EUR&nbsp;&nbsp;199 for 1 unit of the commercial edition
<BR>EUR&nbsp;&nbsp;649 for 5 units
<BR>EUR 1199 for 10 units
<BR>(incl. 16% German VAT, plus EUR 5,- handling charge).

<H4><I>CMATH</I> for Borland C/C++,&nbsp;&nbsp;Microsoft Visual C++,&nbsp;&nbsp;or Borland Delphi separately<BR>
 (CD-ROM, manual in English)</H4> EUR&nbsp;&nbsp;&nbsp;39 for 1 unit of the educational edition
<BR>EUR&nbsp;&nbsp;&nbsp;59 for 1 unit of the commercial edition
<BR>EUR 199 for 5 units
<BR>EUR 349 for 10 units
<BR>(incl. 16% German VAT, plus EUR 5,- handling charge).

<H4><I>OptiVec</I> for Borland (Turbo) Pascal<BR></H4> EUR 29 for 1 unit + EUR 5 for S&amp;H (incl. 16% German VAT)
<H4><I>CMATH</I> for Borland (Turbo) Pascal separately</H4> EUR 19 for 1 unit + EUR 5 for S&amp;H (incl. 16% German VAT)

<P><b>If you have a European VAT ID, or if you order from outside the European Union, you are exempt from German VAT, and it will be deduced from your bill, but you may have to pay your local VAT and/or import duties according to local laws.</b><BR>

<P>Please send a print-out of this <A HREF="ORDFORM1.HTM">order form</A> to
<P><I>OptiCode</I> &#150; Dr. Martin Sander Software Dev.
<BR>Steinachstr. 9A
<BR>D-69198 Schriesheim
<BR>Germany
<P>FAX +49 - 6203 - 601 733

<P>For any other questions related to ordering <I>OptiVec</I>, please contact us at: <A HREF="mailto:sales@optivec.com">sales@optivec.com</A>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap1_3_2"></a>
<h3>1.3.2 License Terms for the Registered version</h3>
If you got this file with the registered version of <I>OptiVec</I>, these are the license terms valid for you:
<b><P>This is a single copy license for <I>OptiVec</I> (&quot;SOFTWARE&quot;), granted by <I>OptiCode</I> &#150; Dr. Martin Sander Software Development (&quot;<I>OptiCode</I>&quot;).
<P>The SOFTWARE in this package is licensed to you as the user. It is not sold. The term &quot;user&quot; means a programmer who links binary code of this SOFTWARE into his own applications. Those people using, in turn, his applications without the need of installing this SOFTWARE themselves, do not need any runtime license for the SOFTWARE. The right to distribute applications containing code of this SOFTWARE is included in the license fee  for the <U>commercial version</U>.
<P>Once you have paid the required license fee, you may use the SOFTWARE for as long as you like, provided you do not violate the copyright and if you observe the following rules:
<OL>
<LI>You may use the SOFTWARE on any computer for which it is designed, as long as not more than one person uses it at any time.<BR>
<LI>You may make backup copies of the SOFTWARE for your personal use. You may only transfer the SOFTWARE to somebody else if you transfer the original and all copies, retaining no copies for yourself. You may not lease or rent the SOFTWARE to others.<BR>
<LI>You may not decompile, disassemble, or otherwise reverse engineer the SOFTWARE into a machine-readable form. You may, however, inspect the functions contained in this SOFTWARE by means of debuggers like those included in the Borland and Microsoft compilers.<BR>
<LI>If you payed the reduced licence fee for the &quot;educational version&quot; rather than the full rate for the &quot;commercial version&quot;, the use of this SOFTWARE is restricted to private and educational purposes. In this case, you may not use the SOFTWARE for commercial purposes or for government purposes other than education. 
<BR>Applications using functions of this SOFTWARE may be freely distributed (i.e. without any run-time licence) only if created with the &quot;commercial edition&quot; and on condition that the functions of this SOFTWARE are permanently linked into a program etc., but do not appear as a library to the user of that application.<BR>
<LI>You may not use the SOFTWARE in any environment or situation where personal injury or excessive damage to anyone's property (including your own) could arise from malfunctioning of the SOFTWARE.<BR>
<LI><I>OptiCode</I>'s liability is limited by the enclosed Limited Warranty. In no case shall <I>OptiCode</I>'s liability exceed the license paid for the right to use the SOFTWARE.
</OL>
<BR><B><U>Limited Warranty for the Registered version</U></B>
<OL><LI><I>OptiCode</I> warrants that the magnetic or optic media on which the SOFTWARE is recorded are free from defects in materials and workmanship under normal use. The SOFTWARE itself will perform substantially in accordance with the specifications set forth in the documentation.<BR>
<LI>The above express warranties are made for a period of six months from the date the SOFTWARE is delivered to you as the first user.<BR>
<LI>Any magnetic/optic or printed media from this package proving defective in materials or workmanship will be replaced on an exchange basis.<BR>
<LI>Great care has been taken to ensure that the SOFTWARE operates in accordance with the specifications as described in the documentation. However, it is not guaranteed that this SOFTWARE will operate completely free of errors or that the documentation is free of errors.<BR>
<LI>Any implied warranties including any warranties of merchantability or of fitness for a particular purpose are limited to the terms of the above express warranties.<BR>
<LI><I>OptiCode</I> shall not in any case be liable for special, incidental, consequential, indirect or other damages arising from any breach of these warranties or of the license conditions, even if he has been notified of the possibility of such damages.
</OL></b>
<BR>Copyright for the SOFTWARE and its documentation &copy; 1996-2002 <I>OptiCode</I> &#150; Dr. Martin Sander Software Development. All rights reserved.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap1_4"></a>
<H2>1.4 Getting Started</H2>
To install <I>OptiVec</I>, please follow these steps:
<OL>
<LI>In order to use <I>OptiVec</I>, you need an already installed copy of your C/C++, Delphi, or Pascal compiler. Install <I>OptiVec</I> by executing INSTALL.EXE from the root directory of the installation disk or CD-ROM. Normally, <I>OptiVec</I> will be installed into a directory named &quot;OPTIVEC&quot;. This directory holds the documentation.
<LI>Include the <I>OptiVec</I> lib and include (C/C++) or units (Pascal/Delphi) subdirectories into the search path.
<LI><U>a) C/C++:</U>
<BR>Assuming your <I>OptiVec</I> directory is C:\OPTIVEC, add
<BR>C:\OPTIVEC\LIB to the library search path and
<BR>C:\OPTIVEC\INCLUDE to the include-file search path of the IDE (and of the configuration file TURBOC.CFG and BCC32.CFG in case you are using Borland's command-line compilers).<BR>&nbsp;
<BR><U>b) Pascal/Delphi, Shareware version:</U>
<BR>Pascal: The units will be installed into the directory OPTIVEC\UNITS.<BR>Delphi: The units (.DCU files) will be installed into the directory OPTIVEC\LIB.<BR>&nbsp;
<BR><U>c) Pascal/Delphi, Registered version:</U>
<BR>Pascal: The units for 386+387 will be installed into the directory OPTIVEC\UNITS.
<BR>The additional units for 486/Pentium and for 286 are contained in the files UNITS2.ZIP and UNITS4.ZIP and are not automatically installed. If you wish to use them, manually create subdirectories OPTIVEC\UNITS4 or OPTIVEC\UNITS2 and unzip the files mentioned into them.
<BR>Delphi: The installation routine you have to execute is named after the target Delphi version: INSTALL2.EXE, INSTALL4.EXE, INSTALL5.EXE, and INSTALL6.EXE. The units (.DCU files) for 486 will be installed into OPTIVEC\LIB3, those for 486 into OPTIVEC\LIB4.
<LI>Choose the desired platform, target, and configuration:
<OL><LI><U>Borland C++:</U>
<BR>Choose the desired platform (DOS, Windows3.x, or Win32) and memory model. Select the required library from the following table (add the suffix .LIB) and add it to your project. 
<BR>The Shareware versions contain only libraries for either DOS-LARGE, Windows-LARGE, or Win32.
<BR>Borland C++ 16-bit models only:
<BR>If you wish to use <I>MatrixLib</I> functions, you must additionally include another library in your project list, whose name is derived from the names in the table by replacing the leading &quot;V&quot; by &quot;M&quot;. For example, for DOS-LARGE, 386, you would need VCL3.LIB and MCL3.LIB.
<BR>Likewise, if you wish to use <I>CMATH</I> functions, you have to add the <I>CMATH</I> library, whereby the letter &quot;V&quot; is replaced by &quot;CMATH&quot;. For the above example, this would be CMATHL3.LIB.<BR>&nbsp;
<table border width="90%">
<tr valign="top"><td>Platform</td><td>Memory Model</td><td>Required Processor</td></tr>
<tr><td>&nbsp;</TD><td>&nbsp;</TD><td><table width="100%"><tr><td width="25%">286</td><td width="21%">386+387</td><td width="29%">486DX/Pentium</td><td>Pentium III</td></tr></table></td></tr>
<tr><td>DOS</td><td>TINY</td><td><table width="100%"><tr><td width="25%">VCS2</td><td width="25%">VCS3</td><td width="25%">VCS4</td><td>&nbsp;</td></tr></table></td></tr>
<tr><td>DOS</td><td>SMALL</td><td><table width="100%"><tr><td width="25%">VCS2</td><td width="25%">VCS3</td><td width="25%">VCS4</td><td>&nbsp;</td></tr></table></td></tr>
<tr><td>DOS</td><td>MEDIUM</td><td><table width="100%"><tr><td width="25%">VCM2</td><td width="25%">VCM3</td><td width="25%">VCM4</td><td>&nbsp;</td></tr></table></td></tr>
<tr><td>DOS</td><td>COMPACT</td><td><table width="100%"><tr><td width="25%">VCC2</td><td width="25%">VCC3</td><td width="25%">VCC4</td><td>&nbsp;</td></tr></table></td></tr>
<tr><td>DOS</td><td>LARGE</td><td><table width="100%"><tr><td width="25%">VCL2</td><td width="25%">VCL3</td><td width="25%">VCL4</td><td>&nbsp;</td></tr></table></td></tr>
<tr><td>DOS</td><td>HUGE</td><td><table width="100%"><tr><td width="25%">VCH2</td><td width="25%">VCH3</td><td width="25%">VCH4</td><td>&nbsp;</td></tr></table></td></tr>
<tr><td>Windows</td><td>SMALL</td><td><table width="100%"><tr><td width="25%">VCS2W</td><td width="25%">VCS3W</td><td width="25%">VCS4W</td><td>&nbsp;</td></tr></table></td></tr>
<tr><td>Windows</td><td>MEDIUM</td><td><table width="100%"><tr><td width="25%">VCM2W</td><td width="25%">VCM3W</td><td width="25%">VCM4W</td><td>&nbsp;</td></tr></table></td></tr>
<tr><td>Windows</td><td>COMPACT</td><td><table width="100%"><tr><td width="25%">VCC2W</td><td width="25%">VCC3W</td><td width="25%">VCC4W</td><td>&nbsp;</td></tr></table></td></tr>
<tr><td>Windows</td><td>LARGE</td><td><table width="100%"><tr><td width="25%">VCL2W</td><td width="25%">VCL3W</td><td width="25%">VCL4W</td><td>&nbsp;</td></tr></table></td></tr>
<tr><td>32-bit Windows<BR>static run-time library<BR>dynamic run-time library</td><td>(FLAT)<BR>GUI or Console</td><td><table width="100%"><tr><td width="25%"></TD><td width="25%">&nbsp;<BR>VCF3W<BR>VCF3WD</td><td width="25%">&nbsp;<BR>VCF4W<BR>VCF4WD</td><td>&nbsp;<BR>VCF6W<BR>VCF6WD</td></tr></table></td></tr>
<tr><td>32-bit Windows<BR>static run-time library<BR>dynamic run-time library</td><td>(FLAT)<BR>Large-Vector-Version</td><td><table width="100%"><tr><td width="25%"></TD><td width="25%">&nbsp;<BR>&nbsp;<BR>&nbsp;</td><td width="25%">&nbsp;<BR>&nbsp;<BR>&nbsp;</td><td>&nbsp;<BR>VCF6L<BR>VCF6LD</td></tr></table></td></tr>
</table>&nbsp;

<LI><U>Visual C++:</U> Choose the target and configuration and add the corresponding <I>OptiVec</I> library to your project, according to the following table. Note that the Shareware version contains only the 486DX/Pentium libraries for single-thread debug and multi-thread debug.<BR>&nbsp;
<table border width="90%">
<tr valign="top"><td>Target</td><td>Configuration</td><td>486/Pentium library </td><td>Pentium III</td><td>Pentium III, Large-vector version</td></tr>
<tr valign="top"><td>single-thread</td><td>debug</td><td>OVVCSD.LIB</td><td>OVVCSD6.LIB</td><td>OVVCLSD6.LIB</td></tr>
<tr valign="top"><td>single-thread</td><td>release</td><td>OVVCSR.LIB</td><td>OVVCSR6.LIB</td><td>OVVCLSR6.LIB</td></tr>
<tr valign="top"><td>multi-thread</td><td>debug</td><td>OVVCMTD.LIB</td><td>OVVCMTD6.LIB</td><td>OVVCLTD6.LIB</td></tr>
<tr valign="top"><td>multi-thread</td><td>release</td><td>OVVCMTR.LIB</td><td>OVVCMTR6.LIB</td><td>OVVCLTR6.LIB</td></tr>
<tr valign="top"><td>multi-thread DLL</td><td>debug</td><td>OVVCMDD.LIB</td><td>OVVCMDD6.LIB</td><td>OVVCLDD6.LIB</td></tr>
<tr valign="top"><td>multi-thread DLL</td><td>release</td><td>OVVCMDR.LIB</td><td>OVVCMDR6.LIB</td><td>OVVCLDR6.LIB</td></tr>
</table>&nbsp;<BR>
In order to allow <I>OptiVec</I> to be used in applications both with and without MFC, it calls the Windows API only directly, not <I>via</I> MFC.  However, if you use MFC (either as a static library or as a DLL), Visual C++ does not automatically link the import library, <font face="courier new">user32.lib</font>. You have to explicitly do this yourself: The line, <font face="Courier new">Project / Settings / Linker / Object and Library Modules</font> must contain <font face="courier new">user32.lib</font>. Otherwise you would get the linker error "error LNK2001: Unresolved external symbol __imp__MessageBoxA@??".<BR>&nbsp;

<LI><U>Borland Pascal:</U><BR>Choose the target DOS real mode or (for the registered version only) DOS protected-mode.<BR>If you can, use the protected-mode version of the compiler, i.e., BP.EXE or TPX.EXE. The real-mode version, TP.EXE, might run out of link memory. If you encounter that problem, set the linker option "link buffer" to "disk". If even that does not help, you can only use the command-line compiler.<BR>&nbsp;
<LI><U>Borland Delphi:</U><BR>
No choices are to be made at this level.
</OL>
<LI>Declare the use of <I>OptiVec</I> functions in your program:
<UL><LI><U>C/C++:</U><BR>
Use #include directives to include the header files described in <a href="#chap7">chapter 7.</a>
<BR>To get the whole <I>OptiVec</I> library at once, along with its new object-oriented interface, declare
<BR><font face="courier new"> #include &lt;OptiVec.h&gt;</font>
<BR>To get only all vector functions (without the object-oriented interface),<BR>
<font face="courier new"> #include &lt;VecAll.h&gt;</font>
<BR>To add all data-fitting and matrix functions to that,
<BR><font face="courier new"> #include &lt;MatAll.h&gt;.</font>
<BR>If you are writing MFC or Borland C++ ObjectWindows applications, any <I>OptiVec</I> header files should be included after the MFC or OWL header files.
<LI><U>Pascal/Delphi:</U><BR>
 Declare the use of <I>OptiVec</I> units as usual with the &quot;uses&quot; statement. The <I>OptiVec</I> units are grouped according to the data type. See <a href="#chap7">chapter 7.</a> In Delphi, <I>OptiVec</I> units should always be used together with the WinProcs unit, as some data types are borrowed from it.
</UL>
<LI>Borland C/C++ 16-bit programs only:
<UL><LI>If the linker option &quot;process extended dictionaries&quot; is available in your version of Borland C++, you must switch it on. Otherwise, you might get a &quot;Table limit exceeded&quot; linker error.
<LI><I>OptiVec</I> works with Borland (Turbo) C++, version 3.0 or higher. Since, from version 4.0 on, Borland changed the name of the error handling routine <I>matherr</I> (without underbar) into <I>_matherr</I> (with a leading underbar), any 16-bit program using <I>OptiVec</I> has to call a macro, NEWMATHERR, which takes care of redirecting calls to <I>_matherr</I>, if necessary. You should place the call to NEWMATHERR into the module containing <I>main()</I> or <I>OwlMain()</I>:
<BR><font face="courier new"> #include .....
<BR>#include &lt;VecAll.h&gt;
<BR>NEWMATHERR
<BR>int main( void )
<BR>{ .......... }</font>
<BR>If you forget to call NEWMATHERR, you will get a linker error &quot;Unresolved external <I>_matherr</I>&quot; in the Borland C versions from 4.0 on. Inclusion of the macro NEWMATHERR is not needed for 32-bit programs.
</UL>
<LI>Have a look into the sample programs:
<UL><LI>VDEMOW.CPP and FITDEMOW.CPP (C/C++, all Windows models)
<LI>VDEMOB.BPR and FITDEMOB.BPR (project files for Borland C++ Builder 4 or higher)<BR>
<LI>VDEMO.CPP  and FITDEMO.CPP (Borland C++, DOS)
<LI>VDEMOW1.CPP and VDEMOW2.CPP (use only with Borland's OWL)
<LI>CDEMO.CPP shows a very simple example for the use of <I>CMATH</I> functions.<BR>&nbsp;
<LI>VDEMO.DPR and FITDEMO.DPR (Delphi projects)
<LI>VDEMO.PAS and FITDEMO.PAS (Borland Pascal, DOS)
<LI>CDEMO.PAS (Borland Pascal and Delphi console application)
</OL>
After these preparations, all <I>OptiVec</I> functions are available for your programs.
<BR>Should you wish to remove <I>OptiVec</I> from your computer, please run UNINSTAL.EXE or simply delete the directory <font face="courier new">OPTIVEC</font> with its subdirectories.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap2"></a>
<H1><HR width="100%">2. Elements of <I>OptiVec</I> Routines</H1>
<P><a name="chap2_1"></a>
<H2>2.1 Synonyms for Some Data Types</H2>
To increase the versatility and completeness of <I>OptiVec</I>, additional data types are defined in &lt;VecLib.h&gt; or the unit VecLib:
<h3>a) C/C++ only:</h3>
The data type <B>ui</B> (short for &quot;unsigned index&quot;) is used for the indexing of vectors and is defined as &quot;unsigned int&quot;. Only in the HUGE model (supported in the registered version of <I>OptiVec</I> for Borland C++), <B>ui</B> is defined as &quot;unsigned long&quot;, in order to correctly address huge arrays (greater than 64 kBytes, but with 16-bit addressing).
<P>Starting already with the 8086/8087 processor pair, the Intel processors are able to process integer numbers of up to 64 bits (8 bytes). We call the 64-bit type &quot;quad&quot; (for &quot;quadword integer&quot;). It is not fully supported by Borland C++. Therefore, floating-point numbers (preferably long doubles with their 64-bit mantissa) have to be used as intermediates. The necessary interface functions are <I><a href="FUNCREF.HTM#setquad">setquad</a>, <a href="FUNCREF.HTM#quadtod">quadtod</a></I> and <I><a href="FUNCREF.HTM#quadtod">_quadtold</a></I>.
<BR>The type <B>quad</B> is always signed. There is not anything like an &quot;unsigned quad&quot;.  
<P>The data type <B>extended</B>, which is familiar to Pascal/Delphi programmers, is defined as a synonym for &quot;long double&quot; in <I>OptiVec</I> for C/C++. As Visual C++ does not support 80-bit reals, we define &quot;extended&quot; as &quot;double&quot; in the <I>OptiVec</I> versions for that compiler.
<BR>The reason for the choice of the name &quot;extended&quot; is that all <I>OptiVec</I> routines shall have identical names in C/C++ and Pascal/Delphi languages. Since the function prefixes are derived from the data types of the processed vectors (see below), this necessitates the definition of alias names for some data types denoted differently in the various languages. While the letter &quot;L&quot; (which could possibly stand for &quot;long double&quot;) is already overcrowded by the data types long int and unsigned long, the letter &quot;E&quot; is unique to the data type extended and therefore used in the prefixes for vectors and functions of long double precision. This way, the letters defining the real- number data types are in alphabetical proximity: &quot;D&quot; for double, &quot;E&quot; for extended, and &quot;F&quot; for float. Maybe the future will bring high-precision 128-bit and 256-bit real numbers which could find their place in this series as &quot;G&quot; for &quot;great&quot; and &quot;H&quot; for &quot;hyper&quot;.

<h3>b) Pascal/Delphi only:</h3>
The data type Float, which is familiar to C/C++ programmers, is defined as a synonym for Single. We prefer to have the letters defining the real-number data types in alphabetical proximity: "D" for Double, "E" for Extended, and "F" for Float. As noted above, possible future 128-bit and 256-bit real numbers could find their place in this series as "G" for Great and "H" for Hyper. 
<P>For historical reasons, the various integer data types have a somewhat confusing nomenclature in Turbo Pascal. The WinProcs unit of Delphi offers already a more systematic nomenclature. In order to make the derived function prefixes compatible with the C/C++ versions of <I>OptiVec</I>, we define those synonyms present in Delphi (and a few more) also for 16-bit Pascal, as described in the following table:

<table border width="100%">
<tr><td>type</td><td>Pascal name</td><td>synonym</td><td>derived prefix</td></tr>
<tr><td>8 bit signed</td><td>ShortInt</td><td>ByteInt</td><td>VBI_</td></tr>
<tr><td>8 bit unsigned</td><td>Byte</td><td>UByte</td><td>VUB_</td></tr>
<tr><td>16 bit signed </td><td>SmallInt</td><td>&nbsp;</TD><td>VSI_</td></tr>
<tr><td>16 bit unsigned </td><td>Word</td><td>USmall</td><td>VUS_</td></tr>
<tr><td>32 bit signed </td><td>LongInt</td>&nbsp;<td></TD><td>VLI_</td></tr>
<tr><td>32 bit unsigned </td><td>&nbsp;</TD><td>ULong</td><td>VUL_</td></tr>
<tr><td>64 bit signed </td><td>Comp</td><td>QuadInt</td><td>VQI_</td></tr>
<tr><td>16/32 bit signed</td><td>Integer</td><td>&nbsp;</TD><td>VI_</td></tr>
<tr><td>16/32 bit unsigned</td><td>Cardinal</td><td>UInt</td><td>VU_</td></tr>
</table>

<P><U>Pascal and Delphi 2 only:</U>
<BR>The unsigned 32-bit integer type <B>ULong</B> is treated as such only  inside <I>OptiVec</I> routines. Otherwise, all <B>ULong</B> variables will be treated  as <B>LongInt</B>. This means that the most significant bit will then be interpreted  as the sign bit, which may lead to errors, unless proper care is taken to  avoid mistakes. Delphi 4+ always treats <B>ULong</B> as such.
<BR><B>QuadInt</B>s are always signed. As yet, there is nothing like a "UQuad".

<P><U>Delphi 4 or higher:</U>
<BR>As Delphi 4+ supports 64-bit integers, <B>QuadInt</B> is not defined as <B>Comp</B>, but is used as a synonym for the new data type <B>Int64</B>.

<P>To have a Boolean data type available which is of the same size as Integer, we define the type <B>IntBool</B>. It is equivalent to <B>WordBool</B> in Pascal, but <B>LongBool</B> in Delphi. You will see the <B>IntBool</B> type as the return value of many mathematical <I>VectorLib</I> functions. 
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<a name="chap2_2"></a>
<H2>2.2 Complex Numbers:
<BR>The Data Types fComplex, dComplex, eComplex, fPolar, dPolar, and ePolar</H2>
Complex numbers are treated in C/C++ in quite a confusing way. ANSI C offers only a struct complex, Borland's C/C++ compiler additionally a struct _complexl for complex numbers of double and long double precision, resp. The real and imaginary parts are denoted as x and y. 
<BR>From early versions on, Borland C++ has also offered a class complex which is of double precision; the real and imaginary parts are accessible via the functions real and imag. There is also a number of mathematical functions
available for this class.
<BR>Finally, the Standard C++ library, included from Borland C++ 5 on (but not in Visual C++), offers the classes complex&lt;float&gt;, complex&lt;double&gt;, and complex&lt;long double&gt;, equipped with basic functionality and the same range of mathematical functions as offered by the class complex.
<BR>Functions in polar coordinates are not available in any of these approaches.

<P>Most compilers and available libraries implement complex functions very inefficiently and inaccurately. (Just writing down the textbook formula for a complex function, like it is usually done, works fine only for a very limited range of arguments!)

<P>Our aims are
<UL><LI>to make the use of complex numbers of all three data types possible in Pascal/Delphi and C as well as in C++,
<LI>to support both cartesian and polar coordinates
<LI>to allow for the most efficient implementation of all complex operations, using assembler code instead of C++ templates,
<LI>and to introduce an easy, compact and consistent nomenclature.
</UL>
To this end, the complex math library <I>CMATH</I> was created and is included in <I>OptiVec</I>. <I>CMATH</I> is described in greater detail in the file <a href="CMATH.HTM">CMATH.HTM</a>. If you use any of the non-vectorized functions contained in <I>CMATH</I> with C/C++, you should include &lt;newcplx.h&gt; (for C++ modules) or &lt;cmath.h&gt; (for plain-C modules) before (!) any of the <I>VectorLib</I> include files.

<P><I>VectorLib</I> itself contains the necessary initialization functions of complex numbers and all vectorized forms of complex math functions. If you are using only these, you need not explicitly include <I>CMATH</I>. In this case, the following complex data types are defined in &lt;VecLib.h&gt; for C/C++:
<BR><font face="courier new"> typedef struct { float Re, Im; } fComplex;
<BR>typedef struct { double Re, Im; } dComplex;
<BR>typedef struct { extended Re, Im; } eComplex;
<BR>typedef struct { float Mag, Arg; } fPolar;
<BR>typedef struct { double Mag, Arg; } dPolar;
<BR>typedef struct { extended Mag, Arg; } ePolar;</font>
<BR>(the data type extended is used as a synonym for long double, see above.)

<P>The corresponding definitions for Pascal/Delphi are contained in the unit VecLib:<font face="courier new">
<BR>type fComplex = record Re, Im: Float; end;
<BR>type dComplex = record Re, Im: Double; end;
<BR>type eComplex = record Re, Im: Extended; end;
<BR>type fPolar = record Mag, Arg: Float; end;
<BR>type dPolar = record Mag, Arg: Double; end;
<BR>type ePolar = record Mag, Arg: Extended; end;</font>

<P>If, for example, a complex number z is declared as &quot;fComplex z;&quot;, the real and imaginary parts of z are available as z.Re and z.Im, resp. Complex numbers are initialized either by setting the constituent parts separately to the desired value, e.g.,<font face="courier new">
<BR>	z.Re = 3.0; z.Im = 5.7;
<BR>p.Mag = 4.0; p.Arg = 0.7;</font>
<BR>(of course, the assignment operator is := in Pascal/Delphi).
<BR>Alternatively, the same initialization can be accomplished by the
functions <I><a href="FUNCREF.HTM#fcplx">fcplx</a></I> or <I><a href="FUNCREF.HTM#fpolr">fpolr</a></I>:
<BR><U>C/C++:</U><font face="courier new">
<BR>z = fcplx( 3.0, 5.7 );
<BR>p = fpolr( 4.0, 0.7 );</font>
<BR><U>Pascal/Delphi:</U><font face="courier new">
<BR>fcplx( z, 3.0, 5.7 );
<BR>fpolr( p, 3.0, 5.7 );</font>

<P>For double-precision complex numbers, use <I>dcplx</I> and <I>dpolr</I>, for extended-precision complex numbers, use <I>ecplx</I> and <I>epolr</I>.
<BR>Pointers to arrays or vectors of complex numbers are declared using the data types cfVector, cdVector, and ceVector (for cartesian complex) and pfVector, pdVector, and peVector (for polar complex) described below.
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<a name="chap2_3"></a>
<h2>2.3 Vectors and Arrays:
<BR>The Data Types fVector, dVector, eVector,
<BR> cfVector, cdVector, ceVector, pfVector, pdVector, peVector,
<BR> iVector, biVector, siVector, liVector, qiVector,
<BR>uVector, ubVector, usVector, ulVector, and uiVector</h2>
We define, as usual, a &quot;vector&quot; as a one-dimensional array of data containing, at least, one element, with all elements being of the same data type. Using a more mathematical definition, a vector is a rank-one tensor. A two-dimensional array (i.e. a rank-two tensor) is denoted as a &quot;matrix&quot;, and higher dimensions are always referred to as &quot;tensors&quot;.
<BR><B>In contrast to other approaches, <I>VectorLib</I> does not allow zero-size vectors!</B><P>The basis of all <I>VectorLib</I> routines is formed by the various vector data types given below and declared in &lt;VecLib.h&gt; or the unit VecLib.  In contrast to the fixed-size static arrays, the <I>VectorLib</I> types use dynamic memory allocation and allow for varying sizes. Because of this increased flexibility, we recommend that you predominantly use the latter. Here they are:<BR>&nbsp;

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=0 WIDTH="95%">
<TR><TD ALIGN="CENTER"><font size="+1"><B>C/C++</B></font><BR>
<TABLE BORDER=0 WIDTH="97%" >
<TR><TD>typedef</td><td>float *</td><td>fVector</td></tr>
<TR><TD>typedef</td><td>double *</td><td>dVector</td></tr>
<TR><TD>typedef</td><td>extended *</td><td>eVector</td></tr>
<TR><TD>typedef</td><td>fComplex *</td><td>cfVector</td></tr>
<TR><TD>typedef</td><td>dComplex *</td><td>cdVector</td></tr>
<TR><TD>typedef</td><td>eComplex *</td><td>ceVector</td></tr>
<TR><TD>typedef</td><td>fPolar *</td><td>pfVector</td></tr>
<TR><TD>typedef</td><td>dPolar *</td><td>pdVector</td></tr>
<TR><TD>typedef</td><td>ePolar *</td><td>peVector</td></tr>
<TR><TD>typedef</td><td>int *</td><td>iVector</td></tr>
<TR><TD>typedef</td><td>byte *</td><td>biVector</td></tr>
<TR><TD>typedef</td><td>short *</td><td>siVector</td></tr>
<TR><TD>typedef</td><td>long *</td><td>liVector</td></tr>
<TR><TD>typedef</td><td>quad *</td><td>qiVector</td></tr>
<TR><TD>typedef</td><td>unsigned *</td><td>uVector</td></tr>
<TR><TD>typedef</td><td>unsigned byte *</td><td>ubVector</td></tr>
<TR><TD>typedef</td><td>unsigned short *</td><td>usVector</td></tr>
<TR><TD>typedef</td><td>unsigned long *</td><td>ulVector</td></tr>
<TR><TD>typedef</td><td>ui *</td><td>uiVector</td></tr>
</TABLE>
</TD><TD>&nbsp;</TD>
<TD VALIGN="TOP" ALIGN="CENTER"><font size="+1"><B>Pascal/Delphi</B></font><BR>
<TABLE ALIGN=RIGHT BORDER=0 WIDTH="100%" >
<TR><TD>type</td><td>fVector</td><td>= ^Float;</td></tr>
<TR><TD>type</td><td>dVector</td><td>= ^Double;</td></tr>
<TR><TD>type</td><td>eVector</td><td>= ^Extended;</td></tr>
<TR><TD>type</td><td>cfVector</td><td>= ^fComplex;</td></tr>
<TR><TD>type</td><td>cdVector</td><td>= ^dComplex;</td></tr>
<TR><TD>type</td><td>ceVector</td><td>= ^eComplex;</td></tr>
<TR><TD>type</td><td>pfVector</td><td>= ^fPolar;</td></tr>
<TR><TD>type</td><td>pdVector</td><td>= ^dPolar;</td></tr>
<TR><TD>type</td><td>peVector</td><td>= ^ePolar</td></tr>
<TR><TD>type</td><td>iVector</td><td>= ^Integer;</td></tr>
<TR><TD>type</td><td>biVector</td><td>= ^ByteInt;</td></tr>
<TR><TD>type</td><td>siVector</td><td>= ^SmallInt;</td></tr>
<TR><TD>type</td><td>liVector</td><td>= ^LongInt;</td></tr>
<TR><TD>type</td><td>qiVector</td><td>= ^QuadInt;</td></tr>
<TR><TD>type</td><td>uVector</td><td>= ^UInt;</td></tr>
<TR><TD>type</td><td>ubVector</td><td>= ^UByte;</td></tr>
<TR><TD>type</td><td>usVector</td><td>= ^USmall;</td></tr>
<TR><TD>type</td><td>ulVector</td><td>= ^ULong;</td></tr>
<TR><TD></TD><td></TD><td></TD></tr>
</table>
</TD></TR>
</TABLE>

<BR>Internally, a data type like fVector means &quot;pointer to float&quot;, but you may think of a variable declared as fVector rather in terms of a &quot;vector of floats&quot;.<BR>&nbsp;
<table width="100%"><tr><td width="10%"></TD><td>
<font size="-1"><U>Note:</U> in connection with Windows programs, often the letter &quot;l&quot; or &quot;L&quot; is used to denote &quot;long int&quot; variables. In order to prevent confusion, however, the data type &quot;long int&quot; is signalled by &quot;li&quot; or &quot;LI&quot;, and the data type &quot;unsigned long&quot; is signalled by &quot;ul&quot; or &quot;UL&quot;. Conflicts with prefixes for &quot;long double&quot; vectors are avoided by deriving these from the alias name &quot;extended&quot; and using &quot;e&quot;, &quot;ce&quot;, &quot;E&quot;, and &quot;CE&quot;, as described above and in the following.</font></td></tr></table>&nbsp;

<BR><U>C/C++ specific</U>:<BR>
Vector elements can be accessed either with the [] operator, like <font face="courier new">VA[375] = 1.234;</font>
<BR>or by the type-specific functions <I><a href="FUNCREF.HTM#element">VF_element</a></I> (returns the value of the
desired vector element, but cannot be used to overwrite the element) and <I><a href="FUNCREF.HTM#Pelement">VF_Pelement</a></I> (returns the pointer to a vector element). The latter function may be used to set vector values, e.g.
<BR><font face="courier new">*<a href="FUNCREF.HTM#Pelement">VF_Pelement</a>( X, 3 ) = 5.7;</font>
<BR>Especially for some older Borland C versions (which have a bug in the pointer-arithmetics), <I><a href="FUNCREF.HTM#Pelement">VF_Pelement</a></I> has to be used instead of the syntax X+n.
<BR>In your programs, you may mix these vector types with the static arrays of classic C style.
<BR>For example:<font face="courier new">
<BR>float a[100]; /* classic static array */
<BR>fVector b=<a href="FUNCREF.HTM#vector">VF_vector</a>(100); /* <I>VectorLib</I> vector */
<BR><a href="FUNCREF.HTM#equ1">VF_equ1</a>( a, 100 ); /* set the first 100 elements of a equal to 1.0 */
<BR><a href="FUNCREF.HTM#equC">VF_equC</a>( b, 100, 3.7 ); /* set the first 100 elements of b equal to 3.7 */</font>

<P><U>Pascal/Delphi specific:</U><BR>
The elements of <I>OptiVec</I> vectors cannot be accessed with the [] operator here. Instead, the the type-specific functions <I><a href="FUNCREF.HTM#element">VF_element</a></I> (returns the value of the
desired vector element, but cannot be used to overwrite the element) and <I><a href="FUNCREF.HTM#Pelement">VF_Pelement</a></I> (returns the pointer to a vector element) have to be used. The latter function allows to set vector values, e.g.
<BR><font face="courier new"><a href="FUNCREF.HTM#Pelement">VF_Pelement</a>( X, 3 )^ := 5.7;</font>
<BR>As in C/C++, you may mix the <I>OptiVec</I> vector types with the static arrays of classic Pascal style. Static arrays have to be passed to <I>OptiVec</I> functions with the &quot;address of&quot; operator. Here, the above example reads:
<font face="courier new">
<BR>a: array[0..99] of Single; (* classic static array *)
<BR>b: fVector;(* <I>VectorLib</I> vector *)
<BR>b := <a href="FUNCREF.HTM#vector">VF_vector</a>(100); 
<BR><a href="FUNCREF.HTM#equ1">VF_equ1</a>( @a, 100 ); (* set first 100 elements of a = 1.0 *)
<BR><a href="FUNCREF.HTM#equC">VF_equC</a>( b, 100, 3.7 ); (* set first 100 elements of b = 3.7 *)</font>

<BR>From Delphi 4 on, Delphi also offers dynamically-allocated arrays, which may also be used as arguments for <I>OptiVec</I> functions. The following table compares the pointer-based vectors of <I>VectorLib</I> with the array types of Pascal/Delphi:
<BR>&nbsp;

<table border=1><tr valign="top"><td>&nbsp;</TD><td><I>OptiVec</I> vectors</td><td>Pascal/Delphi static/dynamic arrays</td></tr>
<tr valign="top"><td>alignment of first element</td><td>on 32-byte boundary for optimum cache-line matching</td><td>2 or 4-byte boundary (may cause line-break penalty for double, QuadInt)</td></tr>
<tr valign="top"><td>alignment of following elements</td><td>packed (i.e., no dummy bytes between elements, even for 10- and 20-bit types</td><td>arrays must be declared as &quot;packed&quot; for Delphi 4+ to be compatible with <I>OptiVec</I></td></tr>
<tr valign="top"><td>index range checking</td><td>none</td><td>automatic with built-in size information</td></tr>
<tr valign="top"><td>dynamic allocation</td><td>function <a href="FUNCREF.HTM#vector">VF_vector</a>,&nbsp; <a href="FUNCREF.HTM#vector0">VF_vector0</a></td><td>procedure SetLength (Delphi 4+ only)</td></tr>
<tr valign="top"><td>initialization with 0</td><td>optional by calling <a href="FUNCREF.HTM#vector0">VF_vector0</a></td><td>always (Delphi 4+ only)</td></tr>
<tr valign="top"><td>de-allocation</td><td>function <a href="FUNCREF.HTM#free">V_free</a>,&nbsp; <a href="FUNCREF.HTM#freeAll">V_freeAll</a></td><td>procedure Finalize (Delphi 4+ only)</td></tr>
<tr valign="top"><td>reading single elements</td><td>function <a href="FUNCREF.HTM#element">VF_element</a>:<BR>a := VF_element(X,5);<BR>Delphi 4+ only: typecast into array also possible:<BR>a := fArray(X)[5];</td><td>index in brackets:<BR>a := X[5];</td></tr>
<tr valign="top"><td>setting single elements</td><td>function <a href="#FUNCREF.HTM#Pelement">VF_Pelement</a>:<BR>VF_Pelement(X,5)^ := a;<BR>Delphi 4+ only: typecast into array also possible:<BR>fArray(X)[5] := a;</td><td>index in brackets:<BR>X[5] := a;</td></tr>
<tr valign="top"><td>passing to <I>OptiVec</I> function</td><td>directly:<BR><a href="FUNCREF.HTM#equ1">VF_equ1</a>( X, sz );</td><td>address-of operator:<BR><a href="FUNKREF.HTM#equ1">VF_equ1</a>( @X, sz );</td></tr>
<tr valign="top"><td>passing sub-vector to <I>OptiVec</I> function</td><td>function <a href="#FUNCREF.HTM#Pelement">VF_Pelement</a>:<BR><a href="FUNCREF.HTM#equC">VF_equC</a>( VF_Pelement(X,10), sz-10, 3.7);</td><td>address-of operator:<BR><a href="FUNCREF.HTM#equC">VF_equC</a>( @X[10], sz-10, 3.7 );</td></tr>
</table>&nbsp;
<BR>Summarizing the properties of <I>OptiVec</I> vectors and of Pascal/Delphi arrays, the latter are somewhat more convenient and, due to the index range checking, safer, whereas the pointer-based <I>OptiVec</I> vectors are processed faster (due to the better alignment and to the absence of checking routines).

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap2_4"></a>
<h2>2.4 Real-number Functions:
<BR>The Prefixes <I>VF_,&nbsp; VD_</I>, and <I>VE_</I></h2>
<I>OptiVec</I> supports the three floating-point data types that are used by the coprocessors of the 80x87 family and the FPU units integrated into the 486DX and Pentium processors and their successors: float, double, and extended (i.e., long double). BCD numbers are not supported.
<P>Any of the algebraic and mathematical functions included in this library exists in one variant for each floating-point format. The data type of all floating-point vector elements, parameters, and of the return value is always the same within one function. The data type is signalled by the second letter of the prefix: <I>VF_</I> denotes the variant of a function that uses exclusively the data type float (Pascal: Single), <I>VD_</I> stands for the data type double, and <I>VE_</I> for the data type extended, i.e., long double. (The first letter, &quot;V&quot;, stands for &quot;Vector function&quot;, of course.) <I>VF_</I> functions thus work on arrays declared as fVector, use parameters of the type float, and, if there is any floating-point return value, this will also be of the type float. Except for a very few cases, there are no mixed-type functions (that would, e.g., work on vectors of type fVector, use parameters of type double and return a value of type long double). 
<P>One partial exception from this rule comes from the fact that floating-point return values of <I>OptiVec</I> functions are returned in extended precision on the number stack. Therefore, you may assign the return value of a function to a variable of another data type. For example, the product of all elements of a vector may easily overflow, and it is a good idea to define eProd as an extended (i.e., as a long double), before writing the line<BR><font face="courier new"> eProd = <a href="FUNCREF.HTM#prod">VF_prod</a>( X, size ); </font>

<P><U>Borland C++ only:</U><BR>
To use this possibility, you must switch the option &quot;Fast floating point&quot; on (in the IDE in the menu &quot;Options/Compiler/Advanced Code Generation&quot;, or the command-line compiler option &quot;-ff&quot;),
<P>For the description of the functions in the <a href="FUNCREF.HTM#chap8">Alphabetical Reference</a>, generally only the <I>VF_</I> version is described and its syntax explicitly given. The versions for the data types double and long double
are exactly analogous to the <I>VF_</I> variant. You have only to replace the prefix <I>VF_</I> by <I>VD_</I> (or <I>VE_</I>) and to use &quot;dVector&quot; and &quot;double&quot; (or &quot;eVector&quot; and &quot;extended&quot;, resp.) wherever you find &quot;fVector&quot; and &quot;float&quot; in the <I>VF_</I> version.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap2_5"></a>
<h2>2.5 Complex-number Functions:
<BR>The Prefixes <I>VCF_,&nbsp; VCD_,&nbsp; VCE_,&nbsp; VPF_,&nbsp; VPD_</I>, and <I>VPE_</I></h2>
Any prefix with its second letter being &quot;C&quot; denotes a function of cartesian complex numbers. If the second letter is &quot;P&quot;, the function is for complex numbers in polar coordinates. By analogy with the nomenclature used for real-number functions, the prefix <I>VCF_</I> signals the exclusive use of single-precision vectors, parameters and return values (fComplex, cfVector and float). Similarly, <I>VCD_</I> is used for double-precision calculations, and <I>VCE_</I> for extended precision. Wherever &quot;fComplex&quot;, &quot;cfVector&quot;, and &quot;float&quot; appear in the description of a function in the <I>VCF_</I> version, the <I>VCD_</I> and <I>VCE_</I> versions are obtained by substituting with &quot;dComplex&quot;, &quot;cdVector&quot; and &quot;double&quot; or &quot;eComplex&quot;, &quot;ceVector&quot;, and &quot;extended&quot; (or &quot;long double&quot;), respectively. Likewise, the <I>VPF_,&nbsp; VPD_</I>, and <I>VPE_</I> functions work on vector elements of the types fPolar, dPolar, and ePolar, resp.
<P>Return values of the complex data types are not possible in Pascal/Delphi. Therefore, the syntax of those functions returning a complex number is different in C/C++ and Pascal/Delphi.
<P>In contrast to the carelessness with which complex mathematical functions are often treated (see above), the complex functions of <I>OptiVec</I> are designed in such a way as to achieve full accuracy over the complete range of input/output values possible with the respective data type.
<P>In order to perform non-vectorized complex operations with the same level of speed and reliability as the vectorized ones, use <I>CMATH</I>. See <a href="CMATH.HTM">CMATH.HTM</a> for details.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap2_6"></a>
<h2>2.6 Functions of the Integer Data Types:
<BR>The Prefixes <I>VI_,&nbsp; VBI_,&nbsp; VSI_,&nbsp; VLI_,&nbsp; VQI_</I>,<BR>
<I>VU_,&nbsp; VUB_,&nbsp; VUS_,&nbsp; VUL_</I>, and <I>VUI_</I></h2>
The nomenclature for the integer data types is designed in a similar way as for the floating-point data types: <I>VI_</I> indicates the use of the data type int, <I>VBI_</I> stands for byte-sized int, <I>VSI_</I> for short int, <I>VLI_</I> for long int and <I>VQI_</I> for quad integers. <I>VU_</I> denotes operations with unsigned integers, <I>VUB_</I> with unsigned byte, <I>VUS_</I> with unsigned short and <I>VUL_</I> is the prefix for functions of unsigned long arguments.<BR>
<U>C/C++ only:</U> For operations on index-arrays, functions with the prefix <I>VUI_</I> allow to perform calculations using arguments of the data type ui defined above. The <I>VUI_</I> versions are always defined as macros, and the compiler automatically substitutes either the <I>VU_</I> or the <I>VUL_</I> version, whichever is appropriate for the memory model actually used. In Pascal/Delphi, no <I>VUI_</I> functions are defined.

<P>Don't be afraid of so many data types. It is one of the advantages of modern computer languages to have them, and it is one of the disadvantages, at the same time, that a programming style is supported which mixes all the data types until it is no longer clear &quot;who is who&quot;. In all normal cases, the <I>VI_,&nbsp; VLI_</I>, and <I>VU_</I> functions should be sufficient; but keep in mind that there are more available in case you need them.
<P>If present, the vectorized integer functions are always described together with their floating-point analogues. To obtain, for example, the <I>VI_</I> version, vectors of type iVector have to be substituted for those of type fVector which are demanded by the <I>VF_</I> version. In the same way, the other versions are obtained by changing &quot;float&quot; and &quot;fVector&quot; into the desired data type.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap2_7"></a>
<H2>2.7 Common Functions of Several Data Types: The Prefix <I>V_</I></H2>
Several functions exist that are either used independently of any data type or that are used to interconvert the data types. Functions like <I><a href="FUNCREF.HTM#initPlot">V_initPlot</a></I> and <I><a href="FUNCREF.HTM#free">V_free</a></I> belong to the first case (you have to initialize the plotting routines regardless of the data type of the vectors you are going to plot, and the initialization is not specific for any data type).
<BR>A function like <I><a href="FUNCREF.HTM#ItoF">V_ULtoD</a></I> belongs to the second case; here, a ulVector
(a vector whose elements are of the data type unsigned long) is transformed into a dVector (a vector whose elements are doubles).
<BR>The type-independent functions are declared in &lt;VecLib.h&gt; and &lt;Vgraph.h&gt; or the units VecLib and Vgraph, respectively. The data-type interconversion functions are declared in the include-files or units belonging to the destination type (i.e. the type into which the numbers are converted).

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap3"></a>
<H1><HR width="100%">3. <I>VecObj</I>, theObject-Oriented Interface for <I>VectorLib</I></H1>
<I>VecObj</I>, the object-oriented C++ interface to <I>OptiVec</I> vector functions was written by Brian Dale, Case Western Reserve University.
<BR>Among the advantages it offers are the following:
<UL><LI>automatic allocation and deallocation of memory
<LI>simplified vector handling
<LI>greatly reduced risk of memory leaks
<LI>increased memory access safety
<LI>intuitive overloaded operators
<LI>simpler function calls
</UL>
There are a few draw-backs, though, which you should be aware of:
<UL><LI>increased compiler load
<LI>larger overhead (as for any encapsulated C++ code!), leading to 
<LI>increased code size
<LI>decreased computational efficiency
<LI>vectors can be processed only as a whole, not in parts
</UL>
<I>VecObj</I> is contained in the include-files &lt;VecObj.h&gt;, &lt;fVecObj.h&gt;, &lt;dVecObj.h&gt; etc., with one include-file for each of the data-types supported in <I>OptiVec</I>.
<BR>To get the whole interface (for all data types at once),
<BR><font face="courier new">#include &lt;OptiVec.h&gt;.</font>
<BR>For access to any of the vector graphics functions, always include &lt;OptiVec.h&gt;.
<P><U>MS Visual C++ and Borland C++ Builder</U> (but not previous Borland C++ versions): Programmers should put the directive
<BR><font face="courier new">&quot;using namespace OptiVec;&quot;</font>
<BR>either in the body of any function that uses<I>tVecObj</I>, or in the global declaration part of the program.  Placing the directive in the function body is safer, avoiding potential namespace conflicts in other functions.
<BR>The vector objects are defined as classes vector&lt;T&gt;, encapsulating the vector address (pointer) and size.
<BR>For easier use, these classes got alias names fVecObj, dVecObj, and so on, with the data-type signalled by the first one or two letters of the class name, in the same way as the vector types described above.
<P>All functions defined in <I>VectorLib</I> for a specific vector data-type are contained as member functions in the respective tVecObj class.
<BR>The constructors are available in four forms:
<BR>vector(); // no memory allocated, size set to 0
<BR>vector( ui size ); // vector of size elements allocated
<BR>vector( ui size, T fill ); // as before, but initialized with value &quot;fill&quot;
<BR>vector( vector&lt;T&gt; init ); // creates a copy of the vector &quot;init&quot;

<P>For all vector classes, the arithmetic operators
<BR>+&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;+=&nbsp;&nbsp;&nbsp;&nbsp;-=&nbsp;&nbsp;&nbsp;&nbsp;*=&nbsp;&nbsp;&nbsp;&nbsp;/=
<BR>are defined, with the exception of the polar-complex vector classes, where only multiplications and divisions, but no additions or subtractions are supported. These operators are the only cases in which you can directly assign the result of a calculation to a vector object, like<BR><font face="courier new">fVecObj Z = X + Y;</font> or<BR>
<font face="courier new">fVecObj Z = X * 3.5;</font><BR>
Note, however, that the C++ class syntax rules do not allow a very efficient implementation of these operators. The arithmetic member functions are much faster. If speed is an issue, use<BR>
<font face="courier new">fVecObj Z.addV( X, Y );</font> or<BR>
<font face="courier new">fVecObj Z.mulC( X, 3.5 );</font><BR>
 instead of the operator syntax. 
<BR><B>The operator * refers to element-wise multiplication, <U>not</U> to the scalar product of two vectors.</B>

<P>All other arithmetic and math functions can only be called as member functions of the respective output vector as, for example, <font face="courier new">Y.exp(X)</font>. Although it would certainly be more logical to have these functions defined in such a way that you could write &quot;<font face="courier new">Y = exp(X)</font>&quot; instead, the member-function syntax was chosen for efficiency considerations: The only way to implement the second variant is to store the result of the exponential function of X first in a temporary vector, which is then copied into Y, thus considerably increasing the work-load and memory demands. <B>What we would be very interested to know, however, is if you would prefer the &quot;Y = func(X);&quot; syntax over the member-function syntax, &quot;Y.func(X);&quot; anyway, and if you would be willing to accept its drawbacks. Please tell us your opinion at <A HREF="mailto:support@optivec.com">support@optivec.com</A>.</B> We might add this syntax in later versions of <I>VecObj</I>.

<P>While most <I>VecObj</I> functions are member functions of the <U>output</U> vector, there is a number of functions which do not have an output vector. In these cases, the functions are member functions of an input vector.<BR>
Example: <font face="courier new">s = X.mean();</font>.

<P>If you ever need to process a <I>VecObj</I> vector in a &quot;classic&quot; plain-C <I>VectorLib</I> function (for example, to process only some part of it), you may use the member function <I>getSize()</I> to retrieve its size, and the member function <I>Pelement( n )</I> to retrieve a pointer to the <I>n</I>'th element, where <I>n</I> most often will be 0.

<P>The syntax of all <I>VecObj</I> functions is described in <a href="FUNCREF.HTM">FUNCREF.HTM</a> together with
the basic <I>VectorLib</I> functions for which <I>tVecObj</I> serves as a wrapper.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap4"></a>
<H1><HR width="100%">4. <I>VectorLib</I> Functions and Routines: A Short Overview</H1>

<P><a name="chap4_1"></a>
<H2>4.1 Generation, Initialization and De-Allocation of Vectors</H2>
<BR>With <I>VectorLib</I>, you may use static arrays (like, for example, float a[100];) as well as dynamically allocated ones (see <a href="#chap2_3">chapter 2.3</a>). We recommend, however, that you use the more flexible vector types defined by <I>VectorLib</I>, using dynamic allocation.
<P>The following functions manage dynamically allocated vectors:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#vector">VF_vector</a></TD><TD>memory allocation for one vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#vector0">VF_vector0</a></TD><TD>memory allocation and initialization of all elements with 0</TD></TR>
<TR><TD><a href="FUNCREF.HTM#free">V_free</a></TD><TD>free one vector</TD></TR>
<TR><TD> <a href="FUNCREF.HTM#nfree">V_nfree</a></TD><TD> free n vectors (only for C, not for Pascal)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#freeAll">V_freeAll</a></TD><TD>free all existing vectors</TD></TR>
</TABLE>&nbsp;
<BR>You should always take proper care to de-allocate the memory of vectors which are no longer needed. Internally, the allocated vectors are written into a table to keep track of the allocated memory. If you try to free a vector that has never been or is no longer allocated, you get a warning message, and nothing is freed.

<BR>You might wonder why we add still more memory allocation functions to the already rich <I>omnium gatherum</I> of C/C++ and Pascal/Delphi. The reason is that, for every environment and every memory model, the most appropriate memory management functions shall be selected automatically. This means that you, the user, need not deal yourself with the various methods, but can leave this task to <I>OptiVec</I>. Moreover, this makes your programs more easily portable. (Of course, the operator &quot;new&quot; offers similar benefits, but it is available only in C++. Since <I>OptiVec</I> shall also be usable in plain-C and Pascal, it has to include its own functions for this purpose.)
<P>The following functions are used to initialize or re-initialize vectors that have already been created:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#equ0">VF_equ0</a></TD><TD>set all elements of a vector equal to 0</TD></TR>
<TR><TD><a href="FUNCREF.HTM#equ1">VF_equ1</a></TD><TD>set all elements equal to 1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#equm1">VF_equm1</a></TD><TD>set all elements equal to -1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#equC">VF_equC</a></TD><TD>set all elements equal to a constant C</TD></TR>
<TR><TD><a href="FUNCREF.HTM#equV">VF_equV</a></TD><TD>make one vector a copy of another</TD></TR>
<TR><TD><a href="FUNCREF.HTM#equV">VFx_equV</a></TD><TD>"expanded" version of the equality operation: Y<SUB>i</SUB> = a * X<SUB>i</SUB> + b</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ramp">VF_ramp</a></TD><TD>"ramp": X<SUB>i</SUB> = a * i + b.</TD></TR>
<TR><TD><a href="FUNCREF.HTM#random">VF_random</a></TD><TD>high-quality random numbers</TD></TR>
<TR><TD><a href="FUNCREF.HTM#noise">VF_noise</a></TD><TD>white noise</TD></TR>
<TR><TD><a href="FUNCREF.HTM#comb">VF_comb</a></TD><TD>"comb": equals a constant C at equidistant points, elsewhere 0</TD></TR>
</TABLE>&nbsp;
<BR>The following functions generate windows for use in spectral analysis:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#Hanning">VF_Hanning</a></TD><TD>Hanning window</TD></TR>
<TR><TD><a href="FUNCREF.HTM#Parzen">VF_Parzen</a></TD><TD>Parzen window</TD></TR>
<TR><TD><a href="FUNCREF.HTM#Welch">VF_Welch</a></TD><TD>Welch window</TD></TR>
</TABLE>&nbsp;

<BR>Complex vectors may be initialized by these functions:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#ReImtoC">VF_ReImtoC</a></TD><TD>merge two vectors, <I>Re</I> and <I>Im</I>, into one cartesian complex vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#RetoC">VF_RetoC</a></TD><TD>overwrite the real part of a cartesian complex vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ImtoC">VF_ImtoC</a></TD><TD>overwrite the imaginary part of a cartesian complex vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#PolartoC">VF_PolartoC</a></TD><TD>construct a cartesian complex vector from polar coordinates, entered as separate vectors <I>Mag</I> and <I>Arg</I></TD></TR>
<TR><TD><a href="FUNCREF.HTM#MagArgtoP">VF_MagArgtoP</a></TD><TD>merge two vectors, <I>Mag</I> and <I>Arg</I> into one polar complex vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#MagArgtoPrincipal">VF_MagArgtoPrincipal</a></TD><TD>merge two vectors, <I>Mag</I> and <I>Arg</I> into one polar complex vector, reducing the <I>Arg</I> range to the principal value, -<font face="symbol">p</font> &lt; Arg &lt;= +<font face="symbol">p</font></TD></TR>
<TR><TD><a href="FUNCREF.HTM#MagtoP">VF_MagtoP</a></TD><TD>overwrite the <I>Mag</I> part of a polar complex vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ArgtoP">VF_ArgtoP</a></TD><TD>overwrite the <I>Arg</I> part of a polar complex vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ReImtoP">VF_ReImtoP</a></TD><TD>construct a polar complex vector from cartesian coordinates, entered as separate vectors <I>Re</I> and <I>Im</I></TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap4_2"></a>
<H2>4.2 Index-oriented Manipulations</H2>

<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#rev">VF_rev</a></TD><TD>reverse the element ordering</TD></TR>
<TR><TD><a href="FUNCREF.HTM#reflect">VF_reflect</a></TD><TD>set the upper half of a vector equal to the reversed lower half</TD></TR>
<TR><TD><a href="FUNCREF.HTM#rotate">VF_rotate</a></TD><TD>rotate the ordering of the elements</TD></TR>
<TR><TD><a href="FUNCREF.HTM#insert">VF_insert</a></TD><TD>insert one element into a vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#delete">VF_delete</a></TD><TD>delete one element from a vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#sort">VF_sort</a></TD><TD>fast sorting of the elements (ascending or descending order)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#sortind">VF_sortind</a></TD><TD>sorting of an index array associated with a vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector">VF_subvector</a></TD><TD>extract a subvector from a (normally larger) vector, using a constant sampling interval.</TD></TR>
<TR><TD><a href="FUNCREF.HTM#indpick">VF_indpick</a></TD><TD>fills a vector with elements &quot;picked&quot; from another vector according to their indices.</TD></TR>
<TR><TD><a href="FUNCREF.HTM#indput">VF_indput</a></TD><TD>distribute the elements of one vector to the sites of another vector specified by their indices.</TD></TR>
</TABLE>&nbsp;
<BR>Operations performed only on a sampled sub-set of elements of a vector are provided by the <I><a href="FUNCREF.HTM#subvector_">VF_subvector_...</a></I> family, where the omission mark stands for a suffix denoting the desired operation:&nbsp;

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >
<TR><TD><TABLE BORDER WIDTH="97%" >
<TR><TD><a href="FUNCREF.HTM#subvector_equC">VF_subvector_equC</a></TD>
<TD>X<sub>i*samp</sub>  =  C,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector_">VF_subvector_addC</a></TD>
<TD>X<sub>i*samp</sub>  +=  C,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector_">VF_subvector_subC</a></TD>
<TD>X<sub>i*samp</sub>  -=  C,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector_">VF_subvector_subrC</a></TD>
<TD>X<sub>i*samp</sub>  =  C - X<sub>i*samp</sub>,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector_">VF_subvector_mulC</a></TD>
<TD>X<sub>i*samp</sub>  *=  C,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector_">VF_subvector_divC</a></TD>
<TD>X<sub>i*samp</sub>  /=  C,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector_">VF_subvector_divrC</a></TD>
<TD>X<sub>i*samp</sub>  =  C / X<sub>i*samp</sub>,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
</TABLE>
</TD>
<TD VALIGN=TOP>
<TABLE ALIGN=RIGHT BORDER WIDTH="100%" >
<TR><TD><a href="FUNCREF.HTM#subvector_equV">VF_subvector_equV</a></TD>
<TD>Y<sub>i*samp</sub>  =  Y<sub>i</sub>,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector_">VF_subvector_addV</a></TD>
<TD>X<sub>i*samp</sub>  +=  Y<sub>i</sub>,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector_">VF_subvector_subV</a></TD>
<TD>X<sub>i*samp</sub>  -=  Y<sub>i</sub>,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector_">VF_subvector_subrV</a></TD>
<TD>X<sub>i*samp</sub>  =  Y<sub>i</sub> - X<sub>i*samp</sub>,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector_">VF_subvector_mulV</a></TD>
<TD>X<sub>i*samp</sub>  *=  Y<sub>i</sub>,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector_">VF_subvector_divV</a></TD>
<TD>X<sub>i*samp</sub>  /=  Y<sub>i</sub>,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subvector_">VF_subvector_divrV</a></TD>
<TD>X<sub>i*samp</sub>  =  Y<sub>i</sub> / X<sub>i*samp</sub>,&nbsp;&nbsp;&nbsp;i=0,...subsize-1</TD></TR>
</TABLE>
</TD>
</TR>
</TABLE>&nbsp;

<BR>Searching tables for specific values is accomplished by: 
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#searchC">VF_searchC</a></TD>
<TD>search for the element of a vector that is closest to a pre-set value C (closest, closest larger-or-equal, or closest smaller-or-equal value, depending on a parameter <I>"mode"</I>)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#searchV">VF_searchV</a></TD><TD>the same, but for a whole array of pre-set values</TD></TR>
</TABLE>&nbsp;

<BR>Interpolations are performed by:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#polyinterpol">VF_polyinterpol</a></TD><TD>polynomial interpolation</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ratinterpol">VF_ratinterpol</a></TD><TD>rational interpolation</TD></TR>
<TR><TD><a href="FUNCREF.HTM#splineinterpol">VF_splineinterpol</a></TD><TD>cubic spline interpolation</TD></TR>
</TABLE>&nbsp;

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap4_3"></a>
<H2>4.3 Data-Type Interconversions</H2>
The first thing that has to be said about the floating-point data-type interconversions is: do not use them too extensively. Decide which accuracy is appropriate for your application, and then use consistently either the <I>VF_</I>, or the <I>VD_</I>, or the <I>VE_</I> version of the functions you need. Nevertheless, every data type can be converted into every other, in case it is necessary. Only a few examples are given; the rest should be obvious:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#FtoD">V_FtoD</a></TD><TD><B>float</B> to <B>double</B></TD></TR>
<TR><TD><a href="FUNCREF.HTM#FtoD">V_CDtoCF</a></TD><TD><B>complex&lt;double&gt;</B> to <B>complex&lt;float&gt;</B> (with overflow protection)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#FtoD">V_PFtoPE</a></TD><TD><B>polar&lt;float&gt;</B> to <B>polar&lt;extended&gt;</B></TD></TR>
<TR><TD><a href="FUNCREF.HTM#PtoC">VF_PtoC</a></TD><TD><B>polar&lt;float&gt;</B> to <B>complex&lt;float&gt;</B></TD></TR>
<TR><TD><a href="FUNCREF.HTM#ItoBI">V_ItoLI</a></TD><TD><B>int</B> to <B>long int</B></TD></TR>
<TR><TD><a href="FUNCREF.HTM#ItoBI">V_ULtoUS</a></TD><TD><B>unsigned long</B> to <B>unsigned short</B></TD></TR>
<TR><TD><a href="FUNCREF.HTM#ItoBI">V_ItoU</a></TD><TD><B>signed int</B> to <B>unsigned int</B>. Interconversions between signed and unsigned types can only be performed on the same level of accuracy. Functions like &quot;V_UStoLI&quot; do <U>not</U> exist.</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ItoF">V_ItoF</a></TD><TD><B>int</B> to <B>float</B></TD></TR>
</TABLE>&nbsp;

<BR>The conversion of floating-point numbers into integers is performed by the following functions, differing in the way a possible fractional part is treated:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#round">VF_roundtoI</a></TD><TD>round to the closest integer</TD></TR>
<TR><TD><a href="FUNCREF.HTM#chop">VF_choptoI</a></TD><TD>round by neglecting ("chopping off") the fractional part</TD></TR>
<TR><TD><a href="FUNCREF.HTM#trunc">VF_trunctoI</a></TD><TD>the same as <a href="FUNCREF.HTM#choptoI">VF_choptoI</a></TD></TR>
<TR><TD><a href="FUNCREF.HTM#ceil">VF_ceiltoI</a></TD><TD>round to the next greater-or-equal integer</TD></TR>
<TR><TD><a href="FUNCREF.HTM#floor">VF_floortoI</a></TD><TD>round to the next smaller-or-equal integer</TD></TR>
</TABLE>&nbsp;
<BR>These operations are treated as mathematical functions and are further described in <a href="#chap4_6_1">chapter 4.6.1</a>.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap4_4"></a>
<H2>4.4 More about Integer Arithmetics</H2>
Although the rules of integer arithmetics are quite straightforward, it appears appropriate to recall that all integer operations are implicitly performed modulo 2<sup>n</sup>, where n is the number of bits the numbers are represented with. This means that any result, falling outside the range of the respective data type, is made to fall inside the range by loosing the highest bits. The effect is the same as if as many times 2<sup>n</sup> had been added to (or subtracted from) the &quot;correct&quot; result as necessary to reach the legal range.
<BR>For example, in the data type <B>short</B> / <B>SmallInt</B>, the result of the multiplication 5 * 20000 is -31072. The reason for this seemingly wrong negative result is that the &quot;correct&quot; result, 100000, falls outside the range of <B>short</B> numbers which is -32768 &lt;= x &lt;= +32767. <B>short</B> / <B>SmallInt</B> is a 16-bit type, so n = 16, and 2<sup>n</sup> = 65536. In order to make the result fall into the specified range, the processor &quot;subtracts&quot; 2 * 65536 = 131072 from 100000, yielding -31072.

<BR>Note that overflowing intermediate results cannot be &quot;cured&quot; by any following operation. For example, (5 * 20000) / 4 is not (as one might hope) 25000, but rather -7768.
<BR>The 64-bit data type <B>quad</B> / <B>QuadInt</B> does not employ this implicit modulo-2<sup>n</sup> arithmetics. Overflow conditions lead to undefined results.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap4_5"></a>
<H2>4.5 Basic Functions of Complex Vectors</H2>
The following functions are available for the basic treatment of <U>cartesian complex</U> vectors:&nbsp;

<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#ReImtoC">VF_ReImtoC</a></TD><TD>form a cartesian complex vector out of its real and imaginary parts</TD></TR>
<TR><TD><a href="FUNCREF.HTM#RetoC">VF_RetoC</a></TD><TD>overwrite the real part</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ImtoC">VF_ImtoC</a></TD><TD>overwrite the imaginary part</TD></TR>
<TR><TD><a href="FUNCREF.HTM#CtoReIm">VF_CtoReIm</a></TD><TD>extract the real and imaginary parts</TD></TR>
<TR><TD><a href="FUNCREF.HTM#CtoRe">VF_CtoRe</a></TD><TD>extract the real part</TD></TR>
<TR><TD><a href="FUNCREF.HTM#CtoIm">VF_CtoIm</a></TD><TD>extract the imaginary part</TD></TR>
<TR><TD><a href="FUNCREF.HTM#PolartoC">VF_PolartoC</a></TD><TD>form a cartesian complex vector out of polar coordinates, entered as separate vectors <I>Mag</I> and <I>Arg</I></TD></TR>
<TR><TD><a href="FUNCREF.HTM#CtoPolar">VF_CtoPolar</a></TD><TD>transform cartesian complex into polar coordinates, returned in the separate vectors <I>Mag</I> and <I>Arg</I></TD></TR>
<TR><TD><a href="FUNCREF.HTM#CtoAbs">VF_CtoAbs</a></TD><TD>absolute value (magnitude of the pointer in the complex plane)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#CtoArg">VF_CtoArg</a></TD><TD>argument (angle of the pointer in the complex plane)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#CtoNorm">VF_CtoNorm</a></TD><TD>norm (here defined as the square of the absolute value)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#norm">VCF_normtoC</a></TD><TD>norm, stored as a cartesian complex vector (with all imaginary parts equal to 0)</TD></TR>
</TABLE>&nbsp;

<BR>The corresponding functions for <U>polar coordinates</U> are:
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#MagArgtoP">VF_MagArgtoP</a></TD><TD>merge two vectors, <I>Mag</I> and <I>Arg</I> into one polar complex vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#MagArgtoPrincipal">VF_MagArgtoPrincipal</a></TD><TD>merge two vectors, <I>Mag</I> and <I>Arg</I> into one polar complex vector, reducing the <I>Arg</I> range to the principal value, -<font face="symbol">p</font> &lt; Arg &lt;= +<font face="symbol">p</font></TD></TR>
<TR><TD><a href="FUNCREF.HTM#MagtoP">VF_MagtoP</a></TD><TD>overwrite the <I>Mag</I> part of a polar complex vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ArgtoP">VF_ArgtoP</a></TD><TD>overwrite the <I>Arg</I> part of a polar complex vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#PtoMagArg">VF_PtoMagArg</a></TD><TD>extract the <I>Mag</I> and <I>Arg</I> parts</TD></TR>
<TR><TD><a href="FUNCREF.HTM#PtoMag">VF_PtoMag</a></TD><TD>extract the <I>Mag</I> part</TD></TR>
<TR><TD><a href="FUNCREF.HTM#PtoArg">VF_PtoArg</a></TD><TD>extract the <I>Arg</I> part</TD></TR>
<TR><TD><a href="FUNCREF.HTM#PtoNorm">VF_PtoNorm</a></TD><TD>norm (here defined as the square of the magnitude)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ReImtoP">VF_ReImtoP</a></TD><TD>construct a polar complex vector from cartesian coordinates, entered as separate vectors <I>Re</I> and <I>Im</I></TD></TR>
<TR><TD><a href="FUNCREF.HTM#PtoReIm">VF_PtoReIm</a></TD><TD>transform a polar complex vector into two real vectors, representing the corresponding cartesian coordinates <I>Re</I> and <I>Im</I></TD></TR>
<TR><TD><a href="FUNCREF.HTM#PtoRe">VF_PtoRe</a></TD><TD>calculate the real part of the polar complex input numbers</TD></TR>
<TR><TD><a href="FUNCREF.HTM#PtoIm">VF_PtoIm</a></TD><TD>calculate the imaginary part of the polar complex input numbers</TD></TR>
<TR><TD><a href="FUNCREF.HTM#principal">VPF_principal</a></TD><TD>calculate the principal value. You might recall that each complex number has an infinite number of representations in polar coordinates, with the angles differing by an integer
multiple of 2 <font face="symbol">p</font>. The representation with -<font face="symbol">p</font> &lt; Arg &lt;= +<font face="symbol">p</font> is called the principal value.</TD></TR>
</TABLE>&nbsp;

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap4_6"></a>
<H2>4.6 Mathematical Functions</H2>
Lacking a more well-founded definition, we denote as &quot;mathematical&quot; all those functions which calculate each single element of a vector from the corresponding element of another vector by a more or less simple mathematical formula:<BR>Y<sub>i</sub> = f( X<sub>i</sub> ). 
<BR>Except for the &quot;basic arithmetics&quot; functions, they are defined only for the floating-point data types. Most of these mathematical functions are vectorized versions of scalar ANSI C or Pascal functions or derived from them. In C/C++, errors are handled by <I>_matherr</I> and <I>_matherrl</I>. In Pascal/Delphi, <I>OptiVec</I> allows the user to control error handling by means of the function <I><a href="FUNCREF.HTM#setFPErrorHandling">V_setFPErrorHandling</a></I>. 
<P>In addition to this error handling &quot;by element&quot;, the return values of the <I>VectorLib</I> math functions show if all elements have been processed successfully. In C/C++, the return value is of the data-type <B>int</B>, in Pascal/Delphi, it is <B>IntBool</B>. (We do not yet use the newly introduced data type bool for this return value in C/C++, in order to make <I>VectorLib</I> compatible also with older versions of C compilers.) If a math function worked error-free, the return value is FALSE (0), otherwise it is TRUE (any non-zero number).

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap4_6_1"></a>
<H2>4.6.1 Rounding</H2>
Some of the functions converting floating-point into integer vectors have already been noted above. The result of these rounding operations may either be left in the original floating-point format, or it may be converted into one of the integer types. The following functions store the result in the original floating-point format:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#round">VF_round</a></TD><TD>round to the closest integer</TD></TR>
<TR><TD><a href="FUNCREF.HTM#chop">VF_chop</a></TD><TD>round by neglecting ("chopping off") the fractional part</TD></TR>
<TR><TD><a href="FUNCREF.HTM#trunc">VF_trunc</a></TD><TD>the same as <a href="FUNCREF.HTM#chop">VF_chop</a></TD></TR>
<TR><TD><a href="FUNCREF.HTM#ceil">VF_ceil</a></TD><TD>round to the next greater-or-equal integer</TD></TR>
<TR><TD><a href="FUNCREF.HTM#floor">VF_floor</a></TD><TD>round to the next smaller-or-equal integer</TD></TR>
</TABLE>
&nbsp;
<BR>The following functions store the result as integers (type <B>int / Integer</B>):&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#round">VF_roundtoI</a></TD><TD>round to the closest integer</TD></TR>
<TR><TD><a href="FUNCREF.HTM#chop">VF_choptoI</a></TD><TD>round by neglecting ("chopping off") the fractional part</TD></TR>
<TR><TD><a href="FUNCREF.HTM#trunc">VF_trunctoI</a></TD><TD>the same as <a href="FUNCREF.HTM#chop">VF_choptoI</a></TD></TR>
<TR><TD><a href="FUNCREF.HTM#ceil">VF_ceiltoI</a></TD><TD>round to the next greater-or-equal integer</TD></TR>
<TR><TD><a href="FUNCREF.HTM#floor">VF_floortoI</a></TD><TD>round to the next smaller-or-equal integer</TD></TR>
</TABLE>&nbsp;
<BR>The target type may also be any of the other integer data types. A few examples
should suffice:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#chop">VF_choptoSI</a></TD><TD>neglect the fractional part and store as <B>short int / SmallInt</B></TD></TR>
<TR><TD><a href="FUNCREF.HTM#ceil">VF_ceiltoLI</a></TD><TD>round up and store as <B>long int / LongInt</B></TD></TR>
<TR><TD><a href="FUNCREF.HTM#floor">VF_floortoQI</a></TD><TD>round downwards and store as quadruple integer, <B>quad / QuadInt</B></TD></TR>
<TR><TD><a href="FUNCREF.HTM#round">VF_roundtoU</a></TD><TD>round and store as <B>unsigned / UInt</B></TD></TR>
<TR><TD><a href="FUNCREF.HTM#ceil">VF_ceiltoUS</a></TD><TD>round up and store as <B>unsigned short / USmall</B></TD></TR>
<TR><TD><a href="FUNCREF.HTM#chop">VD_choptoUL</a></TD><TD>neglect the fractional part and store as <B>unsigned long / ULong</B></TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap4_6_2"></a>
<H2>4.6.2 Comparisons</H2>
Functions performing comparisons are generally named <I>VF_cmp...</I> (where further letters and/or numbers specify the type of comparison desired). Every element of a vector can be compared either to 0, or to a constant C, or to the corresponding element of another vector. There are two possibilities: either the comparison is performed with the three possible answers &quot;greater than&quot;, &quot;equal to&quot; or &quot;less than&quot;. In this case, the results are stored as floating-point numbers (0.0, 1.0, or -1.0). Examples are:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#cmp0">VF_cmp0</a></TD><TD>compare to 0</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cmpC">VD_cmpC</a></TD><TD>compare to a constant <I>C</I></TD></TR>
<TR><TD><a href="FUNCREF.HTM#cmpV">VE_cmpV</a></TD><TD>compare corresponding vector elements</TD></TR>
</TABLE>&nbsp;
<BR>The other possibility is to test if one of the following conditions is fulfilled: &quot;greater than&quot;, &quot;greater than or equal to&quot;, &quot;equal to&quot;, &quot;not equal to&quot;, &quot;less than&quot;, or &quot;less than or equal to&quot;. Here, the answers will be &quot;TRUE&quot; or &quot;FALSE&quot; (1.0 or 0.0). Examples are<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#cmp_">VF_cmp_eq0</a></TD><TD>check if equal to 0</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cmp_">VD_cmp_gtC</a></TD><TD>check if greter than a constant <I>C</I></TD></TR>
<TR><TD><a href="FUNCREF.HTM#cmp_">VE_cmp_leV</a></TD><TD>check if less than or equal to corresponding vector element</TD></TR>
</TABLE>&nbsp;

<BR>Alternatively, the indices of the elements for which the answer was &quot;TRUE&quot; may be stored in an index-array, as in:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#cmp_">VF_cmp_neCind</a></TD><TD>store indices of elements not equal to a constant <I>C</I></TD></TR>
<TR><TD><a href="FUNCREF.HTM#cmp_">VD_cmp_lt0ind</a></TD><TD>store indices of elements less than 0</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cmp_">VE_cmp_geVind</a></TD><TD>store indices of elements greater than or equal to corresponding vector elements</TD></TR>
</TABLE>&nbsp;
<BR>While the basic comparison functions check against one boundary, there is a number of functions checking if a vector elements falls into a certain range:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="32%"><a href="FUNCREF.HTM#cmp_">VF_cmp_inclrange0C</a></TD>
<TD>check if 0 &lt;= x &lt;= C&nbsp;&nbsp;(C positive)<BR>or&nbsp;&nbsp;0 &gt;= x &gt;= C&nbsp;&nbsp;(C negative)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cmp_">VF_cmp_exclrange0C</a></TD>
<TD>check if 0 &lt; x &lt; C&nbsp;&nbsp;(C positive)<BR>or&nbsp;&nbsp;0 &gt; x &gt; C&nbsp;&nbsp;(C negative)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cmp_">VF_cmp_inclrangeCC</a></TD>
<TD>check if CLo &lt;= x &lt;= CHi</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cmp_">VF_cmp_exclrangeCC</a></TD>
<TD>check if CLo &lt; x &lt; CHi</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cmp_">VF_cmp_inclrange0Cind</a></TD>
<TD>store indices of elements 0 &lt;= x &lt;= C&nbsp;&nbsp;(C positive)<BR>or&nbsp;&nbsp;0 &gt;= x &gt; C&nbsp;&nbsp;(C negative)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cmp_">VF_cmp_exclrange0Cind</a></TD>
<TD>store indices of elements 0 &lt; x &lt; C&nbsp;&nbsp;(C positive)<BR>or&nbsp;&nbsp;0 &gt; x &gt; C&nbsp;&nbsp;(C negative)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cmp_">VF_cmp_inclrangeCCind</a></TD>
<TD>store indices of elements CLo &lt;= x &lt;= CHi</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cmp_">VF_cmp_exclrangeCCind</a></TD>
<TD>store indices of elements CLo &lt; x &lt; CHi</TD></TR>
</TABLE>&nbsp;

<BR>The following functions test if one or more values can be found in a vector:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#iselementC">VF_iselementC</a></TD>
<TD>returns TRUE, if <I>C</I> is an element of a vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#iselementV">VF_iselementV</a></TD>
<TD>checks for each element of a vector if it is contained in a table</TD></TR>
</TABLE>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<P><a name="chap4_6_3"></a>
<H2>4.6.3 Direct Bit-Manipulation</H2>
For the integer data types, a number of bit-wise operations is available, which can be used, e.g., for fast multiplication and divisions by integer powers of 2.&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#shl">VI_shl</a></TD><TD>shift the bits to the left</TD></TR>
<TR><TD><a href="FUNCREF.HTM#shr">VI_shr</a></TD><TD>shift the bits to the right</TD></TR>
<TR><TD><a href="FUNCREF.HTM#or">VI_or</a></TD><TD>apply a bit mask in an OR operation</TD></TR>
<TR><TD><a href="FUNCREF.HTM#xor">VI_xor</a></TD><TD>apply a bit mask in an XOR operation</TD></TR>
<TR><TD><a href="FUNCREF.HTM#not">VI_not</a></TD><TD>invert all bits</TD></TR>
</TABLE>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>

<P><a name="chap4_6_4"></a>
<H2>4.6.4 Basic Arithmetics, Accumulations</H2>
As before, only the <I>VF_</I> function is explicitly named, but the <I>VD_</I> and <I>VE_</I> functions exist as well; if it makes sense, the same is true for the complex and for the integer-type versions:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#neg">VF_neg</a></TD><TD>Y<SUB>i</SUB> = - X<SUB>i</SUB></TD></TR>
<TR><TD><a href="FUNCREF.HTM#abs">VF_abs</a></TD><TD>Y<SUB>i</SUB> = | X<SUB>i</SUB> |</TD></TR>
<TR><TD><a href="FUNCREF.HTM#conj">VCF_conj</a></TD><TD>Y<SUB>i</SUB>.Re = X<SUB>i</SUB>.Re; Y<SUB>i</SUB>.Im = -(X<SUB>i</SUB>.Re)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#inv">VF_inv</a></TD><TD>Y<SUB>i</SUB> = 1.0 / X<SUB>i</SUB></TD></TR>
</TABLE>&nbsp;

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >
<TR><TD><TABLE BORDER WIDTH="97%" >
<TR><TD WIDTH="30%"><a href="FUNCREF.HTM#equC">VF_equC</a></TD><TD>X<SUB>i</SUB> = C</TD></TR>
<TR><TD><a href="FUNCREF.HTM#addC">VF_addC</a></TD><TD>Y<SUB>i</SUB> = X<SUB>i</SUB> + C</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subC">VF_subC</a></TD><TD>Y<SUB>i</SUB> = X<SUB>i</SUB> - C</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subrC">VF_subrC</a></TD><TD>Y<SUB>i</SUB> = C - X<SUB>i</SUB></TD></TR>
<TR><TD><a href="FUNCREF.HTM#mulC">VF_mulC</a></TD><TD>Y<SUB>i</SUB> = X<SUB>i</SUB> * C</TD></TR>
<TR><TD><a href="FUNCREF.HTM#divC">VF_divC</a></TD><TD>Y<SUB>i</SUB> = X<SUB>i</SUB> / C</TD></TR>
<TR><TD><a href="FUNCREF.HTM#divrC">VF_divrC</a></TD><TD>Y<SUB>i</SUB> = C / X<SUB>i</SUB></TD></TR>
<TR><TD><a href="FUNCREF.HTM#modC">VF_modC</a></TD><TD>Y<SUB>i</SUB> = X<SUB>i</SUB> mod C</TD></TR>
</TABLE>
</TD>
<TD VALIGN=TOP>
<TABLE ALIGN=RIGHT BORDER WIDTH="100%" >
<TR><TD WIDTH="30%"><a href="FUNCREF.HTM#equV">VF_equV</a></TD><TD>Y<SUB>i</SUB> = X<SUB>i</SUB></TD></TR>
<TR><TD><a href="FUNCREF.HTM#addV">VF_addV</a></TD><TD>Z<SUB>i</SUB> = X<SUB>i</SUB> + Y<SUB>i</SUB></TD></TR>
<TR><TD><a href="FUNCREF.HTM#subV">VF_subV</a></TD><TD>Z<SUB>i</SUB> = X<SUB>i</SUB> - Y<SUB>i</SUB></TD></TR>
<TR><TD><a href="FUNCREF.HTM#subrV">VF_subrV</a></TD><TD>Z<SUB>i</SUB> = Y<SUB>i</SUB> - X<SUB>i</SUB></TD></TR>
<TR><TD><a href="FUNCREF.HTM#mulV">VF_mulV</a></TD><TD>Z<SUB>i</SUB> = X<SUB>i</SUB> * Y<SUB>i</SUB></TD></TR>
<TR><TD><a href="FUNCREF.HTM#divV">VF_divV</a></TD><TD>Z<SUB>i</SUB> = X<SUB>i</SUB> / Y<SUB>i</SUB></TD></TR>
<TR><TD><a href="FUNCREF.HTM#divrV">VF_divrV</a></TD><TD>Z<SUB>i</SUB> = Y<SUB>i</SUB> / X<SUB>i</SUB></TD></TR>
<TR><TD><a href="FUNCREF.HTM#modV">VF_modV</a></TD><TD>Z<SUB>i</SUB> = X<SUB>i</SUB> mod Y<SUB>i</SUB></TD></TR>
</TABLE>
</TD>
</TR>
</TABLE>&nbsp;
<BR>Besides these basic operations, several frequently-used combinations of addition and division have been included, not to forget the Pythagoras formula:&nbsp;
<TABLE CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >
<TR>
<TD WIDTH="50%">
<TABLE BORDER WIDTH="97%" >
<TR><TD WIDTH="30%"><a href="FUNCREF.HTM#hypC">VF_hypC</a></TD><TD>Y<SUB>i</SUB> = X<SUB>i</SUB> / (X<SUB>i</SUB> + C)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#redC">VF_redC</a></TD><TD>Y<SUB>i</SUB> = (X<SUB>i</SUB> * C) / (X<SUB>i</SUB> + C)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#visC">VF_visC</a></TD><TD>Y<SUB>i</SUB> = (X<SUB>i</SUB> - C) / (X<SUB>i</SUB> + C)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#hypotC">VF_hypotC</a></TD><TD>Y<SUB>i</SUB> = sqrt( X<SUB>i</SUB>&sup2; + C&sup2; )</TD></TR>
</TABLE>
</TD>

<TD VALIGN=TOP>
<TABLE ALIGN=RIGHT BORDER WIDTH="100%" >
<TR><TD WIDTH="30%"><a href="FUNCREF.HTM#hypV">VF_hypV</a></TD><TD>Z<SUB>i</SUB> = X<SUB>i</SUB> / (X<SUB>i</SUB> + Y<SUB>i</SUB>)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#redV">VF_redV</a></TD><TD>Z<SUB>i</SUB> = (X<SUB>i</SUB> * Y<SUB>i</SUB>) / (X<SUB>i</SUB> + Y<SUB>i</SUB>)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#visV">VF_visV</a></TD><TD>Z<SUB>i</SUB> = (X<SUB>i</SUB> - Y<SUB>i</SUB>) / (X<SUB>i</SUB> + Y<SUB>i</SUB>)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#hypotV">VF_hypotV</a></TD><TD>Z<SUB>i</SUB> = sqrt( X<SUB>i</SUB>&sup2; + Y<SUB>i</SUB>&sup2;)</TD></TR>
</TABLE>
</TD>
</TR>
</TABLE>
<P>All functions in the right column of the above two sections also exist in an expanded form (with the prefix <I>VFx_...</I>) in which the function is not evaluated for X<SUB>i</SUB> itself, but for the expression 
<BR>(a * X<SUB>i</SUB> + b), e.g.&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#addV">VFx_addV</a></TD>
<TD>Z<SUB>i</SUB> = <B><FONT COLOR="#FF0000">(a * X<SUB>i</SUB> + b)</FONT></B> + Y<SUB>i</SUB></TD></TR>
<TR><TD><a href="FUNCREF.HTM#divrV">VFx_divrV</a></TD>
<TD>Z<SUB>i</SUB> = Y<SUB>i</SUB> / <B><FONT COLOR="#FF0000">(a * X<SUB>i</SUB> + b)</FONT></B></TD></TR>
</TABLE>
&nbsp;
<BR>The simple algebraic functions exist also in yet another special form, with the result being scaled by some arbitrary factor. This scaled form gets the prefix <I>VFs_</I>:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#addV">VFs_addV</a></TD>
<TD>Z<SUB>i</SUB> = <B><FONT COLOR="#FF0000">C *</FONT></B> (X<SUB>i</SUB> + Y<SUB>i</SUB>)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#subV">VFs_subV</a></TD>
<TD>Z<SUB>i</SUB> = <B><FONT COLOR="#FF0000">C *</FONT></B> (X<SUB>i</SUB> - Y<SUB>i</SUB>)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#mulV">VFs_mulV</a></TD>
<TD>Z<SUB>i</SUB> = <B><FONT COLOR="#FF0000">C *</FONT></B> (X<SUB>i</SUB> * Y<SUB>i</SUB>)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#divV">VFs_divV</a></TD>
<TD>Z<SUB>i</SUB> = <B><FONT COLOR="#FF0000">C *</FONT></B> (X<SUB>i</SUB> / Y<SUB>i</SUB>)</TD></TR>
</TABLE>&nbsp;

<BR>Other simple operations include:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#maxC">VF_maxC</a></TD><TD>set Y<SUB>i</SUB> equal to X<SUB>i</SUB> or C, whichever is greater</TD></TR>
<TR><TD><a href="FUNCREF.HTM#minC">VF_minC</a></TD><TD>choose the smaller of X<SUB>i</SUB> and C</TD></TR>
<TR><TD><a href="FUNCREF.HTM#maxV">VF_maxV</a></TD><TD>set Z<SUB>i</SUB> equal to X<SUB>i</SUB> or Y<SUB>i</SUB>, whichever is greater</TD></TR>
<TR><TD><a href="FUNCREF.HTM#minV">VF_minV</a></TD><TD>set Z<SUB>i</SUB> equal to X<SUB>i</SUB> or Y<SUB>i</SUB>, whichever is smaller</TD></TR>
<TR><TD><a href="FUNCREF.HTM#limit">VF_limit</a></TD><TD>limit the range of values</TD></TR>
<TR><TD><a href="FUNCREF.HTM#flush0">VF_flush0</a></TD><TD>set all values to zero which are below a preset threshold</TD></TR>
<TR><TD><a href="FUNCREF.HTM#intfrac">VF_intfrac</a></TD><TD>split into integer and fractional parts</TD></TR>
<TR><TD><a href="FUNCREF.HTM#mantexp">VF_mantexp</a></TD><TD>split into mantissa and exponent</TD></TR>
</TABLE>&nbsp;

<BR>While, in general, all <I>OptiVec</I> functions are for input and output vectors of the same type, there exists one family of functions for the accumulation of data in either the same type or in higher-precision data types. Some examples are:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#accV">VF_accV</a></TD><TD><B>fVector</B> Y += <B>fVector</B> X</TD></TR>
<TR><TD><a href="FUNCREF.HTM#accV">VD_accVF</a></TD><TD><B>dVector</B> Y += <B>fVector</B> X</TD></TR>
<TR><TD><a href="FUNCREF.HTM#accV">VF_accVI</a></TD><TD><B>fVector</B> Y += <B>iVector</B> X</TD></TR>
<TR><TD><a href="FUNCREF.HTM#accV">VQI_accVLI</a></TD><TD><B>qiVector</B> Y += <B>liVector</B> X</TD></TR>
</TABLE>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<P><a name="chap4_6_5"></a>
<H2>4.6.5 Geometrical Vector Arithmetics</H2>
In its geometrical interpretation, a vector is a pointer, with its elements representing the coordinates of a point in <I>n</I>-dimensional space. There are a few functions for geometrical vector arithmetics, namely&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#scalprod">VF_scalprod</a></TD>
<TD>scalar product of two vectors</TD></TR>
<TR><TD><a href="FUNCREF.HTM#xprod">VF_xprod</a></TD>
<TD>cross-product (or vector product) of two vectors</TD></TR>
<TR><TD><a href="FUNCREF.HTM#Euclid">VF_Euclid</a></TD>
<TD>Euclidean norm</TD></TR>
</TABLE>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<P><a name="chap4_6_6"></a>
<H2>4.6.6 Powers</H2>
The following functions raise arbitrary numbers to specified powers. The extra-fast &quot;unprotected versions&quot; can be employed in situations where you are absolutely sure that all input elements yield valid results. Due to the much more efficient vectorization permitted by the absence of error checks, the unprotected functions are up to 1.8 times as fast as the
protected versions. (This is true from the Pentium CPU on; on older computers, almost nothing is gained.) Be, however, aware of the price you have to pay for this increase in speed: in case of an overflow error, the program will crash without any warning.<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%">normal version</TD><TD WIDTH="27%">unprotected version</TD><TD>operation</TD></TR>
<TR><TD><a href="FUNCREF.HTM#square">VF_square</a></TD><TD><a href="FUNCREF.HTM#square">VFu_square</a></TD><TD>square</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cubic">VF_cubic</a></TD><TD><a href="FUNCREF.HTM#cubic">VFu_cubic</a></TD><TD>cubic</TD></TR>
<TR><TD><a href="FUNCREF.HTM#quartic">VF_quartic</a></TD><TD><a href="FUNCREF.HTM#quartic">VFu_quartic</a></TD><TD>quartic (fourth power)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ipow">VF_ipow</a></TD><TD><a href="FUNCREF.HTM#ipow">VFu_ipow</a></TD><TD>arbitrary integer powers</TD></TR>
<TR><TD><a href="FUNCREF.HTM#pow">VF_pow</a></TD><TD>n.a.</TD><TD>fractional powers</TD></TR>
<TR><TD><a href="FUNCREF.HTM#poly">VF_poly</a></TD><TD><a href="FUNCREF.HTM#poly">VFu_poly</a></TD><TD>polynomial</TD></TR>
</TABLE>&nbsp;

<BR>The following group of functions is used to raise specified numbers to arbitrary powers:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#pow10">VF_pow10</a></TD>
<TD>fractional powers of 10</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ipow10">VF_ipow10</a></TD>
<TD>integer powers of 10 (stored as floating-point numbers)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#pow2">VF_pow2</a></TD>
<TD>fractional powers of 2</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ipow2">VF_ipow2</a></TD>
<TD>integer powers of 2 (stored as floating-point numbers)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#exp">VF_exp</a></TD>
<TD>exponential function</TD></TR>
<TR><TD><a href="FUNCREF.HTM#exp10">VF_exp10</a></TD>
<TD>exponential function to the basis 10 (identical to <a href="FUNCREF.HTM#pow10">VF_pow10</a>)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#exp2">VF_exp2</a></TD>
<TD>exponential function to the basis 2 (identical to <a href="FUNCREF.HTM#pow2">VF_pow2</a>)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#expArbBase">VF_expArbBase</a></TD>
<TD>exponential function of an arbitrary base</TD></TR>
<TR><TD><a href="FUNCREF.HTM#sqrt">VF_sqrt</a></TD>
<TD>square-root (which corresponds to a power of 0.5)</TD></TR>
</TABLE>&nbsp;

<BR>All of these functions exist also in the expanded "<I>VFx_</I>" form, like
<BR><I><a href="FUNCREF.HTM#square">VFx_square</a></I>: Y<SUB>i</SUB> = <B><FONT COLOR="#FF0000">(a * X<SUB>i</SUB> + b)</FONT></B>&sup2;&nbsp;<BR>
The expanded form of the unprotected functions has the prefix <I>VFux_</I>.

<P>The complex-number equivalents are available as well, both for cartesian and polar coordinates. Additionally, two special cases are covered:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#powReExpo">VCF_powReExpo</a></TD>
<TD>real, fractional powers of complex numbers</TD></TR>
<TR><TD><a href="FUNCREF.HTM#exp">VCF_exptoP</a></TD>
<TD>takes a cartesian input vector, returning its exponential function in polar coordinates.</TD></TR>
</TABLE>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<P><a name="chap4_6_7"></a>
<H2>4.6.7 Exponentials and Hyperbolic Functions</H2>
A variety of functions are derived from the exponential function <I><a href="FUNCREF.HTM#exp">VF_exp</a></I> (which
itself has already been mentioned in the last section).<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#exp">VF_exp</a></TD>
<TD>exponential function</TD></TR>
<TR><TD><a href="FUNCREF.HTM#expc">VF_expc</a></TD>
<TD>complementary exponential function Y<SUB>i</SUB> = 1 - exp[X<SUB>i</SUB>]</TD></TR>
<TR><TD><a href="FUNCREF.HTM#expmx2">VF_expmx2</a></TD>
<TD>exponential function of the negative square of the argument,<BR>
Y<SUB>i</SUB> = exp( -X<SUB>i</SUB>&sup2; ). This is a bell-shaped function.</TD></TR>
<TR><TD><a href="FUNCREF.HTM#Gauss">VF_Gauss</a></TD>
<TD>Gaussian distribution function</TD></TR>
<TR><TD><a href="FUNCREF.HTM#erf">VF_erf</a></TD>
<TD>Error function (Integral over the Gaussian distribution)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#erfc">VF_erfc</a></TD>
<TD>complementary error function, 1 - erf( X<SUB>i</SUB> )</TD></TR>
</TABLE>
&nbsp;
<BR>The vectorized hyperbolic functions are available as:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#sinh">VF_sinh</a></TD>
<TD>hyperbolic sine</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cosh">VF_cosh</a></TD>
<TD>hyperbolic cosine</TD></TR>
<TR><TD><a href="FUNCREF.HTM#tanh">VF_tanh</a></TD>
<TD>hyperbolic tangent</TD></TR>
<TR><TD><a href="FUNCREF.HTM#coth">VF_coth</a></TD>
<TD>hyperbolic cotangent</TD></TR>
<TR><TD><a href="FUNCREF.HTM#sech">VF_sech</a></TD>
<TD>hyperbolic secant</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cosech">VF_cosech</a></TD>
<TD>hyperbolic cosecant</TD></TR>
<TR><TD><a href="FUNCREF.HTM#sech2">VF_sech2</a></TD>
<TD>square of the hyperbolic secant</TD></TR>
</TABLE>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<P><a name="chap4_6_8"></a>
<H2>4.6.8 Logarithms</H2>

<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#log10">VF_log10</a></TD>
<TD>decadic logarithm (to the basis 10)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#log">VF_log</a></TD>
<TD>natural logarithm (to the basis e)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ln">VF_ln</a></TD>
<TD>synonym for <a href="FUNCREF.HTM#log">VF_log</a></TD></TR>
<TR><TD><a href="FUNCREF.HTM#log2">VF_log2</a></TD>
<TD>binary logarithm (to the basis 2)</TD></TR>
</TABLE>&nbsp;
<BR>Again, the cartesian-complex equivalents exist as well. The polar-complex versions, however, are special in that their output is always in cartesian coordinates:
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#log10">VPF_log10toC</a></TD>
<TD>decadic logarithm (to the basis 10)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#log">VPF_logtoC</a></TD>
<TD>natural logarithm (to the basis e)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ln">VPF_lntoC</a></TD>
<TD>synonym for <a href="FUNCREF.HTM#log">VPF_logtoC</a></TD></TR>
<TR><TD><a href="FUNCREF.HTM#log2">VPF_log2toC</a></TD>
<TD>binary logarithm (to the basis 2)</TD></TR>
</TABLE>

<BR>As a special form of the decadic logarithm, the Optical Density is made available by a family of functions of which some examples are contained in the following table:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#OD">VF_OD</a></TD><TD>OD = log10( X0/X ) for <B>fVector</B> as input and as output</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ODwDark">VF_ODwDark</a></TD><TD>OD = log10( (X0-X0Dark) / (X-XDark) ) for <B>fVector</B> as input and as output</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#OD">VUS_ODtoF</a></TD><TD>OD, calculated in <B>float</B> precision for <B>usVector</B> input</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#OD">VUL_ODtoD</a></TD><TD>OD, calculated in <B>double</B> precision for <B>ulVector</B> input</TD></TR>
<TR><TD><a href="FUNCREF.HTM#OD">VQI_ODtoEwDark</a></TD><TD>OD with dark-current correction, calculated in <B>extended</B> precision for <B>qiVector</B> input</TD></TR>
</TABLE>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<P><a name="chap4_6_9"></a>
<H2>4.6.9 Trigonometric Functions</H2>
Some of the basic trigonometric functions are available in two variants. The first variant follows the usual rules of error handling for math functions, whereas the second is for situations where you know beforehand that all input arguments will be in the range -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT>. If you choose to employ these extra-fast reduced-range functions, you really have to be absolutely sure about your input vectors, as these functions will crash without warning in the case of any input number outside the range specified above. The reduced-range functions are available only for the sine and cosine, as all other trigonometric functions need error checking and handling anyway, even in this range.<BR>&nbsp;

<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#sin">VF_sin</a></TD><TD>sine</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#sin">VFr_sin</a></TD><TD>extra-fast &quot;reduced-range&quot; sine function for -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT></TD>
</TR><TR><TD><a href="FUNCREF.HTM#cos">VF_cos</a></TD><TD>cosine</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#cos">VFr_cos</a></TD><TD>cosine for -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT></TD></TR>
<TR><TD><a href="FUNCREF.HTM#sincos">VF_sincos</a></TD><TD>sine and cosine at once</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#sincos">VFr_sincos</a></TD><TD>sine and cosine for -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT></TD></TR>
<TR><TD><a href="FUNCREF.HTM#tan">VF_tan</a></TD><TD>tangent</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cot">VF_cot</a></TD><TD>cotangent</TD></TR>
<TR><TD><a href="FUNCREF.HTM#sec">VF_sec</a></TD><TD>secant</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cosec">VF_cosec</a></TD><TD>cosecant</TD></TR>
</TABLE>
&nbsp;
<BR>The following functions yield the squares of the trigonometric functions in a more efficient way than by first calculating the basic functions and squaring afterwards:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#sin2">VF_sin2</a></TD><TD>sine&sup2;</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#sin2">VFr_sin2</a></TD><TD>sine&sup2; for -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT></TD></TR>
<TR><TD><a href="FUNCREF.HTM#cos2">VF_cos2</a></TD><TD>cosine&sup2;</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#cos2">VFr_cos2</a></TD><TD>cosine&sup2; for -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT></TD></TR>
<TR><TD><a href="FUNCREF.HTM#sincos2">VF_sincos2</a></TD><TD>sine&sup2; and cosine&sup2; at once</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#sincos2">VFr_sincos2</a></TD><TD>sine&sup2; and cosine&sup2; for -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT></TD></TR>
<TR><TD><a href="FUNCREF.HTM#tan2">VF_tan2</a></TD><TD>tangent&sup2;</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cot2">VF_cot2</a></TD><TD>cotangent&sup2;</TD></TR>
<TR><TD><a href="FUNCREF.HTM#sec2">VF_sec2</a></TD><TD>secant&sup2;</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cosec2">VF_cosec2</a></TD><TD>cosecant&sup2;</TD></TR>
</TABLE>&nbsp;

<BR>A very efficient way to calculate the trigonometric functions for arguments representable as rational multiples of <FONT FACE="Symbol">p</FONT> (PI) is supplied by the trigonometric functions with the suffix &quot;rpi&quot; (meaning &quot;rational multiple of <FONT FACE="Symbol">p</FONT>&quot;). Here, r = p / q, where q is constant and p is given by the input vector elements:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#sinrpi">VF_sinrpi</a></TD><TD>sine of p/q * <FONT FACE="Symbol">p</FONT></TD></TR>
<TR><TD><a href="FUNCREF.HTM#cosrpi">VF_cosrpi</a></TD><TD>cosine of p/q * <FONT FACE="Symbol">p</FONT></TD></TR>
<TR><TD><a href="FUNCREF.HTM#sincosrpi">VF_sincosrpi</a></TD><TD>sine and cosine of p/q * <FONT FACE="Symbol">p</FONT> at once</TD></TR>
<TR><TD><a href="FUNCREF.HTM#tanrpi">VF_tanrpi</a></TD><TD>tangent of p/q * <FONT FACE="Symbol">p</FONT></TD></TR>
<TR><TD><a href="FUNCREF.HTM#cotrpi">VF_cotrpi</a></TD><TD>cotangent of p/q * <FONT FACE="Symbol">p</FONT></TD></TR>
<TR><TD><a href="FUNCREF.HTM#secrpi">VF_secrpi</a></TD><TD>secant of p/q * <FONT FACE="Symbol">p</FONT></TD></TR>
<TR><TD><a href="FUNCREF.HTM#cosecrpi">VF_cosecrpi</a></TD><TD>cosecant of p/q * <FONT FACE="Symbol">p</FONT></TD></TR>
</TABLE>&nbsp;

<BR>Even more efficient versions use tables to obtain frequently-used values; these versions are denoted by the suffixes &quot;rpi2&quot; (multiples of <FONT FACE="Symbol">p</FONT> divided by an integer power of 2) and &quot;rpi3&quot; (multiples of <FONT FACE="Symbol">p</FONT> over an integer multiple of 3). Examples are:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#sinrpi">VF_sinrpi2</a></TD>
<TD>sine of p / 2<SUP>n</SUP> * <FONT FACE="Symbol">p</FONT></TD></TR>
<TR><TD><a href="FUNCREF.HTM#tanrpi">VF_tanrpi3</a></TD>
<TD>tangent of p / (3*n) * <FONT FACE="Symbol">p</FONT></TD></TR>
</TABLE>
&nbsp;
<BR>Two more special trigonometric functions are:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#sinc">VF_sinc</a></TD>
<TD>sinc function, Y<SUB>i</SUB> = sin( X<SUB>i</SUB> ) / X<SUB>i</SUB></TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#Kepler">VF_Kepler</a></TD>
<TD>Kepler function, calculating the time-dependent angular position of a planet or comet</TD></TR>
</TABLE>&nbsp;

<BR>Vectorized inverse trigonometric functions are available as&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#asin">VF_asin</a></TD><TD>arc sin</TD></TR>
<TR><TD><a href="FUNCREF.HTM#acos">VF_acos</a></TD><TD>arc cos</TD></TR>
<TR><TD><a href="FUNCREF.HTM#atan">VF_atan</a></TD><TD>arc tan</TD></TR>
<TR><TD><a href="FUNCREF.HTM#atan2">VF_atan2</a></TD>
<TD>arc tan of ratios, Z<SUB>i</SUB> = atan( Y<SUB>i</SUB> / X<SUB>i</SUB> )</TD></TR>
</TABLE>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<P><a name="chap4_7"></a>
<H2>4.7 Analysis</H2>
There is a number of functions probing the analytical properties of data arrays:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#derivV">VF_derivV</a></TD>
<TD>derivative of a Y-array with respect to an X-array</TD></TR>
<TR><TD><a href="FUNCREF.HTM#derivC">VF_derivC</a></TD>
<TD>the same for constant intervals between the X-values</TD></TR>
<TR><TD><a href="FUNCREF.HTM#integralV">VF_integralV</a></TD>
<TD>value of the integral of a Y-array over an X-array</TD></TR>
<TR><TD><a href="FUNCREF.HTM#runintegralV">VF_runintegralV</a></TD>
<TD>point-by-point ("running") integral</TD></TR>
<TR><TD><a href="FUNCREF.HTM#integralC">VF_integralC</a></TD>
<TD>integral over an equally spaced X-axis</TD></TR>
<TR><TD><a href="FUNCREF.HTM#runintegralC">VF_runintegralC</a></TD>
<TD>point-by-point integral over an equally spaced X-axis</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ismonoton">VF_ismonoton</a></TD>
<TD>test if an array is monotonously rising or falling</TD></TR>
<TR><TD><a href="FUNCREF.HTM#iselementC">VF_iselementC</a></TD>
<TD>test, if a given value occurs within a vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#searchC">VF_searchC</a></TD>
<TD>search an ordered table for the entry whose value comes closest to a preset value <I>C</I></TD></TR>
<TR><TD><a href="FUNCREF.HTM#localmaxima">VF_localmaxima</a></TD>
<TD>detect local maxima (points whose right and left neighbours are smaller)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#localminima">VF_localminima</a></TD>
<TD>detect local minima (points whose right and left neighbours are larger)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#max">VF_max</a></TD>
<TD>detect global maximum</TD></TR>
<TR><TD><a href="FUNCREF.HTM#min">VF_min</a></TD>
<TD>detect global minimum</TD></TR>
<TR><TD><a href="FUNCREF.HTM#maxind">VF_maxind</a></TD>
<TD>global maximum and its index</TD></TR>
<TR><TD><a href="FUNCREF.HTM#minind">VF_minind</a></TD>
<TD>global minimum and its index</TD></TR>
<TR><TD><a href="FUNCREF.HTM#absmax">VF_absmax</a></TD>
<TD>global maximum absolute value</TD></TR>
<TR><TD><a href="FUNCREF.HTM#absmin">VF_absmin</a></TD>
<TD>global minimum absolute value</TD></TR>
<TR><TD><a href="FUNCREF.HTM#absmaxind">VF_absmaxind</a></TD>
<TD>global maximum absolute value and its index</TD></TR>
<TR><TD><a href="FUNCREF.HTM#absminind">VF_absminind</a></TD>
<TD>global minimum absolute value and its index</TD></TR>
<TR><TD><a href="FUNCREF.HTM#runmax">VF_runmax</a></TD>
<TD>&quot;running&quot; maximum</TD></TR>
<TR><TD><a href="FUNCREF.HTM#runmin">VF_runmin</a></TD>
<TD>&quot;running&quot; minimum</TD></TR>
</TABLE>
<P>The complex equivalents of the last group of functions are:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#maxReIm">VCF_maxReIm</a></TD>
<TD>maximum real and imaginary parts separately</TD></TR>
<TR><TD><a href="FUNCREF.HTM#minReIm">VCF_minReIm</a></TD>
<TD>minimum real and imaginary parts separately</TD></TR>
<TR><TD><a href="FUNCREF.HTM#absmaxReIm">VCF_absmaxReIm</a></TD>
<TD>maximum absolute real and imaginary values separately</TD></TR>
<TR><TD><a href="FUNCREF.HTM#absminReIm">VCF_absminReIm</a></TD>
<TD>minimum absolute real and imaginary values separately</TD></TR>
<TR><TD><a href="FUNCREF.HTM#absmax">VCF_absmax</a></TD>
<TD>largest magnitude (absolute value; this is a real number)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#absmin">VCF_absmin</a></TD>
<TD>smallest magnitude</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cabsmax">VCF_cabsmax</a></TD>
<TD>complex number of largest magnitude</TD></TR>
<TR><TD><a href="FUNCREF.HTM#cabsmin">VCF_cabsmin</a></TD>
<TD>complex number of smallest magnitude</TD></TR>
<TR><TD><a href="FUNCREF.HTM#sabsmax">VCF_sabsmax</a></TD>
<TD>complex number for which the sum |Re| + |Im| is largest</TD></TR>
<TR><TD><a href="FUNCREF.HTM#sabsmin">VCF_sabsmin</a></TD>
<TD>smallest complex number in terms of the sum |Re| + |Im|</TD></TR>
<TR><TD><a href="FUNCREF.HTM#absmaxind">VCF_absmaxind</a></TD>
<TD>largest magnitude (absolute value) and its index</TD></TR>
<TR><TD><a href="FUNCREF.HTM#absminind">VCF_absminind</a></TD>
<TD>smallest magnitude and its index</TD></TR>
</TABLE>&nbsp;

<BR>Sums, products, etc. are available by functions grouped as statistical building blocks and summarized in <a href="#chap4_9">chapter 4.9</A>.&nbsp;
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<A NAME="chap4_8"></A>
<h2>4.8 Signal Processing:
<BR>Fourier Transforms and Related Topics</h2>
The following list of functions is available for signal processing applications:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#FFT">VF_FFTtoC</a></TD>
<TD>forward Fast Fourier Transform (FFT) of a real vector; the result is a cartesian complex vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#FFT">VF_FFT</a></TD>
<TD>forward and backward FFT of a real vector; the result of the forward FFT is packed into a real vector of the same size as the input vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#FFT">VCF_FFT</a></TD>
<TD>forward and backward FFT of a complex vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#convolve">VF_convolve</a></TD>
<TD>convolution with a given response function</TD></TR>
<TR><TD><a href="FUNCREF.HTM#deconvolve">VF_deconvolve</a></TD>
<TD>deconvolution, assuming a given response function</TD></TR>
<TR><TD><a href="FUNCREF.HTM#filter">VF_filter</a></TD>
<TD>spectral filtering</TD></TR>
<TR><TD><a href="FUNCREF.HTM#spectrum">VF_spectrum</a></TD>
<TD>spectral analysis</TD></TR>
<TR><TD><a href="FUNCREF.HTM#autocorr">VF_autocorr</a></TD>
<TD>autocorrelation function of a data array</TD></TR>
<TR><TD><a href="FUNCREF.HTM#xcorr">VF_xcorr</a></TD>
<TD>cross-correlation function of two arrays</TD></TR>
<TR><TD><a href="FUNCREF.HTM#setRspEdit">VF_setRspEdit</a></TD>
<TD>set editing threshold for the filter in convolutions and deconvolutions
(decides over the treatment of "lost" frequencies)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#getRspEdit">VF_getRspEdit</a></TD>
<TD>retrieve the current editing threshold</TD></TR>
</TABLE>

<P>The FFT algorithm chosen for this PC implementation is a radix-2 Cooley-Tukey routine. Only for this radix-2 algorithm, the restricted number of eight coprocessor registers still allows to hold all intermediate results of the inner transform loop in coprocessor registers. Although featuring savings in the number of multiplications, radix-4 and radix-8 routines are rendered less efficient than the routine chosen by the need of storing intermediate results in memory.
<BR>There are two different versions of all FFT-based functions. Depending on the memory model, either of the two is automatically chosen. You may, however, explicitly specify the one you wish to employ. The first one uses the already-mentioned table of sine values (see <a href="#chap4_6_9">chapter 4.6.9.</a> and the function <I><a href="FUNCREF.HTM#sinrpi">VF_sinrpi2</a></I>) as a look-up table for the Fourier coefficients needed. This table needs up to 10 kBytes in the 16-bit models and 40 kBytes in the 32-bit models. 
<BR>By default, this very fast variant is used in the memory models FLAT, COMPACT and LARGE. To explicitly specify it in the other memory models, please use the prefixes <I>VFl_,&nbsp; VDl_,&nbsp; VEl_</I> (with the letter &quot;l&quot; for the &quot;larger&quot; amount of memory needed). 
<BR>The second variant, which is automatically chosen in all other memory models, employs trigonometric recursions to obtain the sine and cosine values with still satisfactory speed, though this procedure is not as fast as simply reading them from a table. You may explicitly specifiy this variant by adding the letter &quot;s&quot; (for the &quot;smaller&quot; amount of memory needed) in the function prefix. Examples are <I><a href="FUNCREF.HTM#FFT">VFs_FFT</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#convolve">VDs_convolve</a></I>,&nbsp;&nbsp;
<I><a href="FUNCREF.HTM#spectrum">VEs_spectrum</a></I>.
<BR>If you decide to use this variant in order to economize memory in the models COMPACT and LARGE, use the prefix <I>VFs_</I> for all(!) routines employing FFT. Otherwise, you might happen to load not only a second FFT routine, but also its whole look-up table into your already overcrowded memory.
<P>As all FFT-based matrix functions internally rely on <I>VF_FFT</I>, all of them exist in two versions as well. Here, the prefixes are  <I>MFs_</I> and <I>MFl_</I> in the real-number case, or  <I>MCFs_</I> and <I>MCFl_</I> in the complex case. Similarly to the one-dimensional case, the functions with the &quot;normal&quot; prefix (<I>MF_,&nbsp; MCF_</I>) will automatically be redirected to the <I>MFs_</I> or the <I>MFl_</I> variant, as determined by the memory model.
<P>Although it does not use Fourier transform methods, <I><a href="FUNCREF.HTM#smooth">VF_smooth</a></I> should be
remembered here as a crude form of frequency filtering which removes high-frequency noise.
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<P><a name="chap4_9"></a>
<H2>4.9 Statistical Functions and Building Blocks</H2>
The following collection of statistical functions is offered by <I>OptiVec</I>:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#sum">VF_sum</a></TD>
<TD>sum of all elements</TD></TR>
<TR valign="top"><TD><a href="FUNCREF.HTM#fsum">VI_fsum</a></TD>
<TD>sum of all elements of an integer vector, accumulated as a floating point number in double or extended precision</TD></TR>
<TR><TD><a href="FUNCREF.HTM#prod">VF_prod</a></TD>
<TD>product of all elements</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ssq">VF_ssq</a></TD>
<TD>sum-of-squares of all elements</TD></TR>
<TR><TD><a href="FUNCREF.HTM#sumabs">VF_sumabs</a></TD>
<TD>sum of absolute values of all elements</TD></TR>
<TR><TD><a href="FUNCREF.HTM#rms">VF_rms</a></TD>
<TD>root-of-the-mean-square of all elements</TD></TR>
<TR><TD><a href="FUNCREF.HTM#runsum">VF_runsum</a></TD>
<TD>running sum</TD></TR>
<TR><TD><a href="FUNCREF.HTM#runprod">VF_runprod</a></TD>
<TD>running product</TD></TR>
<TR><TD><a href="FUNCREF.HTM#sumdevC">VF_sumdevC</a></TD>
<TD>sum over the deviations from a preset constant, sum( |X<SUB>i</SUB>-C| )</TD></TR>
<TR><TD><a href="FUNCREF.HTM#sumdevV">VF_sumdevV</a></TD>
<TD>sum over the deviations from another vector, sum( |X<SUB>i</SUB>-Y<SUB>i</SUB>|&nbsp;)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#avdevC">VF_avdevC</a></TD>
<TD>average deviation from a preset constant, 1/N * sum( |X<SUB>i</SUB>-C| )</TD></TR>
<TR><TD><a href="FUNCREF.HTM#avdevV">VF_avdevV</a></TD>
<TD>average deviation from another vector, 1 / N * sum( |X<SUB>i</SUB>-Y<SUB>i</SUB>|&nbsp;)</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ssqdevC">VF_ssqdevC</a></TD>
<TD>sum-of-squares of the deviations from a preset constant,<BR>
sum( (X<SUB>i</SUB> - C)&sup2; )</TD></TR>
<TR><TD><a href="FUNCREF.HTM#ssqdevV">VF_ssqdevV</a></TD>
<TD>sum-of-squares of the deviations from another vector,<BR>
sum( (X<SUB>i</SUB> - Y<SUB>i</SUB>)&sup2; )</TD></TR>
<TR><TD><a href="FUNCREF.HTM#chi2">VF_chi2</a></TD>
<TD>chi-square merit function</TD></TR>
<TR><TD><a href="FUNCREF.HTM#chiabs">VF_chiabs</a></TD>
<TD>&quot;robust&quot; merit function, similar to <a href="FUNCREF.HTM#chi2">VF_chi2</a>, but based on absolute instead of squared deviations</TD></TR>
<TR><TD><a href="FUNCREF.HTM#mean">VF_mean</a></TD>
<TD>equally-weighted mean (or average) of all elements</TD></TR>
<TR><TD><a href="FUNCREF.HTM#meanwW">VF_meanwW</a></TD>
<TD>&quot;mean with weights&quot; of all elements</TD></TR>
<TR><TD><a href="FUNCREF.HTM#meanabs">VF_meanabs</a></TD>
<TD>equally-weighted mean (or average) of the absolute values of all elements</TD></TR>
<TR><TD><a href="FUNCREF.HTM#selected_mean">VF_selected_mean</a></TD>
<TD>averages only those vector elements which fall into a specified range, thus allowing to exclude outlier points from the calculation of the mean</TD></TR>
<TR><TD><a href="FUNCREF.HTM#varianceC">VF_varianceC</a></TD>
<TD>variance of a distribution with respect to a preset constant value</TD></TR>
<TR><TD><a href="FUNCREF.HTM#varianceCwW">VF_varianceCwW</a></TD>
<TD>the same with non-equal weighting</TD></TR>
<TR><TD><a href="FUNCREF.HTM#varianceV">VF_varianceV</a></TD>
<TD>variance of one distribution with respect to another</TD></TR>
<TR><TD><a href="FUNCREF.HTM#varianceVwW">VF_varianceVwW</a></TD>
<TD>the same with non-equal weighting</TD></TR>
<TR><TD><a href="FUNCREF.HTM#meanvar">VF_meanvar</a></TD>
<TD>mean and variance of a distribution simultaneously</TD></TR>
<TR><TD><a href="FUNCREF.HTM#meanvarwW">VF_meanvarwW</a></TD>
<TD>the same with non-equal weighting</TD></TR>
<TR><TD><a href="FUNCREF.HTM#median">VF_median</a></TD>
<TD>median of a distribution</TD></TR>
<TR><TD><a href="FUNCREF.HTM#corrcoeff">VF_corrcoeff</a></TD>
<TD>linear correlation coefficient of two distributions</TD></TR>
<TR><TD><a href="FUNCREF.HTM#distribution">VF_distribution</a></TD>
<TD>bins data into a discrete one-dimensional distribution function</TD></TR>
</TABLE>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<P><a name="chap4_10"></a>
<H2>4.10 Data Fitting</H2>
Ranging from a simple linear regression to complex fitting problems involving multiple data sets and nonlinear functions with many adjustable parameters, <I>OptiVec</I> offers routines for virtually all practically occurring tasks of data fitting. As all of them, except for simple linear regression, rely on matrix methods, they actually form a part of <I>MatrixLib</I>. This means you have to <font face="courier new">#include &lt;MFstd.h&gt; (&lt;MDstd.h&gt;&lt; MEstd.h&gt;)</font> or the unit MFstd, (MDstd, MEstd). In the 16-bit models of Borland C/C++, you also have to include the MC??.LIB file for the respective model.
<P>A detailed description of the various data-fitting concepts is given in <a href="MATRIX.HTM#chap13">chapter 13 of MATRIX.HTM</a>. Therefore, at this place, the available X-Y fitting functions are only summarized in the following table:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#linregress">VF_linregress</a></TD>
<TD>equally-weighted linear regression on X-Y data</TD></TR>
<TR><TD><a href="FUNCREF.HTM#linregress">VF_linregresswW</a></TD>
<TD>the same with non-equal weighting</TD></TR>
<TR><TD><a href="MATRIX.HTM#polyfit">VF_polyfit</a></TD>
<TD>fitting of one X-Y data set to a polynomial</TD></TR>
<TR><TD><a href="MATRIX.HTM#polyfit">VF_polyfitwW</a></TD>
<TD>the same for non-equal data-point weighting</TD></TR>
<TR><TD><a href="MATRIX.HTM#linfit">VF_linfit</a></TD>
<TD>fitting of one X-Y data set to an arbitrary function linear in its parameters</TD></TR>
<TR><TD><a href="MATRIX.HTM#linfit">VF_linfitwW</a></TD>
<TD>the same for non-equal data-point weighting</TD></TR>
<TR><TD><a href="MATRIX.HTM#setLinfitNeglect">VF_setLinfitNeglect</a></TD>
<TD>set threshold to neglect (i.e. set equal to zero) a fitting parameter A[i], if its significance is smaller than the threshold</TD></TR>
<TR><TD><a href="MATRIX.HTM#getLinfitNeglect">VF_getLinfitNeglect</a></TD>
<TD>retrieve current significance threshold</TD></TR>
<TR><TD><a href="MATRIX.HTM#nonlinfit">VF_nonlinfit</a></TD>
<TD>fitting of one X-Y data set to an arbitrary, possibly non-linear function</TD></TR>
<TR><TD><a href="MATRIX.HTM#nonlinfit">VF_nonlinfitwW</a></TD>
<TD>the same for non-equal data-point weighting</TD></TR>
<TR><TD><a href="MATRIX.HTM#multiLinfit">VF_multiLinfit</a></TD>
<TD>fitting of multiple X-Y data sets to one common linear function</TD></TR>
<TR><TD><a href="MATRIX.HTM#multiLinfit">VF_multiLinfitwW</a></TD>
<TD>the same for non-equal data-point weighting</TD></TR>
<TR><TD><a href="MATRIX.HTM#multiNonlinfit">VF_multiNonlinfit</a></TD>
<TD>fitting of multiple X-Y data sets to one common nonlinear function</TD></TR>
<TR><TD><a href="MATRIX.HTM#multiNonlinfit">VF_multiNonlinfitwW</a></TD>
<TD>the same for non-equal data-point weighting</TD></TR>
</TABLE>&nbsp;

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<P><a name="chap4_11"></a>
<H2>4.11 Input and Output</H2>
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#cprint">VF_cprint</a></TD>
<TD>print the elements of a vector to the screen (or "console" &#150; hence the "c" in the name) into the current text window, automatically detecting its height and width. After printing one page, the user is prompted to continue. (Only for DOS)</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#print">VF_print</a></TD>
<TD>is similar to <a href="FUNCREF.HTM#cprint">VF_cprint</a> in that the output is directed to the screen, but there is no automatic detection of the screen data; a default linewidth of 80 characters is assumed, and no division into pages is made. (Only for DOS and EasyWin)</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#fprint">VF_fprint</a></TD>
<TD>print a vector to a stream.</TD></TR>
<TR><TD><a href="FUNCREF.HTM#write">VF_write</a></TD>
<TD>write data in ASCII format in a stream</TD></TR>
<TR><TD><a href="FUNCREF.HTM#read">VF_read</a></TD>
<TD>read a vector from an ASCII file</TD></TR>
<TR><TD><a href="FUNCREF.HTM#nwrite">VF_nwrite</a></TD>
<TD>write <I>n</I> vectors of the same data type as the columns of a table into a stream</TD></TR>
<TR><TD><a href="FUNCREF.HTM#nread">VF_nread</a></TD>
<TD>read the columns of a table into <I>n</I> vectors of the same type</TD></TR>
<TR><TD><a href="FUNCREF.HTM#store">VF_store</a></TD>
<TD>store data in binary format</TD></TR>
<TR><TD><a href="FUNCREF.HTM#recall">VF_recall</a></TD>
<TD>retrieve data in binary format</TD></TR>
</TABLE>

<P>The following functions allow to modify the standard settings of <I><a href="FUNCREF.HTM#write">VF_write</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#nwrite">VF_nwrite</a></I> and <I><a href="FUNCREF.HTM#read">VI_read</a></I>:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#setWriteFormat">VF_setWriteFormat</a></TD>
<TD>define a certain number format</TD></TR>
<TR><TD><a href="FUNCREF.HTM#setWriteSeparate">VF_setWriteSeparate</a></TD>
<TD>define a separation string between successive elements, written by <I><a href="FUNCREF.HTM#write">VF_write</a></I></TD></TR>
<TR><TD><a href="FUNCREF.HTM#setNWriteSeparate">VF_setNWriteSeparate</a></TD>
<TD>define a separation string between the columns written by <I><a href="FUNCREF.HTM#nwrite">VF_nwrite</a></I></TD></TR>
<TR><TD><a href="FUNCREF.HTM#setRadix">V_setRadix</a></TD>
<TD>define a radix different from the standard of 10 for the whole-number variants of the <I>V.._read</I> functions</TD></TR>
</TABLE>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<P><a name="chap4_12"></a>
<H2>4.12 Graphics</H2>
<I>VectorLib</I> includes a range of data-plotting routines. Before any of them may be used, <I>VectorLib</I> graphics has to be initialized:<BR>&nbsp;

<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#initPlot">V_initPlot</a></TD>
<TD>initialize <I>VectorLib</I> graphics functions (both Windows and DOS). For Windows, no shut-down is needed at the end, since the Windows graphics functions always remain accessible. <I>V_initPlot</I> automatically reserves a part of the screen for plotting operations. This part comprises about 2/3 of the screen on the right side. Above, one line is left for a heading. Below, a few lines are left empty. To change this default plotting region, call <I><a href="FUNCREF.HTM#setPlotRegion">V_setPlotRegion</a></I> after <I>V_initPlot</I>.</TD></TR>
<TR><TD><a href="FUNCREF.HTM#initGraph">V_initGraph</a></TD>
<TD>simultaneously initialize Borland's graphics interface and <I>VectorLib</I> plotting functions (DOS only). Do not call <I>initgraph</I> after <I><a href="FUNCREF.HTM#initGraph">V_initGraph</a></I>. If, on the other hand, you have already called <I>initgraph</I>, do <U>not</U> use <I><a href="FUNCREF.HTM#initGraph">V_initGraph</a></I>, but <I><a href="FUNCREF.HTM#initPlot">V_initPlot</a></I> instead. At the end of the graphics session, the BGI function
<I>closegraph</I> has to be used to leave the graphics mode and to release graphics buffer memory.</TD></TR>
<TR><TD><a href="FUNCREF.HTM#initPrint">V_initPrint</a></TD>
<TD>initialize <I>VectorLib</I> graphics functions and direct them to a printer (Windows only). By default, one whole page is reserved for plotting. In order to change this, call <I><a href="FUNCREF.HTM#setPlotRegion">V_setPlotRegion</a></I> after <I>V_initPrint</I>.</TD></TR>
<TR><TD><a href="FUNCREF.HTM#setPlotRegion">V_setPlotRegion</a></TD>
<TD>set a plotting region different from the default</TD></TR>
</TABLE>

<P><I>VectorLib</I> distinguishes between two sorts of plotting functions, <I>AutoPlot</I> and <I>DataPlot</I>. All <I>AutoPlot</I> functions (e.g., <I><a href="FUNCREF.HTM#xyAutoPlot">VF_xyAutoPlot</a></I>) execute the following steps:
<OL><LI>define a viewport within the plotting region (which is either the default region or the one defined by calling <I><a href="FUNCREF.HTM#setPlotRegion">V_setPlotRegion</a></I>)
<LI>clear the viewport
<LI>generate a Cartesian coordinate system with suitably scaled and labeled axes
<LI>plot the data according to the parameters passed to the function
</OL>
All <I>DataPlot</I> functions execute only the last step. They assume that a coordinate system already exists from a previous
call to any of the <I>AutoPlot</I> functions, to <I><a href="FUNCREF.HTM#findAxes">V_findAxes</a></I>, or to <I><a href="FUNCREF.HTM#drawAxes">V_drawAxes</a></I>. The new plot is added to the existing one. All settings of this coordinate system have to be valid. The viewport must still be the active one and the scaling of the axes has to fit also for
the new data plot.
<BR>To add text and lables, a new viewport must be defined. Use <I>SetViewportOrgEx</I> (32-bit Windows), <I>SetViewportOrg</I> (16-bit Windows), or <I>setviewport</I> (DOS).<BR>
<BR>If you wish to switch back into text mode in DOS, use <I>restorecrtmode</I>. After that, a new call to <I><a href="FUNCREF.HTM#initPlot">V_initPlot</a></I> (not <I><a href="FUNCREF.HTM#initGraph">V_initGraph</a></I>!) brings you back into graphics mode.

<BR>For all plotting functions, the different plot styles (symbols, lines, and colors), are specified as parameters, see <I><a href="FUNCREF.HTM#xyAutoPlot">VF_xyAutoPlot</a></I>. Here is a list of the available <I>AutoPlot</I> and <I>DataPlot</I> routines:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#xyAutoPlot">VF_xyAutoPlot</a></TD>
<TD>display an automatically-scaled plot of an X-Y vector pair</TD></TR>
<TR><TD><a href="FUNCREF.HTM#yAutoPlot">VF_yAutoPlot</a></TD>
<TD>plot a single Y-vector, using the index as X-axis</TD></TR>
<TR><TD><a href="FUNCREF.HTM#xy2AutoPlot">VF_xy2AutoPlot</a></TD>
<TD>plot two X-Y pairs at once, scaling the axes in such a way that both
vectors fit into the same coordinate system</TD></TR>
<TR><TD><a href="FUNCREF.HTM#y2AutoPlot">VF_y2AutoPlot</a></TD>
<TD>the same for two Y-vectors, plotted against their indices</TD></TR>
<TR><TD><a href="FUNCREF.HTM#xyDataPlot">VF_xyDataPlot</a></TD>
<TD>plot one additional set of X-Y data</TD></TR>
<TR><TD><a href="FUNCREF.HTM#yDataPlot">VF_yDataPlot</a></TD>
<TD>plot one additional Y vector over its index</TD>
</TR>
</TABLE>
<P>Cartesian complex arrays are printed into the complex plane (the imaginary parts versus the real parts), using<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#autoPlot">VCF_autoPlot</a></TD>
<TD>plot one cartesian complex vector</TD></TR>
<TR><TD><a href="FUNCREF.HTM#2AutoPlot">VCF_2AutoPlot</a></TD>
<TD>plot two cartesian complex vectors simultaneously</TD></TR>
<TR><TD><a href="FUNCREF.HTM#dataPlot">VCF_dataPlot</a></TD>
<TD>plot one additional cartesian complex vector</TD></TR>
</TABLE>
<P>At present, there are no plotting functions for polar complex vectors included.
<BR>It is possible to draw more than one coordinate systems into a given window on the screen. The position of each coordinate system must be specified by the above-mentioned function <I><a href="FUNCREF.HTM#setPlotRegion">V_setPlotRegion</a></I>. &quot;Hopping&quot; between the different coordinate systems and adding new DataPlots after defining new viewports (e.g., for text output) is made possible by the following functions:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#continuePlot">V_continuePlot</a></TD>
<TD>go back to the viewport of the last plot and restore its scalings</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#getCoordSystem">V_getCoordSystem</a></TD>
<TD>get a copy of the scalings and position of the current coordinate system</TD></TR>
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#setCoordSystem">V_setCoordSystem</a></TD>
<TD>restore the scalings and position of a coordinate system; these must have been stored previously, using <I><a href="FUNCREF.HTM#getCoordSystem">V_getCoordSystem</a></I></TD></TR>
</TABLE>
<P><U>DOS only:</U>
<BR>When using multiple coordinate systems on the same screen, the default font used for axis labeling might be too large, so that neighbouring labels overlap each other. In these cases, use the BGI function <I>settextstyle</I> to switch to another font before calling an <I>AutoPlot</I> function.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A>&nbsp;

<P><a name="chap5"></a>
<H1><HR width="100%">5. Error Handling </H1>

<P><a name="chap5_1"></a>
<H2>5.1 General Remarks</H2>
There are two general types of error handling: by the hardware, or by the software. In order to prevent uncontrolled program crash, it is highly desirable that conditions, leading to hardware errors, be recognized before the errors actually occur. All high-level computer languages support this software error-handling to various degrees of perfection. Within the
tightly-defined functions and routines of this <I>OptiVec</I> package, often an even more efficient error handling by the program itself is possible than provided by the compilers for user-written code.
<BR>However, it should be noted that no absolute overflow protection is possible for the extended-precision versions. They do not have a &quot;safety margin&quot; left as in the single- and double-precision versions, where internally all calculations are performed in extended precision. Especially the <I>VEx_</I> and <I>VCEx_</I> versions may fail if constant parameters are very large, or if the X vector elements themselves are already near the overflow limit. To be on the safe side, constant parameters should not exceed about 1.E32 for float, 1.E150 for double, and 1.E2000 for extended parameters.
<P>In the &quot;expanded&quot; versions of all functions with extended accuracy (those with the prefixes <I>VEx_</I> and <I>VCEx_</I>; for example <I><a href="FUNCREF.HTM#exp">VEx_exp</a></I>), there is generally no overflow protection for the calculation of A*X<sub>i</sub>+B, but only for the core of the function itself and for the final multiplication by C.
<P>A series of identical errors occurring within one and the same <I>OptiVec</I> function leads to one error message only. Subsequent identical messages are suppressed.
<P>There is a fundamental difference between floating-point and integer numbers with respect to OVERFLOW and DOMAIN errors: for floating-point numbers, these are always serious errors, whereas for integer numbers, by virtue of the implicit modulo-2<sup>n</sup> arithmetics, this is not necessarily the case. In the following two paragraphs, details are given on the error handling of integer and floating-point numbers, respectively.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap5_2"></a>
<H2>5.2 Integer Errors</H2>
The only genuine integer errors are ZERODIVIDE errors (if a division by 0 is attempted). Other integer errors are neglected due to the implicit definition of integer operations as being performed modulo the respective power of 2 (see <a href="#chap4_4">chapter 4.4</a>). For those situations in which implicit modulo 2<sup>n</sup> arithmetics is not appropriate, <I>OptiVec</I> offers the possibility to trap these errors and print an error message and/or abort the program. 
<BR>All functions where INTEGER OVERFLOW (e.g., in <I><a href="FUNCREF.HTM#ramp">VI_ramp</a>,&nbsp; <a href="FUNCREF.HTM#mulV">VI_mulV</a></I>, etc.) or INTEGER DOMAIN errors (e.g., in <I><a href="FUNCREF.HTM#ItoBI">V_ItoU</a></I> for negative X-values) may occur, exist in two versions: the &quot;normal&quot; version employs modulo 2<sup>n</sup> arithmetics and interchanges signed and unsigned data types according to their bit pattern. For the 16-bit and 32-bit integer types (but not for 8-bit and 64-bit), there is a second version which also employs modulo 2<sup>n</sup> arithmetics, but detects the errors. This second variant is denoted by the letter &quot;o&quot; (for &quot;overflow detection&quot;) in the prefix:  <I>VIo_,&nbsp; VSIo_,&nbsp; VULo_</I>, etc. (for the data-type interconversion functions, the prefix <I>V_</I> is changed into <I>Vo_</I>).  Here, the action to be taken in the case of INTEGER OVERFLOW or INTEGER DOMAIN errors has to be defined by calling <I><a href="FUNCREF.HTM#setIntErrorHandling">V_setIntErrorHandling</a></I> somewhere before the call to the <I>VIo_</I> function. <I>V_setIntErrorHandling</I> takes an argument of the type V_ihand (defined in &lt;VecLib.h&gt; and the unit VecLib) with one of three possible values:<BR>&nbsp;
<table border width="100%"><tr><td>ierrNote</td><td>print an error message</td></tr>
<tr><td>ierrAbort</td><td>print an error message and exit the program</td></tr>
<tr valign="top"><td>ierrIgnore&nbsp;</td><td>ignore the problem. With this last option, the error handling can be switched off intermediately.</td></tr>
</table>
<P>Although you may use a call to<BR>
<font face="courier new">V_setIntErrorHandling( ierrIgnore );</font><BR>
to switch the error handling off, it is always better simply to use the &quot;normal&quot; <I>VI_</I> version rather than the <I>VIo_</I> version with the error-handling short-cut, as the normal version is always much faster.

<P><U>C/C++ only:</U><BR>
To choose the overflow-detecting version not only for single function calls, but everywhere, the easiest way is to define symbolic constant <I>V_trapIntError</I> in the program header before(!) &lt;VecLib.h&gt; is included:
<BR>Example:<font face="courier new">
<BR>#define V_trapIntError 1
<BR>#include &lt;VIstd.h&gt;
<BR>#include &lt;VImath.h&gt;
<BR>.....
<BR>main() /* or WinMain(), or OwlMain() */
<BR>{
<BR>&nbsp;&nbsp;iVector I1, I2;
<BR>&nbsp;&nbsp;I1 = <a href="FUNCREF.HTM#vector">VI_vector</a>( 1000 ); I2 = VI_vector( 1000 );
<BR>&nbsp;&nbsp;<a href="FUNCREF.HTM#setIntErrorHandling">V_setIntErrorHandling</a>( ierrNote );
<BR>&nbsp;&nbsp;<a href="FUNCREF.HTM#ramp">VI_ramp</a>( I1, 1000, 0, 50 ); /* an overflow will occur here! */
<BR>&nbsp;&nbsp;V_setIntErrorHandling( ierrIgnore );
<BR>&nbsp;&nbsp;<a href="FUNCREF.HTM#mulC">VI_mulC</a>( I2, I1, 1000, 5 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;/* here, even a whole series of overflows will occur; they are all ignored. */
<BR>&nbsp;&nbsp;....
<BR>}</font>


<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap5_3"></a>
<H2>5.3 Floating-Point Errors</H2>
<P><a name="chap5_3_1"></a>
<H2>5.3.1 C/C++ specific</H2>
In order to understand the details of the floating-point error handling outlined in the following sections, you may wish to refer to the description of the functions <I>_matherr</I> and <I>signal</I> in the documentation of your C++ compiler.
<BR>(Borland C++ only: prior to the version 4.0, instead of <I>_matherr</I>() the function <I>matherr</I>() &#150; without the leading underbar &#150; was used, see below).<BR>
Keep in mind that <I>_matherr</I> and <I>_matherrl</I> are the user-definable focal points for the handling of all software-detected errors, whereas <I>signal</I> is used to install a handler for hardware-detected errors (which should better be avoided in the first place). Within the <I>VectorLib</I> functions, <I>_matherr</I> is used for the error handling in the <I>VF_,&nbsp; VCF_,&nbsp; VD_</I>, and <I>VCD_</I> versions. <I>_matherrl</I> is used in the <I>VE_</I> and <I>VCE_</I> versions (Borland C++ only, as Visual C++ does not support 80-bit real numbers).
<P>If the function in which an error occurs has one real-valued argument, only the parameter e-&gt;x is defined in calling <I>_matherr</I> and e-&gt;y is left undefined. Only if there are two arguments (like in <I><a href="FUNCREF.HTM#atan2">VF_atan2</a></I> or in <I><a href="FUNCREF.HTM#cotrpi">VF_cotrpi</a></I>),
both e-&gt;x and e-&gt;y are needed to hold these arguments. For complex arguments, the real part (or the Mag part for polar coordinates) is stored in e-&gt;x and the imaginary part (or the Arg part) in e-&gt;y.
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap5_3_2"></a>
<H2>5.3.2 Pascal/Delphi specific</H2>
The types of errors occurring in mathematical functions are described in detail <a href="#chap5_3_3">below</a>. How <I>OptiVec</I> handles each type of error is defined by a call to  <I><a href="FUNCREF.HTM#setFPErrorHandling">V_setFPErrorHandling</a></I>.  The possible options are set by the <I>fperrXXX</I> constants described with <I><a href="FUNCREF.HTM#setFPErrorHandling">V_setFPErrorHandling</a></I>. When calling <I>V_setFPErrorHandling</I>, combine these constants by the OR operator. Note that this influences only the way errors are handled within <I>OptiVec</I> functions. It does not affect the way how the standard Borland Pascal/Delphi functions handle errors.
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap5_3_3"></a>
<H2>5.3.3 Error Types (Both C/C++ and Pascal/Delphi)</H2>
For each <I>VectorLib</I> function, the types of errors that are detected and handled are described in the <a href="FUNCREF.HTM#chap8">Alphabetical Reference</a>. All functions derived from ANSI C or Pascal math functions (those whose declarations are to be found in &lt;V?math.h&gt; or the units V?math) contain a fully-fledged mathematical error handling. In addition to the error handling &quot;by element&quot;, their return value shows if all elements have been processed error-free (return value FALSE or 0) or if an error occurred and was handled (return value TRUE or different from 0).
<P>In the following description of all floating-point error types, we denote by &quot;HUGE_VAL&quot; the largest number possible in the respective data type. Similarly, &quot;TINY_VAL&quot; is the smallest denormal number representable in the
respective data type; this is not the same as &quot;MIN_VAL&quot;, which is the smallest full-accuracy number of the respective data type.
<UL>
<LI>DOMAIN errors most often lead to the result NAN (&quot;not-a-number&quot;). Even if nothing happens within the function itself that detects a DOMAIN error, an uncontrolled program crash may result if subsequent operations are performed on the vector element set to NAN. 
<BR><U>For C/C++</U>, we therefore recommend to modify <I>_matherr</I> and <I>_matherrl</I> in such a way that the program is aborted if a DOMAIN error occurs (for an example, see below; alternatively, the UNIX style may be adopted; see the file MATHERR.C supplied with the your C/C++ compiler). Changing the return value of <I>_matherr</I> is another possiblity, but the better way very clearly is to avoid any DOMAIN errors by performing appropriate checks before calling functions like <I><a href="FUNCREF.HTM#sqrt">VF_sqrt</a>,&nbsp; <a href="FUNCREF.HTM#log">VF_log</a>,&nbsp; <a href="FUNCREF.HTM#atan2">VF_atan2</a></I> etc.
<BR><U>For Pascal/Delphi</U>, we recommend not to change the default setting of <a href="FUNCREF.HTM#setFPErrorHandling">V_FPErrorHandlingMode</a> or to include &quot;fperrAbortDOMAIN&quot; in any changes.
<BR>Note: the pseudo-numbers INF and NAN are not allowed as input for any functions of <I>OptiVec</I>. They are not tested for; their presence will normally result in a hardware interrupt.
<LI>SING errors are treated like an extreme case of OVERFLOW (see below). In most cases, they arise from an implicit division by zero or from taking the logarithm of zero. The proposed result is never NAN, but always a &quot;number&quot;, in most cases &#177;HUGE_VAL. Although it is recommended also in the case of SING errors to abort the program and take the necessary measures to avoid them, you may choose to continue program execution.
<LI>OVERFLOW errors are the most abundant form of floating-point errors. They are always handled by proposing +HUGE_VAL or -HUGE_VAL as the result. Within many user algorithms, OVERFLOW errors may occur for intermediate results; if subsequent steps perform operations like taking the inverse, the final result may be acceptable despite the error. Therefore, we recommend to accept the return-value proposal and not to abort the program.
<BR><U>C/C++ only:</U> In principle, you may decide not to accept the return-value proposal of <I>_matherr</I>, but to substitute another one. However, for several reasons you are discouraged from doing that: the correct sign of the result is
set by the calling (&quot;complaining&quot;) function in many cases only after returning from <I>_matherr</I>; the x-value passed to <I>_matherr</I> (which should be inspected before the return value is modified) may either be X<sub>i</sub>
or (as in some of the expanded complex math functions of the <I>VCEx_...</I> family) the intermediate result x' = Ax + B. Note, furthermore, that all x-values are passed to <I>_matherr</I> as double-precision floating-point numbers, also in the case of integer input numbers (like in <I><a href="FUNCREF.HTM#tanrpi">VF_tanrpi</a></I>, where P<sub>i</sub> and q are passed as x and y to <I>_matherr</I>).
<LI>TLOSS (&quot;total loss of precision&quot;) errors are detected only if a more serious error might occur in the respective function. For example, the sine function takes on values between -1 and +1 for all arguments. So, in case of an argument too big for the sine function to be evaluated with any accuracy, the result may nevertheless be &quot;tacitly&quot; set to 0.0 and no call to the <I>OptiVec</I> error handler is generated (whereas Borland C++ chooses NAN, &quot;not a number&quot;, as the result, which is certainly even less correct than arbitrarily choosing 0.0).
<BR>On the other hand, the cosecant, i.e. the inverse of the sine, is not defined for arguments of integer multiples of <font face="symbol">p</font>. Therefore, a more serious error (in this case a SING or an OVERFLOW error) might be hidden under the TLOSS for very big arguments. This possibility is taken into account by calling the error handler, although the proposed result is again set to 0.0 (which is the mean of the two extremes +HUGE_VAL and -HUGE_VAL). Generally, the default result in the case of a TLOSS error is the mean of the results for arguments of +0.0 and -0.0.
<LI>UNDERFLOW errors are never detected; underflowing results are always &quot;tacitly&quot; set to denormal numbers or finally to 0.0 by the floating-point processor itself. Indeed, you may very rarely wish to do something else in this case.
<LI>As in all non-vectorized math functions of the Borland compilers and Visual C++, PLOSS (&quot;partial loss of precision&quot;) errors are never detected and precision problems simply ignored.
</UL>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap5_3_4"></a>
<h3>5.3.4 Borland C++ only:
<BR>Differences between Borland C++ 4.0 and earlier versions</h3>
Borland C++ uses the function <I>_matherr</I> in the way described above only from version 4.0 on. Earlier versions employ the function <I>matherr</I> (without the leading underbar in the function name). In order to be usable both with the new and the old versions, <I>VectorLib</I> primarily calls <I>matherr</I> as for the older versions. The include-file &lt;VecLib.h&gt;
provides a macro NEWMATHERR for the redirection of these calls to the new <I>_matherr</I>(). This macro should appear somewhere in the module containing the <I>main()</I> or <I>WinMain()</I> procedure, after the header:<font face="courier new">
<BR>#include &lt;VecLib.h&gt;
<BR>#include ...
<BR>NEWMATHERR
<BR>......
<BR>main()
<BR>{ ... }</font>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap5_4"></a>
<H2>5.4 The Treatment of Denormal Numbers</H2>
&quot;Denormal&quot; are very small numbers between zero and the smallest full-accuracy number available in the respective data type. You may understand the underlying principle from a simplified example: 1.175494E-38 is the smallest &quot;normal&quot; float, with 7-digit accuracy. What about 1/1024 of this value? This can only be represented as
0.001145E-38, which is accurate to only four digits, since the first three digits are needed to hold zeros. Thus, denormal numbers provide a smooth transition between the smallest representable normal numbers and zero.
<P>In general, they may be treated just as ordinary numbers. In some instances, however, like taking the inverse, overflow errors may occur. In these cases, the somewhat academic distinction between SING and OVERFLOW errors is dropped
and a SING error signalled (as if it was a division by exactly 0).
<P>On the other hand, for functions like the logarithms, very small input numbers may give perfectly reasonable results, although the exact number 0.0 is an illegal argument, leading to a SING error. Here, the possible loss of precision is neglected and denormals are considered valid arguments. (This treatment is quite different from that chosen for the math functions of
most compilers, where denormal arguments lead to SING errors also in these cases, which seems less appropriate to us.)
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap5_5"></a>
<H2>5.5 Advanced Error Handling: Writing Messages into a File</H2>
Quite generally, the libraries shipped with compilers do not offer the programmer much control over the way error messages are printed. While this is fine in most instances, there may be situations in which you might, for example, wish the error messages not to be printed to the screen, but rather into a file, so that you could check later what has gone wrong. An additional motivation could come from the fact that, for any error occurring in a Windows program, a message box is displayed and program execution interrupted until you acknowledge having taken notice of the error.
<P>You might wish to circumvent this. To this end, <I>OptiVec</I> provides the function <I><a href="FUNCREF.HTM#setErrorEventFile">V_setErrorEventFile</a></I>. This function needs as arguments the desired
name of your event file and a switch named ScreenAndFile which decides if the error message is printed only into the file, or additionally to the screen as well.
<BR>Note that this redirection of error messages is valid only for errors occurring in <I>OptiVec</I> routines. If you wish to do so, however, there is a way in C/C++ to extend the redirection also to the &quot;non-<I>OptiVec</I>&quot; functions: you may modify <I>_matherr</I> and <I>_matherrl</I> such that the statement 
<BR><font face="courier new"> return 0;</font>
<BR>(which signals an unresolved error) is replaced by the sequence
<BR><font face="courier new"><a href="FUNCREF.HTM#noteError">V_noteError</a>( e-&gt;name, e-&gt;type ); return 1;</font>
<BR>Thereby the task of printing the error message for unresolved errors is passed to the <I>OptiVec</I> function <I><a href="FUNCREF.HTM#noteError">V_noteError</a></I>. Keep in mind that it is the return value of <I>_matherr</I> which decides if an error message is printed by the default error handler of your compiler. Thus, after the call to <I>V_noteError</I>, the printing of the default error messages is by-passed by returning &quot;1&quot;. (Also, do not forget that <I>OptiVec</I> uses <B>your</B> <I>_matherr</I> routine to determine which errors you accept and which not!)
<BR>
<BR>For example, your <I>_matherr</I> function (<I>matherr</I> &#150; without the leading underbar &#150; for Borland C++ 3.0 and 3.1) might look like the following one:<font face="courier new">
<BR>#include &lt;math.h&gt;
<BR>int _matherr( struct exception *e) /* &quot;_exception&quot; for MSVC */
<BR>{
<BR>&nbsp;&nbsp;if( (e-&gt;type == UNDERFLOW) || (e-&gt;type == TLOSS) ) ; /* ignore */
<BR>&nbsp;&nbsp;else /* all other errors deserve at least notice */
<BR>&nbsp;&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<a href="FUNCREF.HTM#noteError">V_noteError</a>( e-&gt;name, e-&gt;type );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (e-&gt;type == DOMAIN) exit(1); /* really fatal */
<BR>&nbsp;&nbsp;}
<BR>&nbsp;&nbsp;return 1;
<BR>}</font>
<BR>(Of course, if you decide to change <I>_matherr</I>, do not forget to change <I>_matherrl</I> in the same way, if you are using Borland C++!).
<P><U>Both C/C++ and Pascal/Delphi:</U> The default printing of error messages on the screen alone is restored by <I><a href="FUNCREF.HTM#closeErrorEventFile">V_closeErrorEventFile</a></I>.
<P>A way to keep track also of those errors which do not lead to messages is opened by the return values of mathematical <I>VectorLib</I> functions. Any of the &quot;silent&quot; TLOSS along with the more serious DOMAIN, SING and OVERFLOW errors will lead to a TRUE (non-zero) return value. You may wish to check for a clean result after a group of functions, like in the following example:<font face="courier new">
<BR>unsigned ErrFlag;
<BR>...
<BR>/* part Trig1 */
<BR>ErrFlag=0; /* reset the flag */
<BR>ErrFlag |= <a href="FUNCREF.HTM#sin">VF_sin</a>( Y1, X1, sz );
<BR>ErrFlag |= <a href="FUNCREF.HTM#cos">VF_cos</a>( Y2, X1, sz );
<BR>ErrFlag |= <a href="FUNCREF.HTM#atan2">VF_atan2</a>( Z1, Y1, Y2, sz );
<BR>if( ErrFlag ) <a href="FUNCREF.HTM#printErrorMsg">V_printErrorMsg</a>( &quot;Errors occurred in part Trig1 ! &quot;);
<BR>...</font>
<BR>As indicated in the example, it is better to use the |= operator (Pascal/Delphi: &quot;ErrFlag := ErrFlag <B>or</B>&quot;) instead of += (since, in rare cases, all return values might add up to 65536, which is stored as 0 due to an overflow of the integer variable). Even if you chose addition of the individual return values, the number of occurred errors would not be obtainable from the result; in case of an error, any non-specified non-zero number is returned.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap5_6"></a>
<H2>5.6 OptiVec Error Messages</H2>
Just as with any C/C++ or Pascal program, errors occurring within mathematical functions lead to the appropriate error messages. See <a href="#chap5_3_3">paragraph 5.3.3</a> for details.
<BR>Apart from math errors, there are some run-time errors specific to <I>OptiVec</I> routines. These errors lead to the messages noted below. The name of the function where the error occurred is not always exactly the name you wrote
in your program. Instead of the prefix <I>VI_</I>, the message will read <I>VLI_</I> or <I>VSI_</I>, depending on the memory model used. Similarly, instead of <I>VU_</I>, you will find <I>VUL_</I> or <I>VUS_</I>.
<BR><I><a href="FUNCREF.HTM#FFT">VFs_FFT</a></I> or <I><a href="FUNCREF.HTM#FFT">VFl_FFT</a></I> will be substituted for <I><a href="FUNCREF.HTM#FFT">VF_FFT</a></I>, again depending on the memory model. The reason for this behavior is that many functions share code and even names.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(00) OptiVec/CMATH not installed correctly<BR>(must use INSTALL.EXE !)</b></font></td></tr></table>
</td></tr></table>
Shareware version only: Either you are running a program containing <I>OptiVec</I> functions on a different computer than the one on which you installed <I>OptiVec</I>. The distribution of applications containing <I>OptiVec</I> functions is possible only with the Registered version.
<BR>Or you attempted to install <I>OptiVec</I> by unzipping the package by hand, without using INSTALL.EXE. This is not possible, as INSTALL.EXE also starts the clock for the trial period. With Windows 2000 / XP, you have to run InitOVBC.EXE (Borland C++ version) or InitOVVC.EXE (MSVC version) instead of INSTALL.EXE.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(0) Trial period for OptiVec/CMATH has expired!</b></font></td></tr></table>
</td></tr></table>
Shareware version only: Consider ordering the registered version!

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(1) Not enough memory. </b></font></td></tr></table>
</td></tr></table>
You are trying to allocate memory, but there is not enough left. This error occurs mostly in connection with &quot;forgotten&quot; vectors that are allocated but never freed. Try these solutions:
<BR>* Look out for vectors that might be no longer needed and free them as soon as possible. Be sure that any vectors allocated in subroutines are freed before leaving the subroutine.
<BR>* Are you still working with 16-bit models? If you need to work with large amounts of data, the memory model FLAT should be used, working with Win32, WindowsNT, or Windows95/98.
<BR>* Store data intermediately on disk, using <I><a href="FUNCREF.HTM#store">VF_store</a></I>, and retrieve them using <I><a href="FUNCREF.HTM#recall">VF_recall</a></I>, when needed. This method is slow and should be used only if really unavoidable.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(2) Vector &gt; 64 kB not possible (16-bit).<BR>
(2) Vector &gt; 4 GB not possible (32-bit).</b></font></td></tr></table></td></tr></table>
* Either you are trying to allocate a vector whose size exceeds the maximum of 4 GB (32-bit) or 64 kB (16-bit except HUGE). 
<BR>* Or you are in the HUGE model and attempt to process a huge vector in a function where the size is limited to 64 kB even in this model. This might happen, e.g., if the table is too large in one of the interpolation routines. In this case, you must either use the model FLAT or split up your problem into smaller vectors.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(3) Vectors/matrices must not be identical.</b></font></td></tr></table>
</td></tr></table>
In some functions where more than one input vector (or matrix) is used to calculate more than one output vector (or matrix), attention has to be paid, which output data may or may not overwrite which input data. See the specification of the function where the error occurred.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(4) Cannot use requested format (too many entries per line).</b></font></td></tr></table>
</td></tr></table>
This error occurs with the printing functions. The parameter <I>nperline</I> was chosen too large. The function automatically selects the maximum <I>nperline</I> possible and continues execution, but you should nevertheless consider adapting your program.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(5) X-values of table must be distinct.</b></font></td></tr></table>
</td></tr></table>
The routines performing interpolations need the tables to be ordered according to their x-values. Each x-value may occur only once, as it is impossible for one and the same x-value to belong to different y-values.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(6) Not possible with fewer than n elements. </b></font></td></tr></table>
</td></tr></table>
Some functions require a minimum size of n elements of the vector processed.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(7) Not possible with more than n elements. </b></font></td></tr></table>
</td></tr></table>
Some functions are limited to a maximum size of n elements. This is true, for example, for <I><a href="FUNCREF.HTM#polyinterpol">VF_polyinterpol</a></I>, where only up to 10 table elements may be used for the each interpolation.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(8) Size must be an integer power of 2. </b></font></td></tr></table>
</td></tr></table>
For all functions using – explicitly or implicitly – Fast Fourier Transform methods, the vector size has to be an integer power of 2. Enlarge or truncate your vector(s) to meet that condition.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(9) Invalid parameter(s).</b></font></td></tr></table>
</td></tr></table>
In some functions, certain combinations of input parameters are illegal. For example, it is not possible to perform a 9-point interpolation on only 5 data points.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(10) Cannot scale symbols by more than a factor of 50.</b></font></td></tr></table>
</td></tr></table>
(Windows only.) The symbols used in <I>VectorLib</I> plotting functions cannot be magnified by more than a factor of 50 (which means already filling the screen with a single symbol). Program execution is continued with a value of 50.0.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(11) Cannot use line thicker than 500 pixels.</b></font></td></tr></table>
</td></tr></table>
(Windows only.) The lines used in <I>VectorLib</I> plotting functions cannot be thicker than 500 pixels (which is already nonsense). Program execution is continued with a value of 500.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(12) Cannot free non-existent vector.</b></font></td></tr></table>
</td></tr></table>
You called <I><a href="FUNCREF.HTM#free">V_free</a></I> or <I><a href="FUNCREF.HTM#nfree">V_nfree</a></I> for a vector that has no memory allocated. Program execution is continued without freeing anything.
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(21) Invalid dimension(s).</b></font></td></tr></table>
</td></tr></table>
In one way or the other, the dimensions of input or output matrices do not meet the requirements.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(22) Matrix is singular.</b></font></td></tr></table>
</td></tr></table>
In a function requiring regular input matrices, a singular matrix was encountered. Consider alternative functions, designed to handle (nearly) singular matrices.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(23) No convergence achieved.</b></font></td></tr></table>
</td></tr></table>
Some iterative matrix methods may, in very rare cases, fail to achieve convergence.

<P>&nbsp;<P><table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>(24) Only the first n elements of each row can be printed.</b></font></td></tr></table>
</td></tr></table>
This error occurs with the matrix printing functions. The number of columns is too large for the available linewidth. The function automatically selects the maximum number of columns to be displayed and truncates the rows as needed.

<P><a name="chap6"></a>
<H1><HR width="100%">6. Trouble-Shooting </H1>
<P><a name="chap6_1"></a>
<H2>6.1 General Problems</H2>
In case of problems, please check first if <I>OptiVec</I> is correctly installed (see <a href="#chap1_4">chapter 1.4</a>). If this is the case, carefully check the following points whose violation would inevitably lead to failure.
<UL>
<LI>The choice of the <I>OptiVec</I> library must match your selection of memory model, processor, and environment. With Borland C++, you are not going to have much fun with the library VCL3.LIB under Windows3.x (where you need VCL3W.LIB), and the libraries designed for Borland C++ will not work with Visual C++ or any other compiler. Similarly, OVVCSD.LIB, designed for single-thread debug in Visual C++, will not work in any multi-thread or any &quot;release&quot; link.
<LI>You must not use vectors with a size of 0. All functions tacitly assume that the vectors have at least one element and do not waste your computer time testing for that.
<LI>You must not use vectors that are only declared, but have no allocated memory (see the description of <I><a href="FUNCREF.HTM#vector">VF_vector</a></I>). If you did not switch off warnings, you may be warned also by the compiler not to do that (&quot;possible use of xxx before definition&quot;).
<LI>Constant parameters should not exceed 1.E32 for floats, 1.E150 for doubles, or 1.E2000 for long doubles. Normally, these ranges should suffice for any application...
<LI><U>16-bit Borland C++ only:</U> Do not forget to write the line
<BR>NEWMATHERR
<BR>after the header into the module containing <I>main(),&nbsp; WinMain()</I>, or <I>OwlMain()</I>, in order to maintain compatibility both with older and later versions of Borland C++ (see <a href="#chap5_3_1">chapter 5.3.1</a>).
</UL>
Although <I>OptiVec</I> has been tested thoroughly, there is, of course, always the possibility that a problem might have escaped our attention. Should you feel you discovered a &quot;bug&quot; in <I>OptiVec</I>, please try to specify the situation causing the problem as exactly as possible and let us know at <A HREF="mailto:support@optivec.com">support@optivec.com</A>!
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap6_2"></a>
<H2>6.2 Problems with Windows3.x?</H2>
Programming for 16-bit Windows is much more involved than programming for either DOS or 32-bit Windows. While DOS gives the programmer almost complete control over both the main processor and the coprocessor, Windows demands much of this control for itself. This introduces problems you should be aware of. They are not at all specific to <I>OptiVec</I>. However, since they seem not to be very widely known, here is a collection of some of them. Up to now, these problems have not been observed with the memory model FLAT used with Win32 (Microsoft's 32-bit extension of Windows 3.1), Windows NT or Windows95/98/2000.
<UL><LI>The background routines controlling intermediate results do not only work at the expense of your time, they may also at some point decide to load a NULL selector into the segment registers FS and GS. If you happen to use these registers (somehow, they were meant by Intel to be used!), Windows' answer on your next operation will be the familiar &quot;General Protection Fault (Error 13)&quot;. Therefore, the Windows versions of <I>OptiVec</I> do not use FS and GS at all.
<LI>If a floating-point multiplication or division happens to result in a so-called &quot;denormal number&quot; (see <a href="#chap5_4">chapter 5.4</a>), Windows at first accepts this result. The next time you use this denormal result, however, Windows decides that it had better been zero. Checking for zero by a comparison like
<BR>if(x != 0.0)...
<BR>yields the correct answer that x it is not zero, but, after (!) this check, Windows makes x exactly zero, if it is loaded onto the number stack. This leads to hard-to-find errors. If you inspect <I>OptiVec</I> routines with a debugger, you may at some points encounter strange, seemingly ineffecient code being used for comparisons. This is a fix for the described problem which costs time, but saves you from Windows- induced DIVIDE ERROR crashes.
<LI>Related to the last problem is another &quot;feature&quot; of Windows3.x: after the comparison of two floats or two doubles, one of which is denormal, -NAN (&quot;minus not-a-number&quot;) may appear on the number stack. Some time later, this leads to a &quot;Floating-point invalid&quot; or a &quot;Stack Overflow&quot; error – another means of killing your application. If you encounter -NAN on the number stack when debugging your programs (with or without <I>VectorLib</I> used), you should find out which comparison(s) caused the problem and add the line
<BR><font face="courier new"> asm ffree ST(0);</font>
<BR>after this or these comparisons.
</UL>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap6_3"></a>
<H2>6.3 Problems with 32-bit Windows?</H2>
Until now, no problems of the type described above for 16-bit Windows have occurred. There has, however, been one nice surprise with the switch from Windows95 to Windows98: The Windows API function <I>MessageBox</I> now empties the number stack of the processor's FP unit &#150; apparently for no justifiable reason. To be honest, it has taken us until version 3 of <I>OptiVec</I> to identify this Windows feature as the source of some spurious program crashes after math errors. (The constants A, B, C were suddenly missing in functions like <I>VFx_exp</I> after an overflow error.) Now, care is taken to save the number stack before all calls to <I>MessageBox</I> and restore it afterwards.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap6_4"></a>
<H2>6.4 Problems with Borland's 16-bit Linker?</H2>
When working with large programs and libraries, older versions of TLINK sometimes run into problems. You may get error messages like &quot;Linker stack overflow&quot;, &quot;Out of memory&quot;, &quot;Table limit exceeded&quot;, &quot;Extended dictionaries ignored&quot;, or &quot;Unresolved external xxx referenced from module yyy&quot;.
<BR>Try to give the linker as much memory as possible by closing applications, removing drivers etc. If that does not help, re-arrange your project list. Curiously enough, that solves the problem sometimes.
<BR>In the case of &quot;Unresolved external&quot; linker errors, there is only one way (if the error is not caused by wrong spelling). First you have to use TLIB in order to get a listing of the respective library (see the description of TLIB !). Screening the .LST file thus obtained with a text editor, you find the module containing the symbol which the linker was unable to locate. Using again TLIB, you have to extract this module from the library and add the resulting .OBJ file to your project list.
<P>If you are still working with Borland (Turbo) C++ 3.x, you cannot simultaneously include VC??.LIB and MC??.LIB, as the linker is not able to handle these large libraries. As very few people are still using BC 3, we have discontinued full support for that compiler and do no longer offer the special BC 3 version <I>OptiVec</I>, previously fixing that problem by splitting the libraries up into many smaller ones. You still can extract the needed modules from the MC??.LIB libraries yourself, however, and include them as .OBJ nodes into your project.
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap7"></a>
<H1><HR width="100%">7. The Include-Files and Units of <I>OptiVec</I></H1>
All <I>OptiVec</I> C/C++ include-files have the same names as the corresponding Pascal/Delphi units. Naturally, the extension is different: &quot;.H&quot; for the C/C++ include-files, &quot;.DCU&quot; for Delphi units, and &quot;.TPU&quot; or &quot;TPP&quot; for Pascal units. Below, only the names are listed, without the extension.

<P><U>C/C++ only:</U> Declare the use of <I>OptiVec</I> functions with <font face="courier new">#include</font> statements. If you are using MFC (Microsoft Foundation Classes) or Borland's OWL (ObjectWindows Library), the MFC or OWL include-files have to be #included before (!) the <I>OptiVec</I> include-files.

<P><U>Pascal/Delphi only:</U> Declare the use of <I>OptiVec</I> functions with the <font face="courier new">uses</font> clause.

<BR>&nbsp;<table border width="100%">
<tr valign="top"><td width="40%">Include-file (add suffix .H) or unit</td><td>Contents</td></tr>
<tr valign="top"><td><font face="courier new">VecLib</font></td><td>Basic definitions of the data types along with the functions common to all data types (prefix <I>V_</I>) except for the graphics initialization functions. </td></tr>
<tr valign="top"><td><font face="courier new">VFstd, VDstd, VEstd</font></td><td>Floating-point &quot;standard operations:&quot; generation and initialization of vectors, index-oriented manipulations, data-type interconversions, statistics, analysis, geometrical vector arithmetics, Fourier-Transform related functions, I/O operations. </td></tr>
<tr valign="top"><td><font face="courier new">VCFstd, VCDstd, VCEstd,<BR>VPFstd, VPDstd, VPEstd</font></td><td>Standard operations for cartesian and polar complex vectors</td></tr>
<tr valign="top"><td><font face="courier new">VIstd, VBIstd, VSIstd, VLIstd, VQIstd</font></td><td>Standard operations for signed integer vectors</td></tr>
<tr valign="top"><td><font face="courier new">VUstd, VUBstd, VUSstd, VULstd, VUIstd</font></td><td>Standard operations for unsigned integer vectors (<font face="courier new">VUIstd</font> only for C/C++)</td></tr>
<tr valign="top"><td><font face="courier new">VFmath, VDmath, VEmath</font></td><td>Algebraic, arithmetical and mathematical functions for floating-point vectors</td></tr>
<tr valign="top"><td><font face="courier new">VCFmath, VCDmath, VCEmath,<BR>VPFmath, VPDmath, VPEmath</font></td><td>Arithmetical and mathematical functions for complex vectors</td></tr>
<tr valign="top"><td><font face="courier new">VImath, VBImath, VSImath, VLImath, VQImath</font></td><td>Arithmetical and mathematical functions for signed integer vectors</td></tr>
<tr valign="top"><td><font face="courier new">VUmath, VUBmath, VUSmath, VULmath, VUImath</font></td><td>Arithmetical and mathematical functions for unsigned integer vectors (<font face="courier new">VUImath</font> only for C/C++)</td></tr>
<tr valign="top"><td><font face="courier new">Vgraph</font></td><td>Graphics functions for all data types</td></tr>
<tr valign="top"><td><font face="courier new">VFNLFIT, VDNLFIT, VENLFIT</font></td><td>Non-linear fitting functions (Pascal/Delphi only; in C/C++, they are in <font face="courier new">M?std</font>)</td></tr>
<tr valign="top"><td><font face="courier new">VFMNLFIT, VDMNLFIT, VEMNLFIT</font></td><td>Non-linear fitting functions for multiple data sets (Pascal/Delphi only; in C/C++, they are in <font face="courier new">M?std</font>)</td></tr>
<tr valign="top"><td><font face="courier new">MFstd, MDstd, MEstd</font></td><td>Matrix operations for real-valued matrices</td></tr>
<tr valign="top"><td><font face="courier new">MCFstd, MCDstd, MCEstd</font></td><td>Matrix operations for cartesian complex matrices</td></tr>
<tr valign="top"><td><font face="courier new">Mgraph</font></td><td>Matrix graphics functions for all data types</td></tr>
<tr valign="top"><td><font face="courier new">MFNLFIT, MDNLFIT, MENLFIT</font></td><td>Non-linear fitting functions for Z = f(X, Y) data (Pascal/Delphi only; in C/C++, they are in <font face="courier new">M?std</font>)</td></tr>
<tr valign="top"><td><font face="courier new">MFMNLFIT, MDMNLFIT, MEMNLFIT</font></td><td>Non-linear fitting functions for multiple Z = f(X, Y) data sets (Pascal/Delphi only; in C/C++, they are in <font face="courier new">M?std</font>)</td></tr>
<tr valign="top"><td><font face="courier new">NEWCPLX</font></td><td>complex class library <I>CMATH</I>; C++ only</td></tr>
<tr valign="top"><td><font face="courier new">CMATH</font></td><td>complex library <I>CMATH</I> for Pascal/Delphi and plain C</td></tr>
<tr valign="top"><td><font face="courier new">CFMATH, CDMATH, CEMATH</font></td><td>C/C++ only: type-specific parts of <I>CMATH</I>.</td></tr>
<tr valign="top"><td><font face="courier new">XMATH</font></td><td>A few non-vectorized math functions needed internally by other <I>OptiVec</I> functions; they are publically accessible (see <a href="FUNCREF.HTM#chap9">chapter 9</a>). C/C++: declares also the sine, cosec, and tangent tables for <a href="FUNCREF.HTM#sinrpi">VF_sinrpi2</a> etc.</td></tr>
<tr valign="top"><td><font face="courier new">FSINTAB2, DSINTAB2, ESINTAB3,<BR>FSINTAB3, DSINTAB3, ESINTAB3</font></td><td>sine tables (Pascal/Delphi only; for C/C++, they are in <font face="courier new">XMATH</font>)</td></tr>
<tr valign="top"><td><font face="courier new">FCSCTAB2, DCSCTAB2, ECSCTAB3,<BR>FCSCTAB3, DCSCTAB3, ECSCTAB3</font></td><td>cosecant tables (Pascal/Delphi only; for C/C++, they are in <font face="courier new">XMATH</font>)</td></tr>
<tr valign="top"><td><font face="courier new">FTANTAB2, DTANTAB2, ETANTAB3,<BR>FTANTAB3, DTANTAB3, ETANTAB3</font></td><td>tangent tables (Pascal/Delphi only; for C/C++, they are in <font face="courier new">XMATH</font>)</td></tr>
<tr valign="top"><td><font face="courier new">VecObj</font></td><td>basic definitions for <I>VecObj</I>, the object-oriented interface for C++</td></tr>
<tr valign="top"><td><font face="courier new">fVecObj, dVecObj, eVecObj</font></td><td><I>VecObj</I> member functions for real-valued vector objects (C++ only)</td></tr>
<tr valign="top"><td><font face="courier new">cfVecObj, cdVecObj, ceVecObj<BR>pfVecObj, pdVecObj, peVecObj</font></td><td><I>VecObj</I> member functions for complex vector objects (C++ only)</td></tr>
<tr valign="top"><td><font face="courier new">iVecObj, biVecObj, siVecObj, liVecObj, qiVecObj</font></td><td><I>VecObj</I> member functions for signed-integer vector objects (C++ only)</td></tr>
<tr valign="top"><td><font face="courier new">uVecObj, ubVecObj, usVecObj, ulVecObj, uiVecObj</font></td><td><I>VecObj</I> member functions for unsigned-integer vector objects (C++ only)</td></tr>
<tr valign="top"><td><font face="courier new">OptiVec</font></td><td>includes the whole <I>OptiVec</I> package (C++ only)</td></tr>
<tr valign="top"><td><font face="courier new">VecAll</font></td><td>includes all <I>VectorLib</I> and CMATH functions  (C or C++ only)</td></tr>
<tr valign="top"><td><font face="courier new">MatAll</font></td><td>includes all <I>MatrixLib</I> functions  (C or C++ only)</td></tr>
</table>&nbsp;
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><H1><HR width="100%">E N D </H1>
Copyright for <I>OptiVec</I> software and documentation
<BR>&copy; 1996-2002 <I>OptiCode</I> &#150; Dr. Martin Sander Software Dev.
<BR>All rights reserved!
</body>
</html>