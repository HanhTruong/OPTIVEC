<html>
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<title>OptiVec: VectorLib Function Reference</title></head>
<body bgcolor="#ffffff" text="#000000" link="#0000ff" vlink="#0000ff" alink="#ff0000">
<TABLE CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >
<TR><TD><IMG SRC="optivec.gif" BORDER=0 WIDTH=260>&nbsp;
</TD><TD><h1><I><b><font size="+4">OptiVec</font></b></I><P>
Version 3</h1>
<BR><h2>for C/C++ and for Pascal/Delphi</h2>
</td></tr><tr><TD>
<I>OptiCode</I>
<BR>Dr. Martin Sander Software Development
<BR>Steinachstr. 9A
<BR>D-69198 Schriesheim
<BR>Germany
<BR><a href="http://www.optivec.com">http://www.optivec.com</a>
<BR>e-mail: <A HREF="mailto:support@optivec.com">support@optivec.com</A> or
<BR><A HREF="mailto:sales@optivec.com">sales@optivec.com</A>
</TD><TD><h1>Part I. B: Function Reference<BR>for <I>VectorLib</I></h1>
</TD></TR></TABLE>

<BR>A general description of <I>OptiVec</I> is given in <a href="HANDBOOK.HTM">HANDBOOK.HTM</a>.
<BR>For <I>MatrixLib</I> functions, see <a href="MATRIX.HTM">MATRIX.HTM</a>, for <I>CMATH</I> functions, see <a href="CMATH.HTM">CMATH.HTM</a>.

<BR><a href="HANDBOOK.HTM#chap1_2">Chapter 1.2</a> of HANDBOOK.HTM contains the licence terms for the Shareware version, <a href="HANDBOOK.HTM#chap1_3">Chapter 1.3</a> for the Registered version.

<P><a name="chap8"></a>
<H1><HR width="100%">8. Alphabetical Reference of Vector Functions</H1>

The functions are alphabetically ordered, with the prefixes being neglected for the ordering. The heading of each entry lists all the versions available for a specific function:
<P><a name="example"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_example</b></font></td><td width="33%"><font size="+1"><b>VD_example</b></font></td><td><font size="+1"><b>VE_example</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_example</b></font></td><td width="33%"><font size="+1"><b>VCD_example</b></font></td><td><font size="+1"><b>VCE_example</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Consider, e.g., the &quot;abs&quot; family of functions. It exists in vectorized versions for
<UL><LI>the three real-number data types float, double, and extended (long double) with the prefixes <I>VF_,&nbsp;&nbsp; VD_</I>, and <I>VE_</I>,
<LI>for the three cartesian complex-number data types (prefixes <I>VCF_,&nbsp;&nbsp; VCD_</I>, and <I>VCE_</I>),
<LI>for the three polar complex-number data types (prefixes <I>VPF_,&nbsp;&nbsp; VPD_</I>, and <I>VPE_</I>),
<LI>and for the signed integer data types int, byte, short int, long int, and quad (prefixes <I>VI_,&nbsp;&nbsp; VBI_,&nbsp;&nbsp; VSI_,&nbsp;&nbsp; VLI_</I>, and <I>VQI_</I>);
</UL>
unsigned numbers are, by their very definition, always positive, and it makes no sense to define the operation &quot;abs&quot; for them; consequently, the <I>VU_,&nbsp;&nbsp; VUB_,&nbsp;&nbsp; VUS_,&nbsp;&nbsp; VUL_</I>, and <I>VUI_</I> versions are missing.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td>In most cases, only the <I>VF_</I> version is described. All other versions are exactly analogous; one has only to replace the data types float and fVector by the appropriate ones and replace the VF... include file by the one belonging to the desired data type.</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td>Here, the syntax of the object-oriented interface is described</td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td>Similarly to the description of the C/C++ syntax, again only the <I>VF_</I> version is described. Replace the data types float and fVector by the appropriate ones and include the unit belonging to the desired data type into the &quot;uses&quot; clause.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><TD>Often, for the sake of simplicity, the brackets around vector
 element indices are left away. If not stated otherwise, all vector elements from the zero'th up to the last one (with the index size-1) are subjected to the respective operation described. Thus, a formula like
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yi = | Xi |
<BR>is to be understood as an abbreviation for
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y[i] = | X[i] |, i=0,...,size-1
<BR>or, written as a loop:
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for( i=0; i&lt;size; i++ ) Y[i] = fabs( X[i] );</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>All types of errors are listed which are detected and handled. The default result is given in each case.
<BR><u>C/C++ only:</u>
<BR>In case of any detected floating-point errors, <I>_matherr</I> or <I>_matherrl</I> are called (see <a href="HANDBOOK.HTM#chap5_3">chapter&nbsp;5.3</a>). Although we do not recommend that, the user may modify <I>_matherr</I> and <I>_matherrl</I> such as to specify other results than those suggested.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The return value of the respective function is mentioned here.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td>References to functions without a prefix &quot;V...&quot; refer to the documentation of your C/C++ or Pascal/Delphi compiler. References to chapters 1. to 7. refer to the file <a href="HANDBOOK.HTM">HANDBOOK.HTM</a>.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="abs"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_abs</b></font></td><td width="33%"><font size="+1"><b>VD_abs</b></font></td><td><font size="+1"><b>VE_abs</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_abs</b></font></td><td width="33%"><font size="+1"><b>VCD_abs</b></font></td><td><font size="+1"><b>VCE_abs</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_abs</b></font></td><td width="33%"><font size="+1"><b>VPD_abs</b></font></td><td><font size="+1"><b>VPE_abs</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_abs</b></font></td><td width="20%"><font size="+1"><b>VBI_abs</b></font></td><td width="20%"><font size="+1"><b>VSI_abs</b></font></td><td width="20%"><font size="+1"><b>VLI_abs</b></font></td><td><font size="+1"><b>VQI_abs</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Absolute value</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_abs( fVector Y, fVector X, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_,&nbsp;&nbsp; VBI_,&nbsp;&nbsp; VSI_,&nbsp;&nbsp; VI_,&nbsp;&nbsp; VLI_,&nbsp;&nbsp; VQI_</I>)
<BR><font face="courier new">int VCF_abs( fVector Y, cfVector X, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VPF_,&nbsp;&nbsp; VPD_,&nbsp;&nbsp; VPE_</I>)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::abs( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::abs( const vector&lt;complex&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_abs( Y, X:fVector; size:UInt ): IntBool;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_,&nbsp;&nbsp; VSI_,&nbsp;&nbsp; VI_,&nbsp;&nbsp; VLI_,&nbsp;&nbsp; VQI_</I>)
<BR><font face="courier new">function VCF_abs( Y:fVector; X:cfVector; size:UInt ): IntBool;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VPF_,&nbsp;&nbsp; VPD_,&nbsp;&nbsp; VPE_</I>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Real and integer versions: Y<sub>i</sub> = | X<sub>i</sub> |
<BR><I>VBI_,&nbsp;&nbsp; VSI_,&nbsp;&nbsp; VI_</I>, and <I>VLI_</I> versions only: due to the implicit modulo-2<sup>n</sup> arithmetics, the absolute value of the most negative numbers possible ( -32768 for short/SmallInt, -2147483648 for long/LongInt) is stored as the same negative (!) number (-32768 or -2147483648, resp.).<BR>Complex versions: Y<sub>i</sub> = sqrt( X<sub>i</sub>.Re<sup>2</sup> + X<sub>i</sub>.Im<sup>2</sup> )
<BR>For the complex versions, note that the result is real-valued. For the cartesian complex functions (<I>VC?_abs</I>), the same result may also be obtained slightly
<BR>faster, but without error handling, using <I><a href="#CtoAbs">VF_CtoAbs</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Real and integer versions: no errors should occur;
<BR>Complex versions: OVERFLOW errors lead to the default result +HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>Floating-point versions: FALSE (0), if error-free, otherwise TRUE (!= 0).
<BR>The integer versions have no return value.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#neg">VF_neg</a>,&nbsp;&nbsp; <a href="#conj">VCF_conj</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="absmax"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_absmax</b></font></td><td width="33%"><font size="+1"><b>VD_absmax</b></font></td><td><font size="+1"><b>VE_absmax</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_absmax</b></font></td><td width="33%"><font size="+1"><b>VCD_absmax</b></font></td><td><font size="+1"><b>VCE_absmax</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_absmax</b></font></td><td width="33%"><font size="+1"><b>VPD_absmax</b></font></td><td><font size="+1"><b>VPE_absmax</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Largest absolute value within one vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_absmax( fVector X, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
<BR><font face="courier new">float VCF_absmax( cfVector X, ui size);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VPF_,&nbsp;&nbsp; VPD_,&nbsp;&nbsp; VPE_</I>)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::absmax();
<BR>T vector&lt;complex&lt;T&gt;&gt;::absmax();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_absmax( X:fVector; size:UInt ): Single;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
<BR><font face="courier new">function VCF_absmax( X:cfVector; size:UInt ): Single;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VPF_,&nbsp;&nbsp; VPD_,&nbsp;&nbsp; VPE_</I>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The absolute values of all elements of a vector are compared and the largest returned.
<BR>For complex numbers, the magnitudes of the elements are compared and the largest magnitude is returned. If you need the complex number itself rather than only its magnitude, use <I><a href="#cabsmax">VCF_cabsmax</a></I>. In order to find the greatest real and imaginary parts of cartesian complex vectors separately, call <I><a href="#absmaxReIm">VCF_absmaxReIm</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>maximum absolute value encountered.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#max">VF_max</a>,&nbsp;&nbsp; <a href="#absmin">VF_absmin</a>,&nbsp;&nbsp; <a href="#runmax">VF_runmax</a>,&nbsp;&nbsp; <a href="#absmaxind">VF_absmaxind</a>,&nbsp;&nbsp; <a href="#absmaxReIm">VCF_absmaxReIm</a>,&nbsp;&nbsp; <a href="#cabsmax">VCF_cabsmax</a>,&nbsp;&nbsp; <a href="#sabsmax">VCF_sabsmax</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="absmaxind"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_absmaxind</b></font></td><td width="33%"><font size="+1"><b>VD_absmaxind</b></font></td><td><font size="+1"><b>VE_absmaxind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_absmaxind</b></font></td><td width="33%"><font size="+1"><b>VCD_absmaxind</b></font></td><td><font size="+1"><b>VCE_absmaxind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_absmaxind</b></font></td><td width="33%"><font size="+1"><b>VPD_absmaxind</b></font></td><td><font size="+1"><b>VPE_absmaxind</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Largest absolute value and its index</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_absmaxind( ui *Ind, fVector X, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
<BR><font face="courier new">float VCF_absmaxind( ui *Ind, cfVector X, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VPF_,&nbsp;&nbsp; VPD_,&nbsp;&nbsp; VPE_</I>)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::absmaxind( ui *Ind );
<BR>T vector&lt;complex&lt;T&gt;&gt;::absmaxind( ui *Ind );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_absmaxind( var Ind:UInt; X:fVector; size:UInt ): Single;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
<BR><font face="courier new">function VCF_absmaxind( var Ind:UInt; X:cfVector; size:UInt ): Single;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VPF_,&nbsp;&nbsp; VPD_,&nbsp;&nbsp; VPE_</I>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The absolute values of all elements of a vector are compared and the largest returned. For complex numbers, the magnitudes of the elements are compared and the largest returned. The index of this maximum is stored at the address given by Ind. In case of more than one element with the same maximum value, the lowest index is chosen.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>maximum absolute value encountered.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#maxind">VF_maxind</a>,&nbsp;&nbsp; <a href="#absmax">VF_absmax</a>,&nbsp;&nbsp; <a href="#runmax">VF_runmax</a>,&nbsp;&nbsp; <a href="#maxind">VF_maxind</a>,&nbsp;&nbsp; <a href="#absmaxReIm">VCF_absmaxReIm</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="absmaxReIm"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_absmaxReIm</b></font></td><td width="33%"><font size="+1"><b>VCD_absmaxReIm</b></font></td><td><font size="+1"><b>VCE_absmaxReIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Separate determination of the largest absolute values of the real and imaginary parts occurring in a cartesian complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>fComplex VCF_absmaxReIm( cfVector X, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_</I>)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>complex&lt;T&gt; vector&lt;complex&lt;T&gt;&gt;::absmaxReIm();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VCF_absmaxReIm( var Max:fComplex; X:cfVector; size:UInt );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_</I>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The absolute values of the real parts of all vector elements are compared with each other and the largest one is returned as the real part of the result. Similarly, the absolute values of all the imaginary parts are compared with each other and the largest one is returned as the imaginary part of the result. Generally, the result is made up from different elements of the vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>C/C++: Largest absolute real and imaginary parts, combined into one complex number.
<BR>Pascal/Delphi: none.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#maxReIm">VCF_maxReIm</a>,&nbsp;&nbsp; <a href="#absminReIm">VCF_absminReIm</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="absmin"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_absmin</b></font></td><td width="33%"><font size="+1"><b>VD_absmin</b></font></td><td><font size="+1"><b>VE_absmin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_absmin</b></font></td><td width="33%"><font size="+1"><b>VCD_absmin</b></font></td><td><font size="+1"><b>VCE_absmin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_absmin</b></font></td><td width="33%"><font size="+1"><b>VPD_absmin</b></font></td><td><font size="+1"><b>VPE_absmin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Smallest absolute value within one vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_absmin( fVector X, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
<BR><font face="courier new">float VCF_absmin( cfVector X, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VPF_,&nbsp;&nbsp; VPD_,&nbsp;&nbsp; VPE_</I>)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::absmin();
<BR>T vector&lt;complex&lt;T&gt;&gt;::absmin();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_absmin( X:fVector; size:UInt ): Single;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
<BR><font face="courier new">function VCF_absmin( X:cfVector; size:UInt ): Single;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VPF_,&nbsp;&nbsp; VPD_,&nbsp;&nbsp; VPE_</I>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The absolute values of all elements of a vector are compared and the smallest returned.
<BR>For complex numbers, the magnitudes of the elements are compared and the smallest magnitude is returned. If you need the complex number itself rather than only its magnitude, call <I><a href="#cabsmin">VCF_cabsmin</a></I>. In order to find the smallest real and imaginary parts of cartesian complex vectors separately, please use <I><a href="#absminReIm">VCF_absminReIm</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>minimum absolute value encountered.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#min">VF_min</a>,&nbsp;&nbsp; <a href="#absmax">VF_absmax</a>,&nbsp;&nbsp; <a href="#runmin">VF_runmin</a>,&nbsp;&nbsp; <a href="#minind">VF_minind</a>,&nbsp;&nbsp; <a href="#absminReIm">VCF_absminReIm</a>,&nbsp;&nbsp; <a href="#cabsmin">VCF_cabsmin</a>,&nbsp;&nbsp; <a href="#sabsmin">VCF_sabsmin</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="absminind"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_absminind</b></font></td><td width="33%"><font size="+1"><b>VD_absminind</b></font></td><td><font size="+1"><b>VE_absminind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_absminind</b></font></td><td width="33%"><font size="+1"><b>VCD_absminind</b></font></td><td><font size="+1"><b>VCE_absminind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_absminind</b></font></td><td width="33%"><font size="+1"><b>VPD_absminind</b></font></td><td><font size="+1"><b>VPE_absminind</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Smallest absolute value and the index of its first occurrence.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_absminind( ui *Ind, fVector X, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
<BR><font face="courier new">float VCF_absminind( ui *Ind, cfVector X, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VPF_,&nbsp;&nbsp; VPD_,&nbsp;&nbsp; VPE_</I>)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::absminind( ui *Ind );
<BR>T vector&lt;complex&lt;T&gt;&gt;::absminind( ui *Ind );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_absminind( var Ind:UInt; X:fVector; size:UInt ): Single;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
<BR><font face="courier new">function VCF_absminind( var Ind:UInt; X:cfVector; size:UInt ): Single;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VPF_,&nbsp;&nbsp; VPD_,&nbsp;&nbsp; VPE_</I>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The absolute values of all elements of a vector are compared and the smallest returned. For complex numbers, the magnitudes of the elements are compared and the smallest returned. The index of this minimum is stored at the address given by Ind. In case of more than one element with the same minimum value, the lowest index is chosen.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>minimum absolute value encountered.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#minind">VF_minind</a>,&nbsp;&nbsp; <a href="#absmin">VF_absmin</a>,&nbsp;&nbsp; <a href="#runmin">VF_runmin</a>,&nbsp;&nbsp; <a href="#maxind">VF_maxind</a>,&nbsp;&nbsp; <a href="#absminReIm">VCF_absminReIm</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="absminReIm"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_absminReIm</b></font></td><td width="33%"><font size="+1"><b>VCD_absminReIm</b></font></td><td><font size="+1"><b>VCE_absminReIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Separate determination of the smallest absolute values of the real and imaginary parts occurring in a cartesian complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>fComplex VCF_absminReIm( cfVector X, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_</I>)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>complex&lt;T&gt; vector&lt;complex&lt;T&gt;&gt;::absminReIm();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VCF_absminReIm( var Min:fComplex; X:cfVector; size:UInt );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_</I>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The absolute values of the real parts of all vector elements are compared with each other and the smallest one is returned as the real part of the result. Similarly, the absolute values of all the imaginary parts are compared with each other and the smallest one is returned as the imaginary part of the result. Generally, the result is made up from different elements of the vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>C/C++: Smallest absolute real and imaginary parts, combined into one complex number.
<BR>Pascal/Delphi: none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#minReIm">VCF_minReIm</a>,&nbsp;&nbsp; <a href="#absmaxReIm">VCF_absmaxReIm</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="accV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_accV</b></font></td><td width="33%"><font size="+1"><b>VD_accV</b></font></td><td><font size="+1"><b>VE_accV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_accV</b></font></td><td width="33%"><font size="+1"><b>VCD_accV</b></font></td><td><font size="+1"><b>VCE_accV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_accV</b></font></td><td width="20%"><font size="+1"><b>VBI_accV</b></font></td><td width="20%"><font size="+1"><b>VSI_accV</b></font></td><td width="20%"><font size="+1"><b>VLI_accV</b></font></td><td><font size="+1"><b>VQI_accV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_accV</b></font></td><td width="20%"><font size="+1"><b>VUB_accV</b></font></td><td width="20%"><font size="+1"><b>VUS_accV</b></font></td><td width="20%"><font size="+1"><b>VUL_accV</b></font></td><td><font size="+1"><b>VUI_accV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="100%"><font size="+1"><b>mixed-type versions:</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VD_accVF</b></font></td><td width="33%"><font size="+1"><b>VE_accVF</b></font></td><td><font size="+1"><b>VE_accVD</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCD_accVCF</b></font></td><td width="33%"><font size="+1"><b>VCE_accVCF</b></font></td><td><font size="+1"><b>VCE_accVCD</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td><font size="+1"><b>VSI_accVBI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VI_accVBI</b></font></td><td><font size="+1"><b>VI_accVSI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VLI_accVBI</b></font></td><td width="33%"><font size="+1"><b>VLI_accVSI</b></font></td><td><font size="+1"><b>VLI_accVI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td><font size="+1"><b>VUS_accVUB</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_accVUB</b></font></td><td><font size="+1"><b>VU_accVUS</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_accVUB</b></font></td><td width="33%"><font size="+1"><b>VUL_accVUS</b></font></td><td><font size="+1"><b>VUL_accVU</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>VUI_accVUB</b></font></td><td width="25%"><font size="+1"><b>VUI_accVUS</b></font></td><td width="25%"><font size="+1"><b>VUI_accVU</b></font></td><td><font size="+1"><b>VUI_accVUL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>VQI_accVBI</b></font></td><td width="25%"><font size="+1"><b>VQI_accVSI</b></font></td><td width="25%"><font size="+1"><b>VQI_accVI</b></font></td><td><font size="+1"><b>VQI_accVLI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VQI_accVUB</b></font></td><td width="20%"><font size="+1"><b>VQI_accVUS</b></font></td><td width="20%"><font size="+1"><b>VQI_accVU</b></font></td><td width="20%"><font size="+1"><b>VQI_accVUL</b></font></td><td><font size="+1"><b>VQI_accVUI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_...</b></font></td><td width="33%"><font size="+1"><b>VD_...</b></font></td><td><font size="+1"><b>VE_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...accVI</b></font></td><td width="20%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...accVBI</b></font></td><td width="20%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...accVSI</b></font></td><td width="20%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...accVLI</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...accVQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...accVU</b></font></td><td width="20%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...accVUB</b></font></td><td width="20%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...accVUS</b></font></td><td width="20%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...accVUL</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...accVUI</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Accumulation (corresponds to the += operator)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_accV( fVector Y, fVector X, ui size );
<BR>void VD_accVF( dVector Y, fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::accV( const vector&lt;T&gt;& X );
<BR>void vector&lt;double&gt;::accVF( const vector&lt;float&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_accV( Y, X:fVector; size:UInt );
<BR>procedure VD_accVF( Y:dVector; X:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> += X<sub>i</sub>
<BR>This family of functions consists of two groups. The first group is made up of the normal, same-type versions, like <I>VF_accV</I>.
<BR>The much larger second group allows to add a lower-accuracy type vector to a higher-accuracy type vector, like <I>VD_accVF</I>. For the integer types, only the highest one, quad, is used to accumulate both signed and unsigned types. The 16-bit and 32-bit integer types can accumulate only the lower types of the same sort, signed or unsigned. All integer types can be accumulated in any of the three floating-point types.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#addV">VF_addV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="acos"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_acos</b></font></td><td width="33%"><font size="+1"><b>VD_acos</b></font></td><td><font size="+1"><b>VE_acos</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_acos</b></font></td><td width="33%"><font size="+1"><b>VCD_acos</b></font></td><td><font size="+1"><b>VCE_acos</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_acos</b></font></td><td width="33%"><font size="+1"><b>VDx_acos</b></font></td><td><font size="+1"><b>VEx_acos</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_acos</b></font></td><td width="33%"><font size="+1"><b>VCDx_acos</b></font></td><td><font size="+1"><b>VCEx_acos</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>arcus cosinus function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_acos( fVector Y, fVector X, ui size );
<BR>int VFx_acos( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::acos( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_acos( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_acos( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_acos( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = arccos ( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * arccos (A*X<sub>i</sub> + B )</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Real versions: DOMAIN errors occur for arguments outside the range -1 &lt;= X<sub>i</sub> &lt;= +1; the default result is NAN (&quot;not-a-number&quot;).
<BR>The complex versions should be error-proof as long as the parameter C in the expanded versions is not already near the OVERFLOW limit; this very rare error is neither detected nor handled.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cos">VF_cos</a>,&nbsp;&nbsp; <a href="#asin">VF_asin</a>,&nbsp;&nbsp; <a href="#atan">VF_atan</a>,&nbsp;&nbsp; acos</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="addC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_addC</b></font></td><td width="33%"><font size="+1"><b>VD_addC</b></font></td><td><font size="+1"><b>VE_addC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_addC</b></font></td><td width="33%"><font size="+1"><b>VCD_addC</b></font></td><td><font size="+1"><b>VCE_addC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_addReC</b></font></td><td width="33%"><font size="+1"><b>VCD_addReC</b></font></td><td><font size="+1"><b>VCE_addReC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_addC</b></font></td><td width="20%"><font size="+1"><b>VBI_addC</b></font></td><td width="20%"><font size="+1"><b>VSI_addC</b></font></td><td width="20%"><font size="+1"><b>VLI_addC</b></font></td><td><font size="+1"><b>VQI_addC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_addC</b></font></td><td width="20%"><font size="+1"><b>VUB_addC</b></font></td><td width="20%"><font size="+1"><b>VUS_addC</b></font></td><td width="20%"><font size="+1"><b>VUL_addC</b></font></td><td><font size="+1"><b>VUI_addC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Add a constant to a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_addC( fVector Y, fVector X, ui size, float C);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VI_</I>, etc.)
<BR><font face="courier new">void VCF_addC( cfVector Y, cfVector X, ui size, fComplex C );
<BR>void VCF_addReC( cfVector Y, cfVector X, ui size, float CRe );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_</I>)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::addC( const vector&lt;T&gt;& X, T C); );
<BR>void vector&lt;complex&lt;T&gt;&gt;::addC( const vector&lt;complex&lt;T&gt;&gt;& X, complex&lt;T&gt; C );
<BR>void vector&lt;complex&lt;T&gt;&gt;::addReC( const vector&lt;complex&lt;T&gt;&gt;& X, T CRe );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_addC( Y, X:fVector; size:UInt; C:Single );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VI_</I>, etc.)
<BR><font face="courier new">procedure VCF_addC( Y, X:cfVector; size:UInt; C:fComplex );
<BR>procedure VCF_addReC( Y, X:cfVector; size:UInt; CRe:Single );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_</I>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>i</sub> + C
<BR>The complex floating-point versions exist in two variants, one for complex constants C, the other for real-valued constants CRe added to the complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>floating-point versions: none;
<BR>integer versions: see <a href="HANDBOOK.HTM#chap5_2">chapter&nbsp;5.2.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#addV">VF_addV</a>,&nbsp;&nbsp; <a href="#subC">VF_subC</a>,&nbsp;&nbsp; <a href="#mulC">VF_mulC</a>,&nbsp;&nbsp; <a href="#divC">VF_divC</a>,&nbsp;&nbsp; <a href="#visC">VF_visC</a>,&nbsp;&nbsp; <a href="#redC">VF_redC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="addV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_addV</b></font></td><td width="33%"><font size="+1"><b>VD_addV</b></font></td><td><font size="+1"><b>VE_addV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_addV</b></font></td><td width="33%"><font size="+1"><b>VCD_addV</b></font></td><td><font size="+1"><b>VCE_addV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_addReV</b></font></td><td width="33%"><font size="+1"><b>VCD_addReV</b></font></td><td><font size="+1"><b>VCE_addReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFs_addV</b></font></td><td width="33%"><font size="+1"><b>VDs_addV</b></font></td><td><font size="+1"><b>VEs_addV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_addV</b></font></td><td width="33%"><font size="+1"><b>VDx_addV</b></font></td><td><font size="+1"><b>VEx_addV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_addV</b></font></td><td width="33%"><font size="+1"><b>VCDx_addV</b></font></td><td><font size="+1"><b>VCEx_addV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_addReV</b></font></td><td width="33%"><font size="+1"><b>VCDx_addReV</b></font></td><td><font size="+1"><b>VCEx_addReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_addV</b></font></td><td width="20%"><font size="+1"><b>VBI_addV</b></font></td><td width="20%"><font size="+1"><b>VSI_addV</b></font></td><td width="20%"><font size="+1"><b>VLI_addV</b></font></td><td><font size="+1"><b>VQI_addV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_addV</b></font></td><td width="20%"><font size="+1"><b>VUB_addV</b></font></td><td width="20%"><font size="+1"><b>VUS_addV</b></font></td><td width="20%"><font size="+1"><b>VUL_addV</b></font></td><td><font size="+1"><b>VUI_addV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Add two vectors</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_addV( fVector Z, fVector X, fVector Y,ui size );
<BR>void VFs_addV( fVector Z, fVector X, fVector Y, ui size, float C );
<BR>void VFx_addV( fVector Z, fVector X, fVector Y, ui size, float A, float B );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VDx_,&nbsp;&nbsp; VE_,&nbsp;&nbsp; VEx_,&nbsp;&nbsp; VI_</I>, etc.)
<BR><font face="courier new">void VCF_addV( cfVector Z, cfVector X, cfVector Y, ui size );
<BR>void VCF_addReV( cfVector Z, cfVector X, fVector Y, ui size );
<BR>void VCFx_addV( cfVector Z, cfVector X, cfVector Y, ui size, fComplex A, fComplex B );
<BR>void VCFx_addReV( cfVector Z, cfVector X, fVector Y, ui size, fComplex A, fComplex B );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCDx_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VCEx_</I>)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::addV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y );
<BR>void vector&lt;T&gt;::s_addV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y, T C );
<BR>void vector&lt;T&gt;::x_addV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y, T A, T B );
<BR>void vector&lt;complex&lt;T&gt;&gt;::addV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;complex&lt;T&gt;&gt;& Y );
<BR>void vector&lt;complex&lt;T&gt;&gt;::addReV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;T&gt;& Y );
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_addV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;complex&lt;T&gt;&gt;& Y, complex&lt;T&gt; A, complex&lt;T&gt; B );
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_addReV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;T&gt;& Y, complex&lt;T&gt; A, complex&lt;T&gt; B );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_addV( Z, X, Y:fVector; size:UInt );
<BR>procedure VFx_addV( Z, X, Y:fVector; size:UInt; A, B:Single );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VDx_,&nbsp;&nbsp; VE_,&nbsp;&nbsp; VEx_,&nbsp;&nbsp; VI_</I>, etc.)
<BR><font face="courier new">procedure VCF_addV( Z, X, Y:cfVector; size:UInt );
<BR>procedure VCF_addReV( Z, X:cfVector; Y:fVector; size:UInt );
<BR>procedure VCFx_addV( Z, X, Y:cfVector; size:UInt; A, B:fComplex );
<BR>procedure VCFx_addReV( Z, X:cfVector; Y:fVector; size:UInt; A, B:fComplex );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_</I>, VCDx_, <I>VCE_,&nbsp;&nbsp; VCEx_</I>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Z<sub>i</sub> = X<sub>i</sub> + Y<sub>i</sub>
<BR>scaled versions: Z<sub>i</sub> = C * (X<sub>i</sub> + Y<sub>i</sub>)
<BR>expanded versions: Z<sub>i</sub> = (A * X<sub>i</sub> + B) + Y<sub>i</sub>
<BR>The complex floating-point versions exist in two variants. In the first variant (e.g.<I>VCF_addV,&nbsp;&nbsp; VCFx_addV</I>), X, Y, and Z are all complex; in the second variant, Y is real-valued (e.g., <I>VCF_addReV</I> - &quot;add a real vector&quot;).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>floating-point versions: none;
<BR>integer versions: see <a href="HANDBOOK.HTM#chap5_2">chapter&nbsp;5.2.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#addC">VF_addC</a>,&nbsp;&nbsp; <a href="#subV">VF_subV</a>,&nbsp;&nbsp; <a href="#mulV">VF_mulV</a>,&nbsp;&nbsp; <a href="#divV">VF_divV</a>,&nbsp;&nbsp; <a href="#visV">VF_visV</a>,&nbsp;&nbsp; <a href="#redV">VF_redV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="and"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>VI_and</b></font></td><td width="25%"><font size="+1"><b>VSI_and</b></font></td><td width="25%"><font size="+1"><b>VLI_and</b></font></td><td><font size="+1"><b>VQI_and</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>VU_and</b></font></td><td width="25%"><font size="+1"><b>VUS_and</b></font></td><td width="25%"><font size="+1"><b>VUL_and</b></font></td><td><font size="+1"><b>VUI_and</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Bit-wise AND operation.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VImath.h&gt;
<BR>void VI_and( iVector Y, iVector X, ui size, int C );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::and( const vector&lt;T&gt;& X, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VImath;
<BR>procedure VI_and( Y, X:iVector; size:UInt; C:Integer );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = (X<sub>i</sub>) & C
<BR>The bit-wise AND operation is performed on each element X<sub>i</sub> with the bit-mask given by C. A bit is 1 in Y<sub>i</sub>, if it was 1 both in X<sub>i</sub> and in C, and 0 otherwise. Perhaps the most useful application of this family of functions is the fast &quot;modulo&quot; operation on unsigned or positive numbers with the modulus being an integer power of 2. For example, a modulo division by 64 is performed by
<BR><I>VU_and</I>( Y, X, size, 64-1 );</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#not">VI_not</a>,&nbsp;&nbsp; <a href="#or">VI_or</a>,&nbsp;&nbsp; <a href="#xor">VI_xor</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="arg"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_arg</b></font></td><td width="33%"><font size="+1"><b>VCD_arg</b></font></td><td><font size="+1"><b>VCE_arg</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_arg</b></font></td><td width="33%"><font size="+1"><b>VPD_arg</b></font></td><td><font size="+1"><b>VPE_arg</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Argument (angle in polar coordinates).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VCF_arg( fVector Arg, cfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::arg( const vector&lt;complex&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VCF_arg( Arg:fVector; X:cfVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Identical to <I><a href="#CtoArg">VF_CtoArg</a>,&nbsp;&nbsp; <a href="#CtoArg">VD_CtoArg</a>,&nbsp;&nbsp; <a href="#CtoArg">VE_CtoArg</a></I>, resp. See these functions for details.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ArgtoP"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ArgtoP</b></font></td><td width="33%"><font size="+1"><b>VD_ArgtoP</b></font></td><td><font size="+1"><b>VE_ArgtoP</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Overwrite the Arg part of a polar complex vector with a real vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_ArgtoP( pfVector Y, fVector Arg, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;polar&lt;T&gt;&gt;::ArgtoP( const vector&lt;T&gt;& Arg );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_ArgtoP( X:pfVector; Arg:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The Arg part of the polar complex vector Y is overwritten with the elements of the real-valued vector Arg. The Mag part of Y is not affected.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PtoMagArg">VF_PtoMagArg</a>,&nbsp;&nbsp; <a href="#MagArgtoP">VF_MagArgtoP</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="asin"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_asin</b></font></td><td width="33%"><font size="+1"><b>VD_asin</b></font></td><td><font size="+1"><b>VE_asin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_asin</b></font></td><td width="33%"><font size="+1"><b>VCD_asin</b></font></td><td><font size="+1"><b>VCE_asin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_asin</b></font></td><td width="33%"><font size="+1"><b>VDx_asin</b></font></td><td><font size="+1"><b>VEx_asin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_asin</b></font></td><td width="33%"><font size="+1"><b>VCDx_asin</b></font></td><td><font size="+1"><b>VCEx_asin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>arcus sinus function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_asin( fVector Y, fVector X, ui size );
<BR>int VFx_asin( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::asin( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_asin( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_asin( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_asin( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = arcsin ( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * arcsin (A*X<sub>i</sub> + B )</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Real versions: DOMAIN errors occur for arguments outside the range -1 &lt;= X<sub>i</sub> &lt;= +1; the default result is NAN (&quot;not-a-number&quot;).
<BR>The complex versions should be error-proof as long as the parameter C in the expanded versions is not already near the OVERFLOW limit; this very rare error is either detected nor handled.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sin">VF_sin</a>,&nbsp;&nbsp; <a href="#acos">VF_acos</a>,&nbsp;&nbsp; <a href="#atan">VF_atan</a>,&nbsp;&nbsp; asin</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="atan"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_atan</b></font></td><td width="33%"><font size="+1"><b>VD_atan</b></font></td><td><font size="+1"><b>VE_atan</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_atan</b></font></td><td width="33%"><font size="+1"><b>VCD_atan</b></font></td><td><font size="+1"><b>VCE_atan</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_atan</b></font></td><td width="33%"><font size="+1"><b>VDx_atan</b></font></td><td><font size="+1"><b>VEx_atan</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_atan</b></font></td><td width="33%"><font size="+1"><b>VCDx_atan</b></font></td><td><font size="+1"><b>VCEx_atan</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>arcus tangens function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_atan( fVector Y, fVector X, ui size );
<BR>int VFx_atan( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::atan( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_atan( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_atan( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_atan( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = arctan ( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * arctan (A*X<sub>i</sub> + B )</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>The real versions should be error-proof as long as the parameter C in the expanded versions is not already near the OVERFLOW limit; this very rare error is neither detected nor handled.
<BR>In the complex versions, the result for an argument of {0, -1} is set to {0, -<font face="symbol">p</font>} without notice (and without the program crash resulting in Borland C++ from calling the complex <I>atan</I> with this argument).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#tan">VF_tan</a>,&nbsp;&nbsp; <a href="#asin">VF_asin</a>,&nbsp;&nbsp; <a href="#acos">VF_acos</a>,&nbsp;&nbsp; <a href="#atan2">VF_atan2</a>,&nbsp;&nbsp; atan,&nbsp;&nbsp; atan2</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="atan2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_atan2</b></font></td><td width="33%"><font size="+1"><b>VD_atan2</b></font></td><td><font size="+1"><b>VE_atan2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_atan2</b></font></td><td width="33%"><font size="+1"><b>VDx_atan2</b></font></td><td><font size="+1"><b>VEx_atan2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>arcus tangens function of quotients</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_atan2( fVector Z, fVector X, fVector Y, ui size );
<BR>int VFx_atan2( fVector Z, fVector X, fVector Y, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::atan2( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y );
<BR>int vector&lt;T&gt;::x_atan2( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_atan2( Z, X, Y:fVector; size:UInt ): IntBool;
<BR>function VFx_atan2( Z, X, Y:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Z<sub>i</sub> = arctan( Y<sub>i</sub> / X<sub>i</sub> )
<BR>expanded versions: Z<sub>i</sub> = C * arctan( Y<sub>i</sub> / (A*X<sub>i</sub>+B) ) 
<BR>From Cartesian X -Y-coordinates, the angle of the corresponding polar coordinates is calculated.
<BR>Note: in comparison to the ANSI C function atan2, the ordering of the parameters X and Y is reversed.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If X<sub>i</sub> and Y<sub>i</sub> are both zero, a DOMAIN error results with the default result NAN (&quot;not-a-number&quot;).
<BR>In C/C++, this error is handled by <I>_matherr</I> and <I>_matherrl</I> with X<sub>i</sub> and Y<sub>i</sub> as e-&gt;x and e-&gt;y.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#tan">VF_tan</a>,&nbsp;&nbsp; <a href="#asin">VF_asin</a>,&nbsp;&nbsp; <a href="#acos">VF_acos</a>,&nbsp;&nbsp; <a href="#atan">VF_atan</a>,&nbsp;&nbsp;atan,&nbsp;&nbsp;atan2</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="autocorr"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_autocorr</b></font></td><td width="33%"><font size="+1"><b>VD_autocorr</b></font></td><td><font size="+1"><b>VE_autocorr</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>autocorrelation function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_autocorr( fVector Y, fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;float&gt;::autocorr( const vector&lt;float&gt;& Y );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_autocorr( Y, X:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The autocorrelation function (ACF) of X is calculated and stored in Y in wrap-around order: Y<sub>0</sub> to Y<sub>size/2-1</sub> contain the ACF for zero and positive lags. Beginning with the most negative lag in Y<sub>size/2+1</sub>, the elements up to Y<sub>size-1</sub> contain the ACF for negative lags. Since this function assumes X to be periodic, the ACF for the most positive lag is identical to the ACF for the most negative lag. This element is stored as Y<sub>size/2</sub>.
<BR>To get the ACF into normal order, you may call
<BR><font face="courier new"><a href="#rotate">VF_rotate</a>( Y, Y, size, size/2 );</font>
<BR>After that, the zero point is at the position size/2.
<P>In case X is non-periodic, you should avoid end effects by the methods described in connection with <I><a href="#convolve">VF_convolve</a></I>.
<P>About special versions with the prefixes <I>VFs_</I> and <I>VFl_</I>, consult <a href="HANDBOOK.HTM#chap4_8">chapter&nbsp;4.8.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If size is not a power of 2, <I><a href="#FFT">VF_FFT</a></I> (on which <I>VF_autocorr</I> is based) complains &quot;Size must be an integer power of 2&quot; and the program is aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#FFT">VF_FFT</a>,&nbsp;&nbsp; <a href="#convolve">VF_convolve</a>,&nbsp;&nbsp; <a href="#xcorr">VF_xcorr</a>,&nbsp;&nbsp; <a href="#spectrum">VF_spectrum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="autoPlot"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_autoPlot</b></font></td><td width="33%"><font size="+1"><b>VCD_autoPlot</b></font></td><td><font size="+1"><b>VCE_autoPlot</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Automatic plot of a complex vector into a Cartesian complex plane.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void VCF_autoPlot( cfVector X, ui size, unsigned form, COLORREF color );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;complex&lt;T&gt;&gt;::autoPlot( unsigned form, COLORREF color );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure VCF_autoPlot( X:cfVector; size, form:UInt; color:COLORREF );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A Cartesian complex plane is drawn with the axes automatically scaled and the vector X plotted into it. For a description of the parameters form and color, see <I><a href="#xyAutoPlot">VF_xyAutoPlot</a></I>. The plotting routines have to be initialized by <I><a href="#initGraph">V_initGraph</a></I> or <I><a href="#initPlot">V_initPlot</a></I> prior to calling <I>VCF_autoPlot</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#2AutoPlot">VCF_2AutoPlot</a>,&nbsp;&nbsp; <a href="#dataPlot">VCF_dataPlot</a>,&nbsp;&nbsp; <a href="#xyAutoPlot">VF_xyAutoPlot</a></I>,&nbsp;&nbsp;<a href="HANDBOOK.HTM#chap4_12">chapter&nbsp;4.12</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="2AutoPlot"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_2AutoPlot</b></font></td><td width="33%"><font size="+1"><b>VCD_2AutoPlot</b></font></td><td><font size="+1"><b>VCE_2AutoPlot</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Automatic plot of two complex vectors into a Cartesian complex plane.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void VCF_2AutoPlot( cfVector X1, ui size1, unsigned form1, COLORREF color1, cfVector X2, ui size2, unsigned form2, COLORREF color2 );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;complex&lt;T&gt;&gt;::_2AutoPlot( unsigned form1, COLORREF color1, 
const vector&lt;complex&lt;T&gt;&gt;& X2, unsigned form2, COLORREF color2 );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure VCF_2AutoPlot( X1:cfVector; size1, form1:UInt; color1:COLORREF; X2:cfVector; size2, form2:UInt; color2:COLORREF );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A Cartesian complex plane is drawn with the axes automatically scaled and the vectors X1 and X2 plotted into it. For a description of the parameters form1, form2, color1, and color2, see <I><a href="#xyAutoPlot">VF_xyAutoPlot</a></I>. The plotting routines have to be initialized by <I><a href="#initGraph">V_initGraph</a></I> or <I><a href="#initPlot">V_initPlot</a></I> prior to calling <I>VCF_2AutoPlot</I>.
<BR>Note the leading underbar in the <I>VecObj</I> function. (It is necessary, as C/C++ does not allow function names to begin with a number.)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#autoPlot">VCF_autoPlot</a>,&nbsp;&nbsp; <a href="#dataPlot">VCF_dataPlot</a>,&nbsp;&nbsp; <a href="#xyAutoPlot">VF_xyAutoPlot</a></I>,&nbsp;&nbsp;<a href="HANDBOOK.HTM#chap4_12">chapter&nbsp;4.11</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="avdevC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_avdevC</b></font></td><td width="33%"><font size="+1"><b>VD_avdevC</b></font></td><td><font size="+1"><b>VE_avdevC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>average deviation from a preset value</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_avdevC( fVector X, ui size, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::avdevC( T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_avdevC( X:fVector; size:UInt; C:Single ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>avdevC = 1/size * sum( |X<sub>i</sub> - C| )
<BR>The average of the absolute deviation of each element of X from C is calculated and returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>average deviation.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ssq">VF_ssq</a>,&nbsp;&nbsp; <a href="#ssqdevC">VF_ssqdevC</a>,&nbsp;&nbsp; <a href="#avdevV">VF_avdevV</a>,&nbsp;&nbsp; <a href="#sumdevC">VF_sumdevC</a>,&nbsp;&nbsp; <a href="#chiabs">VF_chiabs</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="avdevV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_avdevV</b></font></td><td width="33%"><font size="+1"><b>VD_avdevV</b></font></td><td><font size="+1"><b>VE_avdevV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>average deviation of the elements of one vector from the corresponding elements of another vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_avdevV( fVector X, fVector Y, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::avdevV( const vector&lt;T&gt;& Y );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_avdevV( X, Y:fVector; size:UInt ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>avdevV = 1/size * sum( |X<sub>i</sub> - Y<sub>i</sub>| )
<BR>The average of the absolute deviation of each element of X from the corresponding element of Y is calculated.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>average deviation.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ssq">VF_ssq</a>,&nbsp;&nbsp; <a href="#ssqdevV">VF_ssqdevV</a>,&nbsp;&nbsp; <a href="#avdevC">VF_avdevC</a>,&nbsp;&nbsp; <a href="#sumdevV">VF_sumdevV</a>,&nbsp;&nbsp; <a href="#chiabs">VF_chiabs</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cabsmax"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_cabsmax</b></font></td><td width="33%"><font size="+1"><b>VCD_cabsmax</b></font></td><td><font size="+1"><b>VCE_cabsmax</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Element of largest absolute value within one vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>fComplex VCF_cabsmax( cfVector X, ui size);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;complex&lt;T&gt;&gt;::cabsmax();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VCF_cabsmax( var Max:fComplex; X:cfVector; size:UInt );</font>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The absolute values of all elements of a cartesian-complex vector are compared and the element with the largest absolute value is returned. A variant of this function, finding the largest element in terms of the sum <nobr>|Re| + |Im|,</nobr> is offered by <I><a href="#sabsmax">VCF_sabsmax</a></I>. The latter function is much faster than <I>VCF_cabsmax</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>largest element in terms of absolute value</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#absmax">VCF_absmax</a>,&nbsp;&nbsp; <a href="#absmaxReIm">VCF_absmaxReIm</a>,&nbsp;&nbsp; <a href="#sabsmax">VCF_sabsmax</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cabsmin"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_cabsmin</b></font></td><td width="33%"><font size="+1"><b>VCD_cabsmin</b></font></td><td><font size="+1"><b>VCE_cabsmin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Element of smallest absolute value within one vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>fComplex VCF_cabsmin( cfVector X, ui size);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;complex&lt;T&gt;&gt;::cabsmin();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VCF_cabsmin( var Min:fComplex; X:cfVector; size:UInt );</font>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The absolute values of all elements of a cartesian-complex vector are compared and the element with the smallest absolute value is returned. A variant of this function, finding the smallest element in terms of the sum <nobr>|Re| + |Im|,</nobr> is offered by <I><a href="#sabsmin">VCF_sabsmin</a></I>. The latter function is much faster than <I>VCF_cabsmin</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>smallest element in terms of absolute value</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#absmin">VCF_absmin</a>,&nbsp;&nbsp; <a href="#absminReIm">VCF_absminReIm</a>,&nbsp;&nbsp; <a href="#sabsmin">VCF_sabsmin</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="CDtoCF"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_CDtoCF</b></font></td><td><font size="+1"><b>V_CDtoCE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_CEtoCF</b></font></td><td><font size="+1"><b>V_CEtoCD</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_CFtoCD</b></font></td><td><font size="+1"><b>V_CFtoCE</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Data type conversions. See <I><a href="#FtoD">V_FtoD</a></I>.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ceil"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ceil</b></font></td><td width="33%"><font size="+1"><b>VD_ceil</b></font></td><td><font size="+1"><b>VE_ceil</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ceiltoI</b></font></td><td width="33%"><font size="+1"><b>VD_ceiltoI</b></font></td><td><font size="+1"><b>VE_ceiltoI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ceiltoBI</b></font></td><td width="33%"><font size="+1"><b>VD_ceiltoBI</b></font></td><td><font size="+1"><b>VE_ceiltoBI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ceiltoSI</b></font></td><td width="33%"><font size="+1"><b>VD_ceiltoSI</b></font></td><td><font size="+1"><b>VE_ceiltoSI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ceiltoLI</b></font></td><td width="33%"><font size="+1"><b>VD_ceiltoLI</b></font></td><td><font size="+1"><b>VE_ceiltoLI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ceiltoQI</b></font></td><td width="33%"><font size="+1"><b>VD_ceiltoQI</b></font></td><td><font size="+1"><b>VE_ceiltoQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ceiltoU</b></font></td><td width="33%"><font size="+1"><b>VD_ceiltoU</b></font></td><td><font size="+1"><b>VE_ceiltoU</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ceiltoUB</b></font></td><td width="33%"><font size="+1"><b>VD_ceiltoUB</b></font></td><td><font size="+1"><b>VE_ceiltoUB</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ceiltoUS</b></font></td><td width="33%"><font size="+1"><b>VD_ceiltoUS</b></font></td><td><font size="+1"><b>VE_ceiltoUS</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ceiltoUL</b></font></td><td width="33%"><font size="+1"><b>VD_ceiltoUL</b></font></td><td><font size="+1"><b>VE_ceiltoUL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ceiltoUI</b></font></td><td width="33%"><font size="+1"><b>VD_ceiltoUI</b></font></td><td><font size="+1"><b>VE_ceiltoUI</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Rounding to the next whole number that is greater or equal.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_ceil( fVector Y, fVector X, ui size );
<BR>int VF_ceiltoI( iVector Y, fVector X, ui size );
<BR>int VF_ceiltoLI( liVector Y, fVector X, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::ceil( const vector&lt;T&gt;& X );
<BR>int vector&lt;int&gt;::ceiltoI( const vector&lt;T&gt;& X );
<BR>int vector&lt;long&gt;::ceiltoLI( const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_ceil( Y, X:fVector; size:UInt ):IntBool;
<BR>function VF_ceiltoI( Y:iVector; X:fVector; size:UInt ): IntBool;
<BR>function VF_ceiltoLI( Y:liVector; X:fVector; size:UInt ): IntBool;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of X is rounded to the nearest whole number that is greater than or equal to the input number and the result stored in Y. The functions <I>VF_ceiltoI,&nbsp;&nbsp; VF_ceiltoLI,&nbsp;&nbsp; VF_ceiltoU</I> etc. convert the result into the various integer data types (in the cases mentioned, to int, long int, and unsigned, resp.).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors are handled by setting the result to the extreme value possible. Negative numbers in the versions <I>VF_ceiltoU,&nbsp;&nbsp; VF_ceiltoUS,&nbsp;&nbsp; VF_ceiltoUL</I>, and <I>VF_ceiltoUI</I> lead to DOMAIN errors; they are handled by setting the result to 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#round">VF_round</a>,&nbsp;&nbsp; <a href="#floor">VF_floor</a>,&nbsp;&nbsp; <a href="#chop">VF_chop</a>,&nbsp;&nbsp; <a href="#trunc">VF_trunc</a>,&nbsp;&nbsp; ceil,&nbsp;&nbsp; floor</I> (C/C++ only)</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="chiabs"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_chiabs</b></font></td><td width="33%"><font size="+1"><b>VD_chiabs</b></font></td><td><font size="+1"><b>VE_chiabs</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Absolute-value analogue of the chi-square merit function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_chiabs( fVector X, fVector Y, fVector Wt, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::chiabs( const vector&lt;T&gt;& Y, const vector&lt;T&gt;& Wt );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_chiabs( X, Y, Wt:fVector; size:UInt ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>chiabs = sum( Wt<sub>i</sub> * |X<sub>i</sub> - Y<sub>i</sub>| ).
<BR>The chiabs function is a &quot;robust&quot; replacement for the <font face="symbol">c</font><sup>2</sup> (chi-square) merit function. It is used to judge the quality of a fit in the presence of outlier points. The chiabs function is disturbed by outlier points to a lesser degree than the chi-square function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>chiabs merit function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#chi2">VF_chi2</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="chi2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_chi2</b></font></td><td width="33%"><font size="+1"><b>VD_chi2</b></font></td><td><font size="+1"><b>VE_chi2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Chi-square merit function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_chi2( fVector X, fVector Y, fVector InvVar, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::chi2( const vector&lt;T&gt;& Y, const vector&lt;T&gt;& InvVar );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_chi2( X, Y, InvVar:fVector; size:UInt ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><font face="symbol">c</font><sup>2</sup> = sum( 1/<font face="symbol">s</font><sub>i</sub><sup>2</sup> * (X<sub>i</sub> - Y<sub>i</sub>)<sup>2</sup> ).
<BR>The <font face="symbol">c</font><sup>2</sup> (chi-square) merit function is most often used to judge the quality of a fit. One vector (either X or Y) represents experimental values that are obtained with individual standard deviations sigma<sub>i</sub>, the other contains the values predicted on the basis of a theory or a model. If the experimental data are &quot;normally&quot; distributed, and if <font face="symbol">s</font> (sigma) is the correct measure for the quality of these data, then <font face="symbol">c</font><sup>2</sup> is a measure for the quality of the fit. Rather than the standard deviations themselves, the routine needs the inverse of their squares (i.e., the inverse of the variances) to be passed as the vector InvVar.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>chi<sup>2</sup> merit function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#meanwW">VF_meanwW</a>,&nbsp;&nbsp; <a href="#varianceVwW">VF_varianceVwW</a>,&nbsp;&nbsp; <a href="#varianceV">VF_varianceV</a>,&nbsp;&nbsp; <a href="#varianceCwW">VF_varianceCwW</a></I>,
&nbsp;&nbsp;<I><a href="#chiabs">VF_chiabs</a>,&nbsp;&nbsp; <a href="#square">VF_square</a>,&nbsp;&nbsp; <a href="#inv">VF_inv</a>,&nbsp;&nbsp; <a href="#linregress">VF_linregress</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="chop"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_chop</b></font></td><td width="33%"><font size="+1"><b>VD_chop</b></font></td><td><font size="+1"><b>VE_chop</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_choptoI</b></font></td><td width="33%"><font size="+1"><b>VD_choptoI</b></font></td><td><font size="+1"><b>VE_choptoI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_choptoBI</b></font></td><td width="33%"><font size="+1"><b>VD_choptoBI</b></font></td><td><font size="+1"><b>VE_choptoBI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_choptoSI</b></font></td><td width="33%"><font size="+1"><b>VD_choptoSI</b></font></td><td><font size="+1"><b>VE_choptoSI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_choptoLI</b></font></td><td width="33%"><font size="+1"><b>VD_choptoLI</b></font></td><td><font size="+1"><b>VE_choptoLI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_choptoQI</b></font></td><td width="33%"><font size="+1"><b>VD_choptoQI</b></font></td><td><font size="+1"><b>VE_choptoQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_choptoU</b></font></td><td width="33%"><font size="+1"><b>VD_choptoU</b></font></td><td><font size="+1"><b>VE_choptoU</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_choptoUB</b></font></td><td width="33%"><font size="+1"><b>VD_choptoUB</b></font></td><td><font size="+1"><b>VE_choptoUB</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_choptoUS</b></font></td><td width="33%"><font size="+1"><b>VD_choptoUS</b></font></td><td><font size="+1"><b>VE_choptoUS</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_choptoUL</b></font></td><td width="33%"><font size="+1"><b>VD_choptoUL</b></font></td><td><font size="+1"><b>VE_choptoUL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_choptoUI</b></font></td><td width="33%"><font size="+1"><b>VD_choptoUI</b></font></td><td><font size="+1"><b>VE_choptoUI</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;Chopping&quot; towards zero.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_chop( fVector Y, fVector X, ui size );
<BR>int VF_choptoI( iVector Y, fVector X, ui size );
<BR>int VF_choptoLI( liVector Y, fVector X, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::chop( const vector&lt;T&gt;& X );
<BR>int vector&lt;int&gt;::choptoI( const vector&lt;T&gt;& X );
<BR>int vector&lt;long&gt;::choptoLI( const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_chop( Y, X:fVector; size:UInt ):IntBool;
<BR>function VF_choptoI( Y:iVector; X:fVector; size:UInt ): IntBool;
<BR>function VF_choptoLI( Y:liVector; X:fVector; size:UInt ): IntBool;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of X is rounded to an integer number by &quot;chopping off&quot; the fractional part. For example, -3.9 yields -3, and +3.9 yields +3. The result is stored in Y. The functions <I>VF_choptoI,&nbsp;&nbsp; VF_choptoLI</I>, etc. convert the result into the various integer data types.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors are handled by setting the result to the extreme value possible. Negative numbers in the versions <I>VF_choptoU,&nbsp;&nbsp; VF_choptoUS,&nbsp;&nbsp; VF_choptoUL</I>, and <I>VF_choptoUI</I> lead to DOMAIN errors; they are handled by setting the result to 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#round">VF_round</a>,&nbsp;&nbsp; <a href="#floor">VF_floor</a>,&nbsp;&nbsp; <a href="#ceil">VF_ceil</a>,&nbsp;&nbsp; ceil,&nbsp;&nbsp; floor</I> (C/C++ only)</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="closeErrorEventFile"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_closeErrorEventFile</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Restore default printing of error messages into <I>stderr</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>void V_closeErrorEventFile( void );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>procedure V_closeErrorEventFile;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>After error messages have been redirected into an event file by <I><a href="#setErrorEventFile">V_setErrorEventFile</a></I>, the default is restored by <I>V_closeErrorEventFile</I> and any further messages will be printed into <I>stderr</I> which normally is the screen (see <a href="HANDBOOK.HTM#chap5_5">chapter&nbsp;5.5</a>). Both of these functions will not be included in versions of <I>VectorLib</I> for compilers that do already offer the possibility of printing error messages simultaneously to the screen and to an event file.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#noteError">V_noteError</a>,&nbsp;&nbsp; <a href="#setErrorEventFile">V_setErrorEventFile</a>,&nbsp;&nbsp; _matherr</I> (C/C++ only)</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cmp0"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cmp0</b></font></td><td width="33%"><font size="+1"><b>VD_cmp0</b></font></td><td><font size="+1"><b>VE_cmp0</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Compares each element of a vector with 0 (signum function).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_cmp0( fVector Y, fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::cmp0( const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_cmp0( Y,X:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of X is compared with 0 and the result of the comparison stored in Y:
<BR>Y<sub>i</sub> = +1.0, if X<sub>i</sub> &gt; 0
<BR>Y<sub>i</sub> = &nbsp;&nbsp;0.0, if X<sub>i</sub> = 0
<BR>Y<sub>i</sub> = &nbsp;-1.0, if X<sub>i</sub> &lt; 0.
<BR>This function may also be called under its synonym <I><a href="#sgn">VF_sgn</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cmp_">VF_cmp_...</a>,&nbsp;&nbsp; <a href="#cmpC">VF_cmpC</a>,&nbsp;&nbsp; <a href="#cmpV">VF_cmpV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cmpC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cmpC</b></font></td><td width="33%"><font size="+1"><b>VD_cmpC</b></font></td><td><font size="+1"><b>VE_cmpC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Compares each element of a vector with a constant.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_cmpC( fVector Y, fVector X, ui size, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::cmpC( const vector&lt;T&gt;& X, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_cmpC( Y,X:fVector; size:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of X is compared with C and the result of the comparison stored in Y:
<BR>Y<sub>i</sub> = +1.0, if X<sub>i</sub> &gt; C
<BR>Y<sub>i</sub> = &nbsp;&nbsp;0.0, if X<sub>i</sub> = C
<BR>Y<sub>i</sub> = &nbsp;-1.0, if X<sub>i</sub> &lt; C
<BR>To compare with C=0, use more efficiently the function <I><a href="#cmp0">VF_cmp0</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cmp_">VF_cmp_</a></I>...,&nbsp;&nbsp;<I><a href="#cmp0">VF_cmp0</a>,&nbsp;&nbsp; <a href="#cmpV">VF_cmpV</a>,&nbsp;&nbsp; <a href="#iselementC">VF_iselementC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cmpV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cmpV</b></font></td><td width="33%"><font size="+1"><b>VD_cmpV</b></font></td><td><font size="+1"><b>VE_cmpV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Compares each element of a vector with the corresponding element of another vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_cmpV( fVector Z, fVector X, fVector Y, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::cmpV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_cmpV( Z, X, Y:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of X is compared with the corresponding element of Y and the result of the comparison stored in Z:
<BR>Z<sub>i</sub> = +1.0, if X<sub>i</sub> &gt; Y<sub>i</sub>
<BR>Z<sub>i</sub> = &nbsp;&nbsp;0.0, if X<sub>i</sub> = Y<sub>i</sub>
<BR>Z<sub>i</sub> = &nbsp;-1.0, if X<sub>i</sub> &lt; Y<sub>i</sub>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cmp_">VF_cmp_</a></I>...,&nbsp;&nbsp;<I><a href="#cmp0">VF_cmp0</a>,&nbsp;&nbsp; <a href="#cmpC">VF_cmpC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cmp_"></a><a name="cmp_..."></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cmp_...</b></font></td><td width="33%"><font size="+1"><b>VD_cmp_...</b></font></td><td><font size="+1"><b>VE_cmp_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eq0</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ne0</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...gt0</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ge0</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...le0</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...lt0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eqC</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...neC</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...gtC</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...geC</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...leC</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ltC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eqV</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...neV</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...gtV</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...geV</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...leV</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ltV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eq0ind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ne0ind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...gt0ind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ge0ind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...le0ind</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...lt0ind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eqCind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...neCind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...gtCind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...geCind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...leCind</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ltCind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eqVind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...neVind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...gtVind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...geVind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...leVind</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ltVind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...inclrange0C</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...exclrange0C</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...inclrangeCC</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...exclrangeCC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...inclrange0Cind</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...exclrange0Cind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...inclrangeCCind</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...exclrangeCCind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_cmp_...</b></font></td><td width="33%"><font size="+1"><b>VCD_cmp_...</b></font></td><td><font size="+1"><b>VCE_cmp_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_cmp_...</b></font></td><td width="33%"><font size="+1"><b>VPD_cmp_...</b></font></td><td><font size="+1"><b>VPE_cmp_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eq0</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ne0</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eqC</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...neC</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eqV</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...neV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eq0ind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...ne0ind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eqCind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...neCind</b></font></td><td width="15%"><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...eqVind</b></font></td><td><font size="+1"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...neVind</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Comparisons</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>ui VF_cmp_eq0( fVector Y, fVector X, ui size );
<BR>ui VF_cmp_ne0( fVector Y, fVector X, ui size );
<BR>ui VF_cmp_gt0( fVector Y, fVector X, ui size );
<BR>ui VF_cmp_ge0( fVector Y, fVector X, ui size );
<BR>ui VF_cmp_lt0( fVector Y, fVector X , ui size );
<BR>ui VF_cmp_le0( fVector Y, fVector X, ui size );</font>
<BR><P><font face="courier new">ui VF_cmp_eqC( fVector Y, fVector X, ui size, float C );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neC, ..._gtC, ..._geC, ..._ltC, ..._leC</I>)
<BR><font face="courier new">ui VF_cmp_eqV( fVector Z, fVector X, fVector Y, ui size);</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neV, ..._gtV, ..._geV, ..._ltV, ..._leV</I>)
<BR><font face="courier new">ui VF_cmp_eq0ind( uiVector Ind, fVector X, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._ne0ind, ..._gt0ind, ..._ge0ind, ..._lt0ind, ..._le0ind</I>)
<BR><font face="courier new">ui VF_cmp_eqCind( uiVector Ind, fVector X, ui size, float C );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neCind, ..._gtCind, ..._geCind, ..._ltCind, ..._leCind</I>)
<BR><font face="courier new">ui VF_cmp_eqVind( uiVector Ind, fVector X, fVector Y, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neVind, ..._gtVind, ..._geVind, ..._ltVind, ..._leVind</I>)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_</I> and <I>VE_</I> versions)
<P><font face="courier new">ui VF_cmp_inclrange0C( fVector Y, fVector X, ui size, float C );
<BR>ui VF_cmp_exclrange0C( fVector Y, fVector X, ui size, float C );
<BR>ui VF_cmp_inclrangeCC( fVector Y, fVector X, ui size, float CLo, float CHi );
<BR>ui VF_cmp_exclrangeCC( fVector Y, fVector X, ui size, float CLo, float CHi );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_</I> and <I>VE_</I> versions)
<P><font face="courier new">ui VF_cmp_inclrange0Cind( uiVector Ind, fVector X, ui size, float C );
<BR>ui VF_cmp_exclrange0Cind( uiVector Ind, fVector X, ui size, float C );
<BR>ui VF_cmp_inclrangeCCind( uiVector Ind, fVector X, ui size, float CLo, float CHi );
<BR>ui VF_cmp_exclrangeCCind( uiVector Ind, fVector X, ui size, float CLo, float CHi );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_</I> and <I>VE_</I> versions)
<P><font face="courier new">ui VCF_cmp_eq0( cfVector Y, cfVector X, ui size );
<BR>ui VCF_cmp_ne0( cfVector Y, cfVector X, ui size );
<BR>ui VCF_cmp_eqC( cfVector Y, cfVector X, ui size, fComplex C );
<BR>ui VCF_cmp_neC( cfVector Y, cfVector X, ui size, fComplex C );
<BR>ui VCF_cmp_eqV( cfVector Z, cfVector X, cfVector Y, ui size );
<BR>ui VCF_cmp_neV( cfVector Z, cfVector X, cfVector Y, ui size );
<BR>ui VCF_cmp_eq0ind( uiVector Ind, cfVector X, ui size );
<BR>ui VCF_cmp_ne0ind( uiVector Ind, cfVector X, ui size );
<BR>ui VCF_cmp_eqCind( uiVector Ind, cfVector X, ui size, fComplex C );
<BR>ui VCF_cmp_neCind( uiVector Ind, cfVector X, ui size, fComplex C );
<BR>ui VCF_cmp_eqVind( uiVector Ind, cfVector X, cfVector Y, ui size );
<BR>ui VCF_cmp_neVind( uiVector Ind, cfVector X, cfVector Y, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_</I> and <I>VCE_</I> versions)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>ui vector&lt;T&gt;::cmp_eq0( const vector&lt;T&gt;& X );
<BR>ui vector&lt;T&gt;::cmp_ne0( const vector&lt;T&gt;& X );
<BR>ui vector&lt;T&gt;::cmp_gt0( const vector&lt;T&gt;& X );
<BR>ui vector&lt;T&gt;::cmp_ge0( const vector&lt;T&gt;& X );
<BR>ui vector&lt;T&gt;::cmp_lt0( const vector&lt;T&gt;& X );
<BR>ui vector&lt;T&gt;::cmp_le0( const vector&lt;T&gt;& X );
<BR>ui vector&lt;T&gt;::cmp_eqC( const vector&lt;T&gt;& X, T C );
<BR>ui vector&lt;T&gt;::cmp_eqV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y );
<BR>ui vector&lt;ui&gt;::cmp_eq0ind( const vector&lt;ui&gt;& Ind, const vector&lt;T&gt;& X );
<BR>ui vector&lt;ui&gt;::cmp_eqCind( const vector&lt;ui&gt;& Ind, const vector&lt;T&gt;& X );
<BR>ui vector&lt;ui&gt;::cmp_eqVind( const vector&lt;ui&gt;& Ind, const vector&lt;T&gt;& X );
<BR>ui vector&lt;T&gt;::cmp_inclrange0C( const vector&lt;T&gt;& X, T C );
<BR>ui vector&lt;T&gt;::cmp_exclrange0C( const vector&lt;T&gt;& X, T C );
<BR>ui vector&lt;T&gt;::cmp_inclrangeCC( const vector&lt;T&gt;& X, T CLo, T CHi );
<BR>ui vector&lt;T&gt;::cmp_exclrangeCC( const vector&lt;T&gt;& X, T CLo, T CHi );
<BR>ui vector&lt;ui&gt;::cmp_inclrange0Cind( const vector&lt;ui&gt;& Ind, const vector&lt;T&gt;& X, T C );
<BR>ui vector&lt;ui&gt;::cmp_exclrange0Cind( const vector&lt;ui&gt;& Ind, const vector&lt;T&gt;& X, T C );
<BR>ui vector&lt;ui&gt;::cmp_inclrangeCCind( const vector&lt;ui&gt;& Ind, const vector&lt;T&gt;& X, T CLo, T CHi );
<BR>ui vector&lt;ui&gt;::cmp_exclrangeCCind( const vector&lt;ui&gt;& Ind, const vector&lt;T&gt;& X, T CLo, T CHi );
<BR>ui vector&lt;complex&lt;T&gt;&gt;::cmp_eq0( const vector&lt;complex&lt;T&gt;&gt;& X );
<BR>ui vector&lt;complex&lt;T&gt;&gt;::cmp_ne0( const vector&lt;complex&lt;T&gt;&gt;& X );
<BR>ui vector&lt;complex&lt;T&gt;&gt;::cmp_eqC( const vector&lt;complex&lt;T&gt;&gt;& X, complex&lt;T&gt; C );
<BR>ui vector&lt;complex&lt;T&gt;&gt;::cmp_neC( const vector&lt;complex&lt;T&gt;&gt;& X, complex&lt;T&gt; C );
<BR>ui vector&lt;complex&lt;T&gt;&gt;::cmp_eqV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;complex&lt;T&gt;&gt;& Y );
<BR>ui vector&lt;complex&lt;T&gt;&gt;::cmp_neV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;complex&lt;T&gt;&gt;& Y );
<BR>ui vector&lt;ui&gt;::cmp_eq0ind( const vector&lt;ui&gt;& Ind, const vector&lt;complex&lt;T&gt;&gt;& X );
<BR>ui vector&lt;ui&gt;::cmp_ne0ind( const vector&lt;ui&gt;& Ind, const vector&lt;complex&lt;T&gt;&gt;& X );
<BR>ui vector&lt;ui&gt;::cmp_eqCind( const vector&lt;ui&gt;& Ind, const vector&lt;complex&lt;T&gt;&gt;& X );
<BR>ui vector&lt;ui&gt;::cmp_neCind( const vector&lt;ui&gt;& Ind, const vector&lt;complex&lt;T&gt;&gt;& X );
<BR>ui vector&lt;ui&gt;::cmp_eqVind( const vector&lt;ui&gt;& Ind, const vector&lt;complex&lt;T&gt;&gt;& X );
<BR>ui vector&lt;ui&gt;::cmp_neVind( const vector&lt;ui&gt;& Ind, const vector&lt;complex&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_cmp_eq0( Y,X:fVector; size:UInt ):UInt;
<BR>function VF_cmp_ne0( Y,X:fVector; size:UInt ):UInt;
<BR>function VF_cmp_gt0( Y,X:fVector; size:UInt ):UInt;
<BR>function VF_cmp_ge0( Y,X:fVector; size:UInt ):UInt;
<BR>function VF_cmp_lt0( Y,X:fVector; size:UInt ):UInt;
<BR>function VF_cmp_le0( Y,X:fVector; size:UInt ):UInt;</font>
<BR><P><font face="courier new">function VF_cmp_eqC( Y,X:fVector; size:UInt; C:Single ):UInt;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neC, ..._gtC, ..._geC, ..._ltC, ..._leC</I>)
<BR><font face="courier new">function VF_cmp_eqV( Z, X, Y:fVector; size:UInt ):UInt;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neV, ..._gtV, ..._geV, ..._ltV, ..._leV</I>)
<BR><font face="courier new">function VF_cmp_eq0ind( Ind:uVector; X:fVector; size:UInt ):UInt;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._ne0ind, ..._gt0ind, ..._ge0ind, ..._lt0ind, ..._le0ind</I>)
<BR><font face="courier new">function VF_cmp_eqCind( Ind:uVector; X:fVector; size:UInt; C:Single ):UInt;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neCind, ..._gtCind, ..._geCind, ..._ltCind, ..._leCind</I>)
<BR><font face="courier new">function VF_cmp_eqVind( Ind:uVector; X, Y:fVector; size:UInt ):UInt;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly: <I>..._neVind, ..._gtVind, ..._geVind, ..._ltVind, ..._leVind</I>)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_</I> and <I>VE_</I> versions)
<BR><P><font face="courier new">function VF_cmp_inclrange0C( Y, X:fVector; size:UInt; C:Single ): UInt;
<BR>function VF_cmp_exclrange0C( Y, X:fVector; size:UInt; C:Single ): UInt;
<BR>function VF_cmp_inclrangeCC( Y, X:fVector; size:UInt; CLo, CHi:Single ): UInt;
<BR>function VF_cmp_exclrangeCC( Y, X:fVector; size:UInt; CLo, CHi:Single ): UInt;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_</I> and <I>VE_</I> versions)
<BR><P><font face="courier new">function VF_cmp_inclrange0Cind( Ind:uVector; X:fVector; size:UInt; C:Single ): UInt;
<BR>function VF_cmp_exclrange0Cind( Ind:uVector; X:fVector; size:UInt; C:Single ): UInt;
<BR>function VF_cmp_inclrangeCCind( Ind:uVector; X:fVector; size:UInt; CLo, CHi:Single ): UInt;
<BR>function VF_cmp_exclrangeCCind( Ind:uVector; X:fVector; size:UInt; CLo, CHi:Single ): UInt;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_</I> and <I>VE_</I> versions)
<BR><P><font face="courier new">function VCF_cmp_eq0( Y, X:cfVector; size:UInt ):UInt;
<BR>function VCF_cmp_ne0( Y, X:cfVector; size:UInt ):UInt;
<BR>function VCF_cmp_eqC( Y, X:cfVector; size:UInt; C:fComplex ):UInt;
<BR>function VCF_cmp_neC( Y, X:cfVector; size:UInt; C:fComplex ):UInt;
<BR>function VCF_cmp_eqV( Z, X, Y:cfVector; size:UInt ):UInt;
<BR>function VCF_cmp_neV( Z, X, Y:cfVector; size:UInt ):UInt;</font>
<BR><P><font face="courier new">function VCF_cmp_eq0ind( Ind:uVector; X:cfVector; size:UInt ):UInt;
<BR>function VCF_cmp_ne0ind( Ind:uVector; X:cfVector; size:UInt ):UInt;
<BR>function VCF_cmp_eqCind( Ind:uVector; X:cfVector; size:UInt; C:fComplex ):UInt;
<BR>function VCF_cmp_neCind( Ind:uVector; X:cfVector; size:UInt; C:fComplex ):UInt;
<BR>function VCF_cmp_eqVind( Ind:uVector; X, Y:cfVector; size:UInt ):UInt;
<BR>function VCF_cmp_neVind( Ind:uVector; X, Y:cfVector; size:UInt ):UInt;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_</I> and <I>VCE_</I> versions)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>a) Simple comparisons:
<BR>Each element of X is compared with either 0, or a constant C, or the corresponding element of another vector, Y. The conditions to be tested are denoted by two letters as in ASSEMBLER or FORTRAN:<BR>&nbsp;
<TABLE>
<TR><TD>&quot;eq&quot; (&quot;equal&quot;)</TD><TD>True, if X<sub>i</sub> = 0 (C, Y<sub>i</sub>, resp.)</TD></TR>
<TR><TD>&quot;ne&quot; (&quot;not equal&quot;)</TD><TD>True, if X<sub>i</sub> != 0 (C, Y<sub>i</sub>, resp.)</TD></TR>
<TR><TD>&quot;gt&quot; (&quot;gteater than&quot;)</TD><TD>True, if X<sub>i</sub> &gt; 0 (C, Y<sub>i</sub>, resp.)</TD></TR>
<TR><TD>&quot;ge&quot; (&quot;greater or equal&quot;) &nbsp;&nbsp;</TD><TD>True, if X<sub>i</sub> &gt;= 0 (C, Y<sub>i</sub>, resp.)</TD></TR>
<TR><TD>&quot;lt&quot; (&quot;less than&quot;)</TD><TD>True, if X<sub>i</sub> &lt; 0 (C, Y<sub>i</sub>, resp.)</TD></TR>
<TR><TD>&quot;le&quot; (&quot;less or equal&quot;)</TD><TD>True, if X<sub>i</sub> &lt;= 0 (C, Y<sub>i</sub>, resp.)</TD></TR>
</TABLE>
<P>For complex numbers, only the test for equality (&quot;eq&quot;) or inequality (&quot;ne&quot;) makes sense and is available.
<P>b) Range-checking functions
<BR>Each element of X is checked if it falls into a range which is specified either by 0 and a (positive or negative) constant C, or by two constants, CLo and CHi. One has the choice between two versions, treating the range either as inclusive or as exclusive of the end points:
<BR><I>VF_cmp_inclrange0C</I> checks for 0 &lt;= x &lt;= C (positive C) or 0 &gt;= x &gt;= C (negative C), whereas <I>VF_cmp_exclrangeCC</I> checks for CLo &lt; x &lt; CHi.
<P>a) and b):
<BR>There are two different ways how the result of the comparison is treated. The result for each element of X is either stored as 1.0 for TRUE and 0.0 for FALSE in a vector of a floating-point data type (with the imaginary part in the complex versions always set to 0), or the indices of the elements for which the result is TRUE are stored in an index vector; the latter is the case in the functions with the suffix &quot;ind&quot; as the last part of their names, like in <I>VF_cmp_neCind</I>. In any case, the number of TRUE results encountered is returned by the function. The index-finding variant is especially useful to extract the elements for which the condition is TRUE into a sub-vector by <I><a href="#indpick">VF_indpick</a></I>; be sure to check that the return value nTrue is non-zero if you wish to do that (remember that the parameter size for any of the functions of this <I>VectorLib</I> library must be non-zero!).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>number of elements for which the condition was found to be TRUE.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cmp0">VF_cmp0</a>,&nbsp;&nbsp; <a href="#cmpC">VF_cmpC</a>,&nbsp;&nbsp; <a href="#cmpV">VF_cmpV</a>,&nbsp;&nbsp; <a href="#indpick">VF_indpick</a>,&nbsp;&nbsp; <a href="#iselementC">VF_iselementC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="comb"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_comb</b></font></td><td width="33%"><font size="+1"><b>VD_comb</b></font></td><td><font size="+1"><b>VE_comb</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initializes a vector with a comb function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_comb( fVector X, ui size, ui spac, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::comb( ui spac, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_comb( X:fVector; size:UInt; spac:Word; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X<sub>i</sub> = C, i = 0, 1*spac, 2*spac,...
<BR>X<sub>i</sub> = 0, otherwise</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If the spacing spac of the comb exceeds size, an error message &quot;Invalid parameter(s)&quot; is displayed and the program aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#equ1">VF_equ1</a>,&nbsp;&nbsp; <a href="#equ0">VF_equ0</a>,&nbsp;&nbsp; <a href="#equC">VF_equC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="complex"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_complex</b></font></td><td width="33%"><font size="+1"><b>VCD_complex</b></font></td><td><font size="+1"><b>VCE_complex</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_complex</b></font></td><td width="33%"><font size="+1"><b>VPD_complex</b></font></td><td><font size="+1"><b>VPE_complex</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Constructs a complex vector (either cartesian or polar coordinates) from its real and imaginary parts.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VCF_complex( cfVector X, fVector Re, fVector Im, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;complex&lt;T&gt;&gt;::complex( vector&lt;T&gt; Re, vector&lt;T&gt; Im );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VCF_complex( X:cfVector; Re, Im:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Identical to <I><a href="#ReImtoC">VF_ReImtoC</a>,&nbsp;&nbsp; <a href="#ReImtoC">VD_ReImtoC</a></I>, and <I><a href="#ReImtoC">VE_ReImtoC</a></I>. See these functions for details.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="conj"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_conj</b></font></td><td width="33%"><font size="+1"><b>VCD_conj</b></font></td><td><font size="+1"><b>VCE_conj</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_conj</b></font></td><td width="33%"><font size="+1"><b>VPD_conj</b></font></td><td><font size="+1"><b>VPE_conj</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the complex conjugate of a vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFmath.h&gt;
<BR>int VCF_conj( cfVector Y, cfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;complex&lt;T&gt;&gt;::conj( const vector&lt;complex&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFmath;
<BR>function VCF_conj( Y, X:cfVector; size:UInt ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Re(Y<sub>i</sub>) = Re(X<sub>i</sub>)
<BR>Im(Y<sub>i</sub>) = -Im(X<sub>i</sub>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#neg">VCF_neg</a>,&nbsp;&nbsp; <a href="#abs">VCF_abs</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="continuePlot"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_continuePlot</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Get back into the last viewport used for plotting</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void V_continuePlot( void );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure V_continuePlot;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>If one wants to add new DataPlots to an existing coordinate system after one has already defined a new viewport (e.g., for text output), this function takes one back to the most recently used coordinate system.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#getCoordSystem">V_getCoordSystem</a>,&nbsp;&nbsp; <a href="#setCoordSystem">V_setCoordSystem</a>,&nbsp;&nbsp; <a href="#setPlotRegion">V_setPlotRegion</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="convolve"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_convolve</b></font></td><td width="33%"><font size="+1"><b>VD_convolve</b></font></td><td><font size="+1"><b>VE_convolve</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Calculates the convolution of a vector with a response function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_convolve( fVector Y, fVector Flt, fVector X, fVector Rsp, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::convolve( vector&lt;T&gt; Flt, const vector&lt;T&gt;& X, const vector&lt;T&gt;& Rsp );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_convolve( Y, Flt, X, Rsp:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The convolution of X with the response function Rsp is calculated and stored in Y. A filter Flt is also calculated. If more than one vector is to be convolved with the same Rsp, use <I>VF_convolve</I> only once and use <I><a href="#filter">VF_filter</a></I> for the other vectors.
<BR>The response has to be stored in Rsp in wrap-around order: the response for zero and positive times (or whatever the independent variable is) is stored in Rsp<sub>0</sub> to Rsp<sub>size/2</sub> and the response for negative times (beginning with the most negative time) in Rsp<sub>size/2+1</sub> to Rsp<sub>size-1</sub>. You may wish to use <I><a href="#rotate">VF_rotate</a></I> or <I><a href="#reflect">VF_reflect</a></I> to achieve this wrap-around order and to construct the response vector.
<BR>Notice that Rsp has to be of the same size as X.
<P>The result of the convolution appears scaled with the sum of all elements of Rsp. Normally, therefore, Rsp should be normalized to 1.0.
<P>X, Y, Rsp, and Flt must all be of the same size, which has to be an integer power of 2. X may be overwritten by Y, Rsp may be overwritten by Flt, but X and Flt as well as Y and Rsp have to be distinct from each other.
<P>The treatment of round-off errors in the construction of Flt may be modified by <I><a href="#setRspEdit">VF_setRspEdit</a></I>.</td></tr>
<tr valign="TOP">
<td>Example C/C++</td><td><font face="courier new"><a href="#ramp">VF_ramp</a>( Time, 1024, 0.0, 1.0 );
<BR><a href="#Gauss">VF_Gauss</a>( Rsp, Time, 513, 10.0, 0.0, 1.0 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Response function for zero and positive times */
<BR><a href="#reflect">VF_reflect</a>( Rsp+1, 1023 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* ... and for negative times */
<BR><a href="#divC">VF_divC</a>( Rsp, Rsp, 1024, VF_sum( Rsp, 1024 ) );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Normalisation of Rsp */
<BR>VF_convolve( X, Rsp, X, Rsp, 1024 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Convolution; X is overwritten by the desired result
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and Rsp is overwritten by the frequency filter */
<BR><a href="#filter">VF_filter</a>( Y, Y, Rsp, 1024 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Next convolution: instead of another call to
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VF_convolve, Y is filtered using the frequency
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filter just obtained */<BR>&nbsp;</font></td></tr>
<tr valign="TOP">
<td>Example Pascal/Delphi</td><td><font face="courier new"><a href="#ramp">VF_ramp</a>( Time, 1024, 0.0, 1.0 );
<BR><a href="#Gauss">VF_Gauss</a>( Rsp, Time, 513, 10.0, 0.0, 1.0 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(* Response function for zero and positive times *)
<BR><a href="#reflect">VF_reflect</a>( VF_Pelement(Rsp,1), 1023 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(* ... and for negative times *)
<BR><a href="#divC">VF_divC</a>( Rsp, Rsp, 1024, VF_sum( Rsp, 1024 ) );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(* Normalisation of Rsp *)
<BR>VF_convolve( X, Rsp, X, Rsp, 1024 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(* Convolution; X is overwritten by the desired result and Rsp is overwritten by the frequency filter *)
<BR><a href="#filter">VF_filter</a>( Y, Y, Rsp, 1024 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(* Next convolution: instead of another call to VF_convolve, Y is filtered using the frequency filter just obtained&nbsp;&nbsp;&nbsp;*)</font><P>Mathematically, this convolution is based on the assumption that X is periodic; it still works well if X is non-periodic but converges on both ends to the same value X<sub>0</sub> = X<sub>size-1</sub>. If that is not the case, the first and the last elements of Y are spoiled by &quot;wrap-around&quot; from elements on the other side. Extrapolate X on both sides in order to imbed the original X in a larger vector, if wrap-around is a problem. The minimum number of elements to be added equals half the width of the response function. (In the case of an asymmetric response function, it is the broader wing that counts.) After convolving the larger vector with the response function, it will be the dummy elements just added which become spoiled by wrap-around. Those elements of the result vector which correspond to the original X will represent the desired convolution of X with Rsp.
<BR>If X is smoothly converging on both sides to different values, it is not necessary to employ the procedure just described. Rather, the difference between the end points may be regarded as a linear trend. In this case, remove the trend, convolve the resultant vector and add the trend to the result.</td></tr>
<tr valign="TOP">
<td>Example C/C++</td><td><font face="courier new">d = (X[size-1] - X[0]) / (size-1);
<BR><a href="#ramp">VF_ramp</a>( Trend, size, 0.0, d );
<BR><a href="#subV">VF_subV</a>( Y, X, Trend, size );
<BR>VF_convolve( Y, Flt, Y, Rsp, size );
<BR><a href="#addV">VF_addV</a>( Y, Y, Trend, size );</font></td></tr>
<tr valign="TOP">
<td>Example for treatment of end effects in Pascal/Delphi</td><td><font face="courier new"> 
d := (<a href="#element">VF_element</a>(X,size-1) - X^) / (size-1);
<BR><a href="#ramp">VF_ramp</a>( Trend, size, 0.0, d );
<BR><a href="#subV">VF_subV</a>( Y, X, Trend, size );
<BR>VF_convolve( Y, Flt, Y, Rsp, size );
<BR><a href="#addV">VF_addV</a>( Y, Y, Trend, size );</font><P>You might notice that Flt is declared as fVector rather than cfVector, although the information stored in Flt consists of complex numbers. The reason is that these numbers are stored in the packed complex format (as described for <I><a href="#FFT">VF_FFT</a></I>) which is used only in connection with Fourier-Transform operations of real vectors.
<P>About special versions with the prefixes <I>VFs_</I> and VFl_, consult <a href="HANDBOOK.HTM#chap4_8">chapter&nbsp;4.8.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If size is not a power of 2, <I><a href="#FFT">VF_FFT</a></I> (on which <I>VF_convolve</I> is based) complains &quot;Size must be an integer power of 2&quot; and the program is aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#filter">VF_filter</a>,&nbsp;&nbsp; <a href="#deconvolve">VF_deconvolve</a>,&nbsp;&nbsp; <a href="#FFT">VF_FFT</a>,&nbsp;&nbsp; <a href="#autocorr">VF_autocorr</a>,&nbsp;&nbsp; <a href="#xcorr">VF_xcorr</a>,&nbsp;&nbsp; <a href="#spectrum">VF_spectrum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="corrcoeff"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_corrcoeff</b></font></td><td width="33%"><font size="+1"><b>VD_corrcoeff</b></font></td><td><font size="+1"><b>VE_corrcoeff</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Linear correlation coefficient between two distributions</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_corrcoeff( fVector X, fVector Y, ui size, float Xmean, float Ymean );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::corrcoeff( const vector&lt;T&gt;& Y, T Xmean, T Ymean );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_corrcoeff( X, Y:fVector; size:UInt; Xmean, Ymean:Single ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The linear correlation coefficient (&quot;Pearson's r&quot;) takes on values between -1.0 and +1.0. The mean values of both distributions must be known. They are passed to <I>VF_corrcoeff</I> as the parameters Xmean and Ymean.</td></tr>
<tr valign="TOP">
<td>Example C/C++</td><td><font face="courier new">r = VF_corrcoeff( X, Y, n, <a href="#mean">VF_mean</a>( X, n ), VF_mean( Y, n ) );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>linear correlation coefficient r</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mean">VF_mean</a>,&nbsp;&nbsp; <a href="#varianceV">VF_varianceV</a>,&nbsp;&nbsp; <a href="#linregress">VF_linregress</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cos"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cos</b></font></td><td width="33%"><font size="+1"><b>VD_cos</b></font></td><td><font size="+1"><b>VE_cos</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_cos</b></font></td><td width="33%"><font size="+1"><b>VDx_cos</b></font></td><td><font size="+1"><b>VEx_cos</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFr_cos</b></font></td><td width="33%"><font size="+1"><b>VDr_cos</b></font></td><td><font size="+1"><b>VEr_cos</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFrx_cos</b></font></td><td width="33%"><font size="+1"><b>VDrx_cos</b></font></td><td><font size="+1"><b>VErx_cos</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_cos</b></font></td><td width="33%"><font size="+1"><b>VCD_cos</b></font></td><td><font size="+1"><b>VCE_cos</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_cos</b></font></td><td width="33%"><font size="+1"><b>VCDx_cos</b></font></td><td><font size="+1"><b>VCEx_cos</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Cosine function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_cos( fVector Y, fVector X, ui size );
<BR>int VFx_cos( fVector Y, fVector X, ui size, float A, float B, float C );
<BR>int VFr_cos( fVector Y, fVector X, ui size );
<BR>int VFrx_cos( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::cos( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_cos( const vector&lt;T&gt;& X, T A, T B, T C );
<BR>int vector&lt;T&gt;::r_cos( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::rx_cos( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_cos( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_cos( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;
<BR>function VFr_cos( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFrx_cos( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = cos ( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * cos ( A*X<sub>i</sub> + B )
<BR>For large values of X<sub>i</sub>, round-off error becomes appreciable; if the X<sub>i</sub> values are representable as rational multiples of <font face="symbol">p</font>, it is better to use <I><a href="#cosrpi">VF_cosrpi</a></I> than <I>VF_cos</I>.
<BR>If, on the other hand, one can be sure that all X<sub>i</sub> are within the range -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT>, one can employ the faster reduced-range versions with the prefixes <I>VFr_</I> and <I>VFrx_</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Precision errors in the real-value functions lead to a default result of 1.0 (as if the input were 0.0) and to a non-zero return value, but are otherwise ignored; <I>_matherr</I> is not called.
<BR>OVERFLOW errors can only occur in the complex versions and lead to a result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cos2">VF_cos2</a>,&nbsp;&nbsp; <a href="#cosrpi">VF_cosrpi</a>,&nbsp;&nbsp; <a href="#sin">VF_sin</a>,&nbsp;&nbsp; <a href="#cosh">VF_cosh</a>,&nbsp;&nbsp; <a href="#acos">VF_acos</a>,&nbsp;&nbsp; cos</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cos2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cos2</b></font></td><td width="33%"><font size="+1"><b>VD_cos2</b></font></td><td><font size="+1"><b>VE_cos2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_cos2</b></font></td><td width="33%"><font size="+1"><b>VDx_cos2</b></font></td><td><font size="+1"><b>VEx_cos2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFr_cos2</b></font></td><td width="33%"><font size="+1"><b>VDr_cos2</b></font></td><td><font size="+1"><b>VEr_cos2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFrx_cos2</b></font></td><td width="33%"><font size="+1"><b>VDrx_cos2</b></font></td><td><font size="+1"><b>VErx_cos2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Square of the cosine function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_cos2( fVector Y, fVector X, ui size );
<BR>int VFx_cos2( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::cos2( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_cos2( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_cos2( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_cos2( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = cos<sup>2</sup>( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * cos<sup>2</sup>( A*X<sub>i</sub> + B )
<BR>Calculating the squared trigonometric functions directly is faster and sometimes more accurate than first calculating the trigonometric function itself and squaring it afterwards. The reduced-range versions with the prefixes <I>VFr_</I> and <I>VFrx_</I> are for situations in which one can be sure that all input values lie in the range -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Precision errors lead to a default result of 1.0 (as if the input were 0.0) and a non-zero return value, but are otherwise ignored; <I>_matherr</I> is not called.
<BR>OVERFLOW errors can only occur in the complex versions and lead to a result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cos">VF_cos</a>,&nbsp;&nbsp; <a href="#cosrpi">VF_cosrpi</a></I>,&nbsp;&nbsp;cos</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cosec"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cosec</b></font></td><td width="33%"><font size="+1"><b>VD_cosec</b></font></td><td><font size="+1"><b>VE_cosec</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_cosec</b></font></td><td width="33%"><font size="+1"><b>VDx_cosec</b></font></td><td><font size="+1"><b>VEx_cosec</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Cosecant function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_cosec( fVector Y, fVector X, ui size );
<BR>int VFx_cosec( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::cosec( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_cosec( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_cosec( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_cosec( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = cosec ( X<sub>i</sub> ) = 1.0 / sin ( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * cosec ( A*X<sub>i</sub> + B )
<BR>The cosecant is defined as the inverse of the sine (not to be mistaken for the arcus function arcsin!) For large values of X<sub>i</sub>, round-off error becomes appreciable; if the X<sub>i</sub> values are representable as rational multiples of <font face="symbol">p</font>, it is better to use <I><a href="#cosecrpi">VF_cosecrpi</a></I> than <I>VF_cosec</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>For TLOSS precision errors, the default result is arbitrarily set to 1.0 (as an exception from the general rule which would require the result to be the mean of the results for +0 and -0. This would be 0.0. However, zero is not a valid result for the cosecant function). For SING and OVERFLOW errors, the default result is &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cosec2">VF_cosec2</a>,&nbsp;&nbsp; <a href="#cosecrpi">VF_cosecrpi</a>,&nbsp;&nbsp; <a href="#sin">VF_sin</a>,&nbsp;&nbsp; <a href="#cosech">VF_cosech</a>,&nbsp;&nbsp; sin</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cosec2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cosec2</b></font></td><td width="33%"><font size="+1"><b>VD_cosec2</b></font></td><td><font size="+1"><b>VE_cosec2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_cosec2</b></font></td><td width="33%"><font size="+1"><b>VDx_cosec2</b></font></td><td><font size="+1"><b>VEx_cosec2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Square of the cosecant function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_cosec2( fVector Y, fVector X, ui size );
<BR>int VFx_cosec2( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::cosec2( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_cosec2( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_cosec2( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_cosec2( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = cosec<sup>2</sup> ( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * cosec<sup>2</sup> ( A*X<sub>i</sub> + B )
<BR>Calculating the squared trigonometric functions directly is faster and sometimes more accurate than first calculating the trigonometric function itself and squaring it afterwards.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>For SING, OVERFLOW, and TLOSS errors, the default result is &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cosec">VF_cosec</a>,&nbsp;&nbsp; <a href="#cosecrpi">VF_cosecrpi</a></I>,&nbsp;&nbsp;sin</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cosech"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cosech</b></font></td><td width="33%"><font size="+1"><b>VD_cosech</b></font></td><td><font size="+1"><b>VE_cosech</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_cosech</b></font></td><td width="33%"><font size="+1"><b>VDx_cosech</b></font></td><td><font size="+1"><b>VEx_cosech</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Hyperbolic cosecant function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_cosech( fVector Y, fVector X, ui size );
<BR>int VFx_cosech( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::cosech( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_cosech( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_cosech( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_cosech( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = cosech ( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * cosech ( A*X<sub>i</sub>+B )</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>SING errors lead to a default result of 0 (mean of +HUGE_VAL and -HUGE_VAL); OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sinh">VF_sinh</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; sinh</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cosecrpi"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cosecrpi</b></font></td><td width="33%"><font size="+1"><b>VD_cosecrpi</b></font></td><td><font size="+1"><b>VE_cosecrpi</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cosecrpi2</b></font></td><td width="33%"><font size="+1"><b>VD_cosecrpi2</b></font></td><td><font size="+1"><b>VE_cosecrpi2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cosecrpi3</b></font></td><td width="33%"><font size="+1"><b>VD_cosecrpi3</b></font></td><td><font size="+1"><b>VE_cosecrpi3</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Cosecant function of fractional multiples of <font face="symbol">p</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_cosecrpi( fVector Y, iVector P, ui size, int q );
<BR>int VF_cosecrpi2( fVector Y, iVector P, ui size, int q );
<BR>int VF_cosecrpi3( fVector Y, iVector P, ui size, int q );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::cosecrpi( const vector&lt;int&gt;& P, int q );
<BR>int vector&lt;T&gt;::cosecrpi2( const vector&lt;int&gt;& P, int q );
<BR>int vector&lt;T&gt;::cosecrpi3( const vector&lt;int&gt;& P, int q );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_cosecrpi( Y:fVector; P:iVector; size:UInt; q:Integer ): IntBool;
<BR>function VF_cosecrpi2( Y:fVector; P:iVector; size:UInt; q:Integer ): IntBool;
<BR>function VF_cosecrpi3( Y:fVector; P:iVector; size:UInt; q:Integer ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = cosec( (P<sub>i</sub> / q) * <font face="symbol">p</font> )
<BR>The cosecant of fractional multiples of <font face="symbol">p</font> is calculated. There are three versions: <I>VF_cosecrpi</I> is for general use with any arbitrary denominator q. If q is a power of 2, <I>VF_cosecrpi2</I> should be used which is a highly optimized version using a look-up table. If q is a multiple of 3, <I>VF_cosecrpi3</I> should be used. <I>VF_cosecrpi2</I> and <I>VF_cosecrpi3</I> work also with q values they are not optimized for; in this case, however, memory space is wasted for the tables.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>SING errors occur if P<sub>i</sub> / q is exactly an integer number; the default result is 0.0 (which is the mean of +HUGE_VAL and -HUGE_VAL; in contrast to <I><a href="#cosec">VF_cosec</a></I>, 0.0 is chosen irrespective of the fact that it is not a valid result of the cosecant function); q must be non-zero; this is, however, not tested for.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cosec">VF_cosec</a>,&nbsp;&nbsp; sin</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cosectab2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cosectab2</b></font></td><td width="33%"><font size="+1"><b>VD_cosectab2</b></font></td><td><font size="+1"><b>VE_cosectab2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cosectab3</b></font></td><td width="33%"><font size="+1"><b>VD_cosectab3</b></font></td><td><font size="+1"><b>VE_cosectab3</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">&nbsp;</TD><td>Table of cosecant values for arguments between 0 and <font face="symbol">p</font>/2.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;xmath.h&gt;
<BR>extern float&nbsp;&nbsp;&nbsp;&nbsp;VF_cosectab2[ VF_tabsz2+1 ];
<BR>extern double&nbsp;&nbsp;&nbsp;VD_cosectab2[ VD_tabsz2+1 ];
<BR>extern extended&nbsp;VE_cosectab2[ VE_tabsz2+1 ];
<BR>extern float&nbsp;&nbsp;&nbsp;&nbsp;VF_cosectab3[ VF_tabsz3+1 ];
<BR>extern double&nbsp;&nbsp;&nbsp;VD_cosectab3[ VD_tabsz3+1 ];
<BR>extern extended&nbsp;VE_cosectab3[ VE_tabsz3+1 ];</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses FCSCTAB3, DCSCTAB3, ECSCTAB3;
<BR>VF_cosectab2: array[0..VF_tabsz2] of Single;
<BR>VD_cosectab2: array[0..VD_tabsz2] of Double;
<BR>VE_cosectab2: array[0..VE_tabsz2] of Extended;
<BR>VF_cosectab3: array[0..VF_tabsz3] of Single;
<BR>VD_cosectab3: array[0..VD_tabsz3] of Double;
<BR>VE_cosectab3: array[0..VE_tabsz3] of Extended;
<BR></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><font face="courier new"> VF_cosectab2[ i ] = cosec ( i/(2*VF_tabsz2) * <font face="symbol">p</font> ), &nbsp;&nbsp;&nbsp;i=0,...,VF_tabsz2-1
<BR>VF_cosectab3[ i ] = cosec ( i/(2*VF_tabsz3) * <font face="symbol">p</font> ), &nbsp;&nbsp;&nbsp;i=0,...,VF_tabsz3-1
<BR>VF_cosectab2[ VF_tabsz2 ] = VF_cosectab3[ VF_tabsz3 ] = 0</font>
<BR>These look-up tables of cosecant values for arguments between 0 and <font face="symbol">p</font>/2 are used by VF_cosecrpi2 and the other functions of that family and are also available to the user. Since the cosecant of <font face="symbol">p</font>/2 is not defined, zero is stored at its place.
<BR>C/C++: The symbols VF_tabsz2 etc., denoting the size of the tables, are defined in &lt;xmath.h&gt;.
<BR>Pascal/Delphi: The symbols VF_tabsz2 etc. are defined in the same units as the tables themselves.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cosh"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cosh</b></font></td><td width="33%"><font size="+1"><b>VD_cosh</b></font></td><td><font size="+1"><b>VE_cosh</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_cosh</b></font></td><td width="33%"><font size="+1"><b>VDx_cosh</b></font></td><td><font size="+1"><b>VEx_cosh</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_cosh</b></font></td><td width="33%"><font size="+1"><b>VCD_cosh</b></font></td><td><font size="+1"><b>VCE_cosh</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_cosh</b></font></td><td width="33%"><font size="+1"><b>VCDx_cosh</b></font></td><td><font size="+1"><b>VCEx_cosh</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Hyperbolic cosine</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_cosh( fVector Y, fVector X, ui size );
<BR>int VFx_cosh( fVector Y, fVector X, ui size, float A, float B, float C );
<BR>int VCF_cosh( cfVector Y, cfVector X, ui size );
<BR>int VCFx_cosh( cfVector Y, cfVector X, ui size, fComplex A, fComplex B, fComplex C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::cosh( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_cosh( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_cosh( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_cosh( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = cosh ( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * cosh ( A*X<sub>i</sub>+B )</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sinh">VF_sinh</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a></I>,&nbsp;&nbsp;cosh</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cosrpi"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cosrpi</b></font></td><td width="33%"><font size="+1"><b>VD_cosrpi</b></font></td><td><font size="+1"><b>VE_cosrpi</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cosrpi2</b></font></td><td width="33%"><font size="+1"><b>VD_cosrpi2</b></font></td><td><font size="+1"><b>VE_cosrpi2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cosrpi3</b></font></td><td width="33%"><font size="+1"><b>VD_cosrpi3</b></font></td><td><font size="+1"><b>VE_cosrpi3</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Cosine function of fractional multiples of <font face="symbol">p</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_cosrpi( fVector Y, iVector P, ui size, int q );
<BR>int VF_cosrpi2( fVector Y, iVector P, ui size, int q );
<BR>int VF_cosrpi3( fVector Y, iVector P, ui size, int q );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::cosrpi( const vector&lt;int&gt;& P, int q );
<BR>int vector&lt;T&gt;::cosrpi2( const vector&lt;int&gt;& P, int q );
<BR>int vector&lt;T&gt;::cosrpi3( const vector&lt;int&gt;& P, int q );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_cosrpi( Y:fVector; P:iVector; size:UInt; q:Integer ): IntBool;
<BR>function VF_cosrpi2( Y:fVector; P:iVector; size:UInt; q:Integer ): IntBool;
<BR>function VF_cosrpi3( Y:fVector; P:iVector; size:UInt; q:Integer ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = cos( (P<sub>i</sub> / q) * <font face="symbol">p</font> )
<BR>The cosine of fractional multiples of <font face="symbol">p</font> is calculated. There are three versions: <I>VF_cosrpi</I> is for general use with any arbitrary denominator q. If q is a power of 2, <I>VF_cosrpi2</I> should be used which is a highly optimized version reading the results from a look-up table, if possible. If q is a multiple of 3, <I>VF_cosrpi3</I> should be used. <I>VF_cosrpi3</I> offers a convenient way to use degrees instead of radians; if, for example, q is 180, the unit of the elements of P is &quot;degree&quot;. <I>VF_cosrpi2</I> and <I>VF_cosrpi3</I> work also with q values they are not optimized for; in this case, however, memory space is wasted for the tables.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>These functions are error-proof, as long as q != 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cos">VF_cos</a>,&nbsp;&nbsp; cos</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cot"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cot</b></font></td><td width="33%"><font size="+1"><b>VD_cot</b></font></td><td><font size="+1"><b>VE_cot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_cot</b></font></td><td width="33%"><font size="+1"><b>VDx_cot</b></font></td><td><font size="+1"><b>VEx_cot</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Cotangent function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_cot( fVector Y, fVector X, ui size );
<BR>int VFx_cot( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::cot( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_cot( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_cot( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_cot( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = cot ( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * cot ( A*X<sub>i</sub>+B )
<BR>The cotangent is defined as the inverse of the tangent (not to be mistaken for the arcus function arctan!) For large values of X<sub>i</sub>, round-off error becomes appreciable; if the X<sub>i</sub> values are representable as rational multiples of <font face="symbol">p</font>, it is better to use <I><a href="#cotrpi">VF_cotrpi</a></I> than <I>VF_cot</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>For TLOSS precision errors, the default result is 0.0 (which is the mean of +HUGE_VAL and -HUGE_VAL); for SING and OVERFLOW errors, the default result is &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cot2">VF_cot2</a>,&nbsp;&nbsp; <a href="#cotrpi">VF_cotrpi</a>,&nbsp;&nbsp; <a href="#coth">VF_coth</a>,&nbsp;&nbsp; <a href="#atan">VF_atan</a>,&nbsp;&nbsp; <a href="#atan2">VF_atan2</a>,&nbsp;&nbsp; tan</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cot2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cot2</b></font></td><td width="33%"><font size="+1"><b>VD_cot2</b></font></td><td><font size="+1"><b>VE_cot2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_cot2</b></font></td><td width="33%"><font size="+1"><b>VDx_cot2</b></font></td><td><font size="+1"><b>VEx_cot2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Square of the cotangent function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_cot2( fVector Y, fVector X, ui size );
<BR>int VFx_cot2( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::cot2( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_cot2( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_cot2( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_cot2( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = cot<sup>2</sup>( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * cot<sup>2</sup>( A*X<sub>i</sub>+B )
<BR>Calculating the squared trigonometric functions directly is faster and sometimes more accurate than first calculating the trigonometric function itself and squaring it afterwards.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>For SING, OVERFLOW and TLOSS errors, the default result is +HUGE_VAL (multiplied by the sign of C in the expanded versions).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cot">VF_cot</a>,&nbsp;&nbsp; <a href="#cotrpi">VF_cotrpi</a>,&nbsp;&nbsp; tan</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="coth"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_coth</b></font></td><td width="33%"><font size="+1"><b>VD_coth</b></font></td><td><font size="+1"><b>VE_coth</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_coth</b></font></td><td width="33%"><font size="+1"><b>VDx_coth</b></font></td><td><font size="+1"><b>VEx_coth</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Hyperbolic cotangent function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_coth( fVector Y, fVector X, ui size );
<BR>int VFx_coth( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::coth( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_coth( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_coth( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_coth( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = coth ( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * coth ( A*X<sub>i</sub>+B )</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>SING errors lead to a default result of 0.0 (the mean of +HUGE_VAL and -HUGE_VAL); OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sinh">VF_sinh</a>,&nbsp;&nbsp; <a href="#tanh">VF_tanh</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; tanh</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cotrpi"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cotrpi</b></font></td><td width="33%"><font size="+1"><b>VD_cotrpi</b></font></td><td><font size="+1"><b>VE_cotrpi</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cotrpi2</b></font></td><td width="33%"><font size="+1"><b>VD_cotrpi2</b></font></td><td><font size="+1"><b>VE_cotrpi2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cotrpi3</b></font></td><td width="33%"><font size="+1"><b>VD_cotrpi3</b></font></td><td><font size="+1"><b>VE_cotrpi3</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Cotangent function of rational multiples of <font face="symbol">p</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_cotrpi( fVector Y, iVector P, ui size, int q );
<BR>int VF_cotrpi2( fVector Y, iVector P, ui size, int q );
<BR>int VF_cotrpi3( fVector Y, iVector P, ui size, int q );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::cotrpi( const vector&lt;int&gt;& P, int q );
<BR>int vector&lt;T&gt;::cotrpi2( const vector&lt;int&gt;& P, int q );
<BR>int vector&lt;T&gt;::cotrpi3( const vector&lt;int&gt;& P, int q );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_cotrpi( Y:fVector; P:iVector; size:UInt; q:Integer ): IntBool;
<BR>function VF_cotrpi2( Y:fVector; P:iVector; size:UInt; q:Integer ): IntBool;
<BR>function VF_cotrpi3( Y:fVector; P:iVector; size:UInt; q:Integer ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = cot( (P<sub>i</sub> / q) * <font face="symbol">p</font> )
<BR>The cotangent of fractional multiples of <font face="symbol">p</font> is calculated. There are three versions: <I>VF_cotrpi</I> is for general use with any arbitrary denominator q. If q is a power of 2, <I>VF_cotrpi2</I> should be used which is a highly optimized version using a look-up table. If q is a multiple of 3, <I>VF_cotrpi3</I> should be used. <I>VF_cotrpi2</I> and <I>VF_cotrpi3</I> also work with q values they are not optimized for; in this case, however, memory space is wasted for the tables.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>SING errors occur if P<sub>i</sub> / q is a whole number. The default result is 0.0 (which is the mean of +HUGE_VAL and -HUGE_VAL); q must be non-zero; this is, however, not tested for.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cot">VF_cot</a>,&nbsp;&nbsp; tan</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cprint"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cprint</b></font></td><td width="33%"><font size="+1"><b>VD_cprint</b></font></td><td><font size="+1"><b>VE_cprint</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_cprint</b></font></td><td width="33%"><font size="+1"><b>VCD_cprint</b></font></td><td><font size="+1"><b>VCE_cprint</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_cprint</b></font></td><td width="33%"><font size="+1"><b>VPD_cprint</b></font></td><td><font size="+1"><b>VPE_cprint</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_cprint</b></font></td><td width="20%"><font size="+1"><b>VBI_cprint</b></font></td><td width="20%"><font size="+1"><b>VSI_cprint</b></font></td><td width="20%"><font size="+1"><b>VLI_cprint</b></font></td><td><font size="+1"><b>VQI_cprint</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_cprint</b></font></td><td width="20%"><font size="+1"><b>VUB_cprint</b></font></td><td width="20%"><font size="+1"><b>VUS_cprint</b></font></td><td width="20%"><font size="+1"><b>VUL_cprint</b></font></td><td><font size="+1"><b>VUI_cprint</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>print a vector to the screen. Only DOS and Win32 console applications; not for Visual C++.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_cprint( fVector X, ui size, unsigned nperline );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::cprint( unsigned nperline );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_cprint( X:fVector; size, nperline:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>size elements of X are printed to the screen (or &quot;console&quot;), into the actual text window, nperline elements in each line.
<P>The display starts always with a new line. Please note that this may lead to an empty line at the beginning.
<BR>Each line begins with the index of the first element printed into that line. The index is followed by a colon and by the requested nperline elements.
<BR>Cartesian complex numbers are printed in braces, with the real and imaginary parts separated by a komma: {Re, Im}. Polar complex numbers are also written in braces, with the Mag and Arg parts separated by an at-sign: {Mag @ Arg}.
<P>The display pauses every screenful. The user is prompted after each page to continue or to stop printing.
<BR>The number of digits per element is determined by the available space, which depends in turn on the line width and on the parameter nperline.
<P>This family of functions is available only for DOS and Win32 console applications. It should not be used within TurboVision DOS programs.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If nperline exceeds the maximum number of entries possible in the current text mode, an error message &quot;Cannot use requested format (too many entries per line)!&quot; is generated; in this case, the program chooses the maximum number nperline that is possible.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#fprint">VF_fprint</a>,&nbsp;&nbsp; <a href="#print">VF_print</a>,&nbsp;&nbsp; <a href="#write">VF_write</a>,&nbsp;&nbsp; <a href="#store">VF_store</a>,&nbsp;&nbsp; cprintf</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="CtoAbs"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_CtoAbs</b></font></td><td width="33%"><font size="+1"><b>VD_CtoAbs</b></font></td><td><font size="+1"><b>VE_CtoAbs</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Absolute value (magnitude) of cartesian complex numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VF_CtoAbs( fVector Abs, cfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::CtoAbs( const vector&lt;complex&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VF_CtoAbs( Abs:fVector; X:cfVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Abs<sub>i</sub> = sqrt( Re<sup>2</sup>(X<sub>i</sub>) + Im<sup>2</sup>(X<sub>i</sub>) )
<BR>The absolute value, i.e. the magnitude of each element of the complex vector X is calculated. This function is almost identical to <I><a href="#abs">VCF_abs</a></I>, but does not perform any error handling.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#abs">VCF_abs</a>,&nbsp;&nbsp; <a href="#PolartoC">VF_PolartoC</a>,&nbsp;&nbsp; <a href="#CtoReIm">VF_CtoReIm</a>,&nbsp;&nbsp; <a href="#CtoArg">VF_CtoArg</a>,&nbsp;&nbsp; <a href="#CtoNorm">VF_CtoNorm</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="CtoArg"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_CtoArg</b></font></td><td width="33%"><font size="+1"><b>VD_CtoArg</b></font></td><td><font size="+1"><b>VE_CtoArg</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Argument (angle) of cartesian-complex numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VF_CtoArg( fVector Arg, cfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::CtoArg( const vector&lt;complex&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VF_CtoArg( Arg:fVector; X:cfVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Arg<sub>i</sub> = arctan( Im(X<sub>i</sub>) / Re(X<sub>i</sub>) )
<BR>The argument, i.e. the angle of each element of the complex vector X is calculated. For Cartesian coordinates {0, 0}, the angle is arbitrary and is set to zero.
<BR>When necessary, depending on the signs of Re(X<sub>i</sub>) and Im(X<sub>i</sub>), <font face="symbol">p</font> is added or subtracted from the arctan to obtain the correct quadrant.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PolartoC">VF_PolartoC</a>,&nbsp;&nbsp; <a href="#CtoPolar">VF_CtoPolar</a>,&nbsp;&nbsp; <a href="#atan2">VF_atan2</a>,&nbsp;&nbsp; <a href="#CtoAbs">VF_CtoAbs</a>,&nbsp;&nbsp; <a href="#CtoReIm">VF_CtoReIm</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="CtoIm"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_CtoIm</b></font></td><td width="33%"><font size="+1"><b>VD_CtoIm</b></font></td><td><font size="+1"><b>VE_CtoIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Extract the imaginary part from a cartesian-complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VF_CtoIm( fVector Im, cfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::CtoIm( const vector&lt;complex&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VF_CtoIm( Im:fVector; X:cfVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The imaginary part of the complex vector X is extracted and stored in Im.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#CtoReIm">VF_CtoReIm</a>,&nbsp;&nbsp; <a href="#ReImtoC">VF_ReImtoC</a>,&nbsp;&nbsp; <a href="#ImtoC">VF_ImtoC</a>,&nbsp;&nbsp; <a href="#PolartoC">VF_PolartoC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="CtoNorm"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_CtoNorm</b></font></td><td width="33%"><font size="+1"><b>VD_CtoNorm</b></font></td><td><font size="+1"><b>VE_CtoNorm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Norm (square of the absolute value) of cartesian-complex numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VF_CtoNorm( fVector Norm, cfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::CtoNorm( const vector&lt;complex&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VF_CtoNorm( Norm:fVector; X:cfVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Norm<sub>i</sub> = Re<sup>2</sup>(X<sub>i</sub>) + Im<sup>2</sup>(X<sub>i</sub>)
<BR>This definition of the Norm of a complex number is the same as in C++, but it is not consistent with the usual definition in mathematics, where the term &quot;norm&quot; is used as a synomym for &quot;absolute value&quot; or &quot;magnitude&quot;. As defined here, the Norm is the square of the absolute value. The absolute value itself is available by the functions <I><a href="#CtoAbs">VF_CtoAbs</a></I> (without error handling) and <I><a href="#abs">VCF_abs</a></I> (with error handling).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PolartoC">VF_PolartoC</a>,&nbsp;&nbsp; <a href="#CtoReIm">VF_CtoReIm</a>,&nbsp;&nbsp; <a href="#CtoArg">VF_CtoArg</a>,&nbsp;&nbsp; <a href="#CtoAbs">VF_CtoAbs</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="CtoP"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_CtoP</b></font></td><td width="33%"><font size="+1"><b>VD_CtoP</b></font></td><td><font size="+1"><b>VE_CtoP</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Transformation of a cartesian complex into a polar complex vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_CtoP( pfVector Y, cfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;polar&lt;T&gt;&gt;::CtoP( const vector&lt;complex&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_CtoP( Y:pfVector; X:cfVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X is transformed from cartesian coordinates {Re, Im} into polar coordinates {Mag @ Arg}.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#CtoPolar">VF_CtoPolar</a>,&nbsp;&nbsp; <a href="#PtoC">VF_PtoC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="CtoPolar"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_CtoPolar</b></font></td><td width="33%"><font size="+1"><b>VD_CtoPolar</b></font></td><td><font size="+1"><b>VE_CtoPolar</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Transformation of complex numbers from Cartesian into polar coordinates, stored in separate vectors Mag and Arg.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VF_CtoPolar( fVector Mag, fVector Arg, cfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::CtoPolar( vector&lt;T&gt; Arg, const vector&lt;complex&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VF_CtoPolar( Mag, Arg:fVector; X:cfVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The polar coordinates Mag (magnitude, absolute value) and Arg (argument, angle) of each element of the Cartesian complex vector X are calculated. For the Cartesian coordinates {0, 0}, the polar coordinates are also set to {0 @ 0}.
<BR>This function is similar to <I><a href="#CtoP">VF_CtoP</a></I>, with the exception that Mag and Arg are stored in separate vectors instead of one polar complex vector, as in <I><a href="#CtoP">VF_CtoP</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#CtoP">VF_CtoP</a>,&nbsp;&nbsp; <a href="#PolartoC">VF_PolartoC</a>,&nbsp;&nbsp; <a href="#CtoReIm">VF_CtoReIm</a>,&nbsp;&nbsp; <a href="#CtoAbs">VF_CtoAbs</a>,&nbsp;&nbsp; <a href="#CtoArg">VF_CtoArg</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="CtoRe"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_CtoRe</b></font></td><td width="33%"><font size="+1"><b>VD_CtoRe</b></font></td><td><font size="+1"><b>VE_CtoRe</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Extracts the real part from a cartesian-complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VF_CtoRe( fVector Re, cfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::CtoRe( const vector&lt;complex&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VF_CtoRe( Re:fVector; X:cfVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The real part of the complex vector X is extracted and stored in Re.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#CtoReIm">VF_CtoReIm</a>,&nbsp;&nbsp; <a href="#ReImtoC">VF_ReImtoC</a>,&nbsp;&nbsp; <a href="#RetoC">VF_RetoC</a>,&nbsp;&nbsp; <a href="#PolartoC">VF_PolartoC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="CtoReIm"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_CtoReIm</b></font></td><td width="33%"><font size="+1"><b>VD_CtoReIm</b></font></td><td><font size="+1"><b>VE_CtoReIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Extracts the real and imaginary parts from a cartesian-complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VF_CtoReIm( fVector Re, fVector Im, cfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::CtoReIm( vector&lt;T&gt; Im, const vector&lt;complex&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VF_CtoReIm( Re, Im:fVector; X:cfVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The real and imaginary parts of the complex vector X are extracted and stored in Re and Im, resp.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#CtoRe">VF_CtoRe</a>,&nbsp;&nbsp; <a href="#ReImtoC">VF_ReImtoC</a>,&nbsp;&nbsp; <a href="#RetoC">VF_RetoC</a>,&nbsp;&nbsp; <a href="#PolartoC">VF_PolartoC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="cubic"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_cubic</b></font></td><td width="33%"><font size="+1"><b>VD_cubic</b></font></td><td><font size="+1"><b>VE_cubic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_cubic</b></font></td><td width="33%"><font size="+1"><b>VDx_cubic</b></font></td><td><font size="+1"><b>VEx_cubic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFu_cubic</b></font></td><td width="33%"><font size="+1"><b>VDu_cubic</b></font></td><td><font size="+1"><b>VEu_cubic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFux_cubic</b></font></td><td width="33%"><font size="+1"><b>VDux_cubic</b></font></td><td><font size="+1"><b>VEux_cubic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_cubic</b></font></td><td width="33%"><font size="+1"><b>VCD_cubic</b></font></td><td><font size="+1"><b>VCE_cubic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_cubic</b></font></td><td width="33%"><font size="+1"><b>VCDx_cubic</b></font></td><td><font size="+1"><b>VCEx_cubic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFu_cubic</b></font></td><td width="33%"><font size="+1"><b>VCDu_cubic</b></font></td><td><font size="+1"><b>VCEu_cubic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFux_cubic</b></font></td><td width="33%"><font size="+1"><b>VCDux_cubic</b></font></td><td><font size="+1"><b>VCEux_cubic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_cubic</b></font></td><td width="33%"><font size="+1"><b>VPD_cubic</b></font></td><td><font size="+1"><b>VPE_cubic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPFu_cubic</b></font></td><td width="33%"><font size="+1"><b>VPDu_cubic</b></font></td><td><font size="+1"><b>VPEu_cubic</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Cubic (third power)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_cubic( fVector Y, fVector X, ui size );
<BR>int VFx_cubic( fVector Y, fVector X, ui size, float A, float B );
<BR>int VFu_cubic( fVector Y, fVector X, ui size );
<BR>int VFux_cubic( fVector Y, fVector X, ui size, float A, float B );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::cubic( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_cubic( const vector&lt;T&gt;& X, T A, T B );
<BR>int vector&lt;T&gt;::u_cubic( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::ux_cubic( const vector&lt;T&gt;& X, T A, T B );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_cubic( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_cubic( Y, X:fVector; size:UInt; A, B:Single ): IntBool;
<BR>function VFu_cubic( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFux_cubic( Y, X:fVector; size:UInt; A, B:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = (X<sub>i</sub>)<sup>3</sup>
<BR>expanded versions: Y<sub>i</sub> = (A*X<sub>i</sub>+B)<sup>3</sup>
<P>&quot;unprotected&quot; versions (prefix <I>VFu_,&nbsp;&nbsp; VFux_</I>, etc.):
<BR>These functions do not perform any error handling, which makes them much faster (up to 50%) than the standard versions. The extended-precision complex (<I>VCEu_</I> and <I>VCEux_</I>) versions do not take some of the security measures present in the standard version and might fail for results very near the overflow limit; results near the underflow limit might be rendered as 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#square">VF_square</a>,&nbsp;&nbsp; <a href="#quartic">VF_quartic</a>,&nbsp;&nbsp; <a href="#sqrt">VF_sqrt</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#ipow">VF_ipow</a>,&nbsp;&nbsp; <a href="#poly">VF_poly</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="dataPlot"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_dataPlot</b></font></td><td width="33%"><font size="+1"><b>VCD_dataPlot</b></font></td><td><font size="+1"><b>VCE_dataPlot</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Plot of a complex vector into an existing Cartesian complex plane.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void VCF_dataPlot( cfVector X, ui size, unsigned form, COLORREF color );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;complex&lt;T&gt;&gt;::dataPlot( unsigned form, COLORREF color );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure VCF_dataPlot( X:cfVector; size, form:UInt; color:COLORREF );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector X is plotted into a Cartesian complex plane that has been drawn previously by a call to either <I><a href="#autoPlot">VCF_autoPlot</a></I>, or <I><a href="#2AutoPlot">VCF_2AutoPlot</a></I> or <I><a href="#drawAxes">V_drawAxes</a></I>.
<BR>For a description of the parameters form and color, see <I><a href="#xyAutoPlot">VF_xyAutoPlot</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#autoPlot">VCF_autoPlot</a>,&nbsp;&nbsp; <a href="#2AutoPlot">VCF_2AutoPlot</a>,&nbsp;&nbsp; <a href="#xyAutoPlot">VF_xyAutoPlot</a></I>,&nbsp;&nbsp;<a href="HANDBOOK.HTM#chap4_12">chapter&nbsp;4.12</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="deconvolve"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_deconvolve</b></font></td><td width="33%"><font size="+1"><b>VD_deconvolve</b></font></td><td><font size="+1"><b>VE_deconvolve</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Deconvolution</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_deconvolve( fVector Y, fVector Flt, fVector X, fVector Rsp, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::deconvolve( vector&lt;T&gt; Flt, const vector&lt;T&gt;& X, const vector&lt;T&gt;& Rsp );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_deconvolve( Y, Flt, X, Rsp:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X is assumed to be the result of a convolution of some &quot;true&quot; profile with the response function Rsp; a deconvolution is attempted and stored in Y. A filter Flt is also calculated; if more than one vector is to be deconvolved with the same Rsp, use <I>VF_deconvolve</I> only once and use the filter Flt thus obtained to deconvolve other vectors by calling <I><a href="#filter">VF_filter</a></I>. The response has to be stored in Rsp in wrap-around order: the elements for zero and positive times (or whatever the independent variable is) are stored as Rsp<sub>0</sub> to Rsp<sub>size/2</sub> and the elements for negative times as Rsp<sub>size/2+1</sub> to Rsp<sub>size-1</sub>.
<BR>You may wish to use <I><a href="#rotate">VF_rotate</a></I> or <I><a href="#reflect">VF_reflect</a></I> to obtain the correct order when constructing the response vector.
<P>X, Y, Rsp, and Flt must all be of the same size, which has to be an integer power of 2. X may be overwritten by Y, Rsp may be overwritten by Flt, but X and Flt as well as Y and Rsp have to be distinct from each other.
<P>Mathematically, Flt is the inverse of the Fourier transform of Rsp. If the Fourier transform of Rsp contains elements equal to zero, all information is lost for the respective frequency and no reconstruction is possible. The best one can do in this case is to accept this loss and to deconvolve only up to those frequencies where still something is left to be reconstructed.
<BR>You are therefore advised not to use this function blindly but rather to inspect the Fourier transform of Rsp and decide what to do on the basis of your specific application. If you wish to use this function nevertheless, you may rely on the automatic editing of the filter, built into <I>VF_deconvolve</I>. Thereby, Flt is set to zero (instead of infinity) at those frequences where all information has been lost. You may set the threshold for this implicit editing by <I><a href="#setRspEdit">VF_setRspEdit</a></I>. In order to retrieve the threshold actually set, use <I><a href="#getRspEdit">VF_getRspEdit</a></I>.
<P>This deconvolution is based on the implicit assumption that X is periodic; if this is not the case, see the description of <I><a href="#convolve">VF_convolve</a></I> about how to avoid end effects.
<P>About special versions with the prefixes <I>VFs_</I> and <I>VFl_</I>, consult <a href="HANDBOOK.HTM#chap4_8">chapter&nbsp;4.8.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If size is not a power of 2, <I><a href="#FFT">VF_FFT</a></I> (on which <I>VF_deconvolve</I> is based) complains &quot;Size must be an integer power of 2&quot; and the program is aborted.
<BR>If, by <I><a href="#setRspEdit">VF_setRspEdit</a></I>, you specified Trunc.Re = Trunc.Im = 0, SING errors may occur that are handled by setting Flt to &#177;HUGE_VAL at the respective frequency. During multiplication with the transform of X, this may lead to unhandled floating-point overflow errors (in case your guess of Rsp was wrong and there is some information left at the frequencies where you thought it was not).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#filter">VF_filter</a>,&nbsp;&nbsp; <a href="#convolve">VF_convolve</a>,&nbsp;&nbsp; <a href="#FFT">VF_FFT</a>,&nbsp;&nbsp; <a href="#xcorr">VF_xcorr</a>,&nbsp;&nbsp; <a href="#spectrum">VF_spectrum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="delete"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_delete</b></font></td><td width="33%"><font size="+1"><b>VD_delete</b></font></td><td><font size="+1"><b>VE_delete</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_delete</b></font></td><td width="33%"><font size="+1"><b>VCD_delete</b></font></td><td><font size="+1"><b>VCE_delete</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_delete</b></font></td><td width="33%"><font size="+1"><b>VPD_delete</b></font></td><td><font size="+1"><b>VPE_delete</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>VI_delete</b></font></td><td width="25%"><font size="+1"><b>VSI_delete</b></font></td><td width="25%"><font size="+1"><b>VLI_delete</b></font></td><td><font size="+1"><b>VQI_delete</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>VU_delete</b></font></td><td width="25%"><font size="+1"><b>VUS_delete</b></font></td><td width="25%"><font size="+1"><b>VUL_delete</b></font></td><td><font size="+1"><b>VUI_delete</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Delete one element from a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_delete( fVector X, ui size, ui pos );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::delete( ui pos );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_delete( X:fVector; size, pos:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This is one of the few functions where the input vector itself is changed, instead of being mapped onto an output vector. The element numbered pos is deleted from the vector, and all the following elements are shifted one position lower; the last element is left undefined.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#rotate">VF_rotate</a>,&nbsp;&nbsp; <a href="#insert">VF_insert</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="derivC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_derivC</b></font></td><td width="33%"><font size="+1"><b>VD_derivC</b></font></td><td><font size="+1"><b>VE_derivC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Derivative of an array with respect to an independent variable sampled at constant intervals</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_derivC( fVector Y, fVector X, ui size, float DeltaT );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::derivC( const vector&lt;T&gt;& X, T DeltaT );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_derivC( Y, X:fVector; size:UInt; DeltaT:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y(t) = dX(t) / dt.
<BR>The vector X is assumed to be a function of a variable t; the t values themselves are equally spaced. Therefore, only the spacing, DeltaT, must be passed to the function. By parabolic interpolation, the derivative of X with respect to t is calculated. This function does the inverse of the integration by <I><a href="#runintegralC">VF_runintegralC</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#derivV">VF_derivV</a>,&nbsp;&nbsp; <a href="#runintegralC">VF_runintegralC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="derivV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_derivV</b></font></td><td width="33%"><font size="+1"><b>VD_derivV</b></font></td><td><font size="+1"><b>VE_derivV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Derivative of one array with respect to another</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_derivV( fVector Z, fVector X, fVector Y, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::derivV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_derivV( Z, X, Y:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Z(X) = dY(X) / dX.
<BR>The derivative of Y with respect to X is calculated by parabolic interpolation and stored in Z. If the elements of X are equally-spaced, it is better to use <I><a href="#derivC">VF_derivC</a></I>. The inverse procedure, i.e. integration, is performed by <I><a href="#runintegralV">VF_runintegralV</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#derivC">VF_derivC</a>,&nbsp;&nbsp; <a href="#runintegralV">VF_runintegralV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="distribution"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_distribution</b></font></td><td width="33%"><font size="+1"><b>VD_distribution</b></font></td><td><font size="+1"><b>VE_distribution</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Distribution function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>ui VF_distribution( uiVector Abund, fVector Limits, ui nbins, fVector X, ui sizex, int mode );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>ui vector&lt;ui&gt;::distribution( const vector&lt;T&gt;& Limits, const vector&lt;T&gt;& X, int mode=0 );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_distribution( Abund:uVector; Limits:fVector; bins:UInt; X:fVector; sizex:UInt; mode:Integer ):UInt;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function counts the number of elements of X falling into each of the intervals defined by Limits. The abundances thus determined are stored in Abund.
<BR>nbins is the number of elements of Limits, i.e. the number of intervals. sizex is the size of X.
<P>Limits must be in ascending order. The spacing between the elements of Limits need not necessarily be constant.
<P>The parameter mode specifies how to interpret the values given in Limits.
<BR>mode &gt; 0: Limits contains the upper limits of the intervals
<BR>mode &lt; 0: Limits contains the lower limits of the intervals
<BR>mode = 0: Limits contains the mid-points of the intervals. An element of X belongs to the element of Limits closest to it. In case of exactly equal distances, the interval with the lower index is chosen.
<BR>The interval defined by Limits<sub>0</sub> extends down to -HUGE_VAL, the interval defined by Limits<sub>nbins-1</sub> reaches up to +HUGE_VAL.
<P>The number of elements of X not falling into one of the intervals is returned. For mode &gt; 0, these are the elements greater than the highest limit. For mode &lt; 0, these are the elements smaller than the lowest limit.
<BR>For mode = 0, the return value is always zero, because the intervals are open on both sides. So every element of X is accounted for in Abund.
<P>In order to get the normalized distribution function, use the sequence
<BR><font face="courier new">VF_distribution( Abund, Limits, nbins, X, sizex, 0 );
<BR><a href="#ItoF">V_UItoD</a>( Y, Abund, nbins ); /* C/C++ or */
<BR><a href="#ItoF">V_UtoD</a>( Y, Abund, nbins ); (* Pascal/Delphi *)
<BR><a href="#divC">VD_divC</a>( Y, Y, nbins, VD_integralV(Limits,Y,nbins) );</font>
<P>After that, a call to
<BR><font face="courier new"><a href="#runintegralC">VD_runintegralC</a>( Y, Y, nbins, 1.0 );</font>
<BR>yields the cumulated distribution function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>number of elements of X not accounted for in Abund</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#searchV">VF_searchV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="divC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divC</b></font></td><td width="33%"><font size="+1"><b>VD_divC</b></font></td><td><font size="+1"><b>VE_divC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_divC</b></font></td><td width="33%"><font size="+1"><b>VCD_divC</b></font></td><td><font size="+1"><b>VCE_divC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_divReC</b></font></td><td width="33%"><font size="+1"><b>VCD_divReC</b></font></td><td><font size="+1"><b>VCE_divReC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_divC</b></font></td><td width="33%"><font size="+1"><b>VPD_divC</b></font></td><td><font size="+1"><b>VPE_divC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_divReC</b></font></td><td width="33%"><font size="+1"><b>VPD_divReC</b></font></td><td><font size="+1"><b>VPE_divReC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_divC</b></font></td><td width="20%"><font size="+1"><b>VBI_divC</b></font></td><td width="20%"><font size="+1"><b>VSI_divC</b></font></td><td width="20%"><font size="+1"><b>VLI_divC</b></font></td><td><font size="+1"><b>VQI_divC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_divC</b></font></td><td width="20%"><font size="+1"><b>VUB_divC</b></font></td><td width="20%"><font size="+1"><b>VUS_divC</b></font></td><td width="20%"><font size="+1"><b>VUL_divC</b></font></td><td><font size="+1"><b>VUI_divC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Divide by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_divC( fVector Y, fVector X, ui size, float C );
<BR>void VCF_divC( cfVector Y, cfVector X, ui size, fComplex C );
<BR>void VCF_divReC( cfVector Y, cfVector X, ui size, float CRe );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::divC( const vector&lt;T&gt;& X, T C );
<BR>void vector&lt;complex&lt;T&gt;&gt;::divC( const vector&lt;complex&lt;T&gt;&gt;& X, complex&lt;T&gt; C );
<BR>void vector&lt;complex&lt;T&gt;&gt;::divReC( const vector&lt;complex&lt;T&gt;&gt;& X, T CRe );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_divC( Y, X:fVector; size:UInt; C:Single );
<BR>procedure VCF_divC( Y, X:cfVector; size:UInt; C:fComplex );
<BR>procedure VCF_divReC( Y, X:cfVector; size:UInt; CRe:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>i</sub> / C
<BR>The integer versions perform an integer division, discarding the remainder; the remainder itself may be obtained by the functions of the <I><a href="#modC">VI_modC</a></I> family.
<BR>The complex floating-point versions exist in two variants, one for complex constants C, the other for real-valued constants CRe by which the complex vector is divided.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#divV">VF_divV</a>,&nbsp;&nbsp; <a href="#addC">VF_addC</a>,&nbsp;&nbsp; <a href="#subC">VF_subC</a>,&nbsp;&nbsp; <a href="#mulC">VF_mulC</a>,&nbsp;&nbsp; <a href="#divrC">VF_divrC</a>,&nbsp;&nbsp; <a href="#modC">VF_modC</a>,&nbsp;&nbsp; <a href="#visC">VF_visC</a>,&nbsp;&nbsp; <a href="#redC">VF_redC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="divrC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divrC</b></font></td><td width="33%"><font size="+1"><b>VD_divrC</b></font></td><td><font size="+1"><b>VE_divrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_divrC</b></font></td><td width="33%"><font size="+1"><b>VCD_divrC</b></font></td><td><font size="+1"><b>VCE_divrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_divrReC</b></font></td><td width="33%"><font size="+1"><b>VCD_divrReC</b></font></td><td><font size="+1"><b>VCE_divrReC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_divrC</b></font></td><td width="33%"><font size="+1"><b>VDx_divrC</b></font></td><td><font size="+1"><b>VEx_divrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_divrC</b></font></td><td width="33%"><font size="+1"><b>VCDx_divrC</b></font></td><td><font size="+1"><b>VCEx_divrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_divrC</b></font></td><td width="33%"><font size="+1"><b>VPD_divrC</b></font></td><td><font size="+1"><b>VPE_divrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_divrReC</b></font></td><td width="33%"><font size="+1"><b>VPD_divrReC</b></font></td><td><font size="+1"><b>VPE_divrReC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_divrC</b></font></td><td width="20%"><font size="+1"><b>VBI_divrC</b></font></td><td width="20%"><font size="+1"><b>VSI_divrC</b></font></td><td width="20%"><font size="+1"><b>VLI_divrC</b></font></td><td><font size="+1"><b>VQI_divrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_divrC</b></font></td><td width="20%"><font size="+1"><b>VUB_divrC</b></font></td><td width="20%"><font size="+1"><b>VUS_divrC</b></font></td><td width="20%"><font size="+1"><b>VUL_divrC</b></font></td><td><font size="+1"><b>VUI_divrC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Reverse division: divide a constant by a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_divrC( fVector Y, fVector X, ui size, float C );
<BR>void VFx_divrC( fVector Y, fVector X, ui size, float A, float B, float C );
<BR>void VCF_divrC( cfVector Y, cfVector X, ui size, fComplex C );
<BR>void VCFx_divrC( cfVector Y, cfVector X, ui size, fComplex A, fComplex B, fComplex C );
<BR>void VCF_divrReC( cfVector Y, cfVector X, ui size, float CRe );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::divrC( const vector&lt;T&gt;& X, T C );
<BR>void vector&lt;T&gt;::x_divrC( const vector&lt;T&gt;& X, T A, T B, T C );
<BR>void vector&lt;complex&lt;T&gt;&gt;::divrC( const vector&lt;complex&lt;T&gt;&gt;& X, complex&lt;T&gt; C );
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_divrC( const vector&lt;complex&lt;T&gt;&gt;& X, complex&lt;T&gt; A, complex&lt;T&gt; B, complex&lt;T&gt; C );
<BR>void vector&lt;complex&lt;T&gt;&gt;::divrReC( const vector&lt;complex&lt;T&gt;&gt;& X, T CRe );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_divrC( Y, X:fVector; size:UInt; C:Single );
<BR>procedure VFx_divrC( Y, X:fVector; size:UInt; A, B, C:Single );
<BR>procedure VCF_divrC( Y, X:cfVector; size:UInt; C:fComplex );
<BR>procedure VCFx_divrC( Y, X:cfVector; size:UInt; A, B, C:fComplex );
<BR>procedure VCF_divrReC( Y, X:cfVector; size:UInt; CRe:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = C / X<sub>i</sub>
<BR>expanded versions: Y<sub>i</sub> = C / (A*X<sub>i</sub>+B)
<BR>The complex floating-point versions exist in two variants, one for complex constants C, the other for real-valued constants CRe which are divided by the complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none; for the floating-point versions, there are related functions that calculate 1.0 / X<sub>i</sub> and 1.0 / (A*X<sub>i</sub>+B): <I><a href="#inv">VF_inv</a></I> and <I><a href="#inv">VFx_inv</a></I>, respectively; both of these detect and handle SING errors.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#divV">VF_divV</a>,&nbsp;&nbsp; <a href="#inv">VF_inv</a>,&nbsp;&nbsp; <a href="#addC">VF_addC</a>,&nbsp;&nbsp; <a href="#subC">VF_subC</a>,&nbsp;&nbsp; <a href="#mulC">VF_mulC</a>,&nbsp;&nbsp; <a href="#divC">VF_divC</a>,&nbsp;&nbsp; <a href="#modC">VF_modC</a>,&nbsp;&nbsp; <a href="#visC">VF_visC</a>,&nbsp;&nbsp; <a href="#redC">VF_redC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="divrV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divrV</b></font></td><td width="33%"><font size="+1"><b>VD_divrV</b></font></td><td><font size="+1"><b>VE_divrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_divrV</b></font></td><td width="33%"><font size="+1"><b>VCD_divrV</b></font></td><td><font size="+1"><b>VCE_divrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_divrReV</b></font></td><td width="33%"><font size="+1"><b>VCD_divrReV</b></font></td><td><font size="+1"><b>VCE_divrReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_divrV</b></font></td><td width="33%"><font size="+1"><b>VDx_divrV</b></font></td><td><font size="+1"><b>VEx_divrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_divrV</b></font></td><td width="33%"><font size="+1"><b>VCDx_divrV</b></font></td><td><font size="+1"><b>VCEx_divrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_divrReV</b></font></td><td width="33%"><font size="+1"><b>VCDx_divrReV</b></font></td><td><font size="+1"><b>VCEx_divrReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_divrV</b></font></td><td width="33%"><font size="+1"><b>VPD_divrV</b></font></td><td><font size="+1"><b>VPE_divrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_divrReV</b></font></td><td width="33%"><font size="+1"><b>VPD_divrReV</b></font></td><td><font size="+1"><b>VPE_divrReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_divrV</b></font></td><td width="20%"><font size="+1"><b>VBI_divrV</b></font></td><td width="20%"><font size="+1"><b>VSI_divrV</b></font></td><td width="20%"><font size="+1"><b>VLI_divrV</b></font></td><td><font size="+1"><b>VQI_divrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_divrV</b></font></td><td width="20%"><font size="+1"><b>VUB_divrV</b></font></td><td width="20%"><font size="+1"><b>VUS_divrV</b></font></td><td width="20%"><font size="+1"><b>VUL_divrV</b></font></td><td><font size="+1"><b>VUI_divrV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Divide two vectors in reverse order</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_divrV( fVector Z, fVector X, fVector Y, ui size );
<BR>void VFx_divrV( fVector Z, fVector X, fVector Y, ui size, float A, float B );
<BR>void VCF_divrV( cfVector Z, cfVector X, cfVector Y, ui size );
<BR>void VCF_divrReV( cfVector Z, cfVector X, fVector Y, ui size );
<BR>void VCFx_divrV( cfVector Z, cfVector X, cfVector Y, ui size, fComplex A, fComplex B );
<BR>void VCFx_divrReV( cfVector Z, cfVector X, fVector Y, ui size, fComplex A, fComplex B );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::divrV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y );
<BR>void vector&lt;T&gt;::x_divrV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y, T A, T B );
<BR>void vector&lt;complex&lt;T&gt;&gt;::divrV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;complex&lt;T&gt;&gt;& Y );
<BR>void vector&lt;complex&lt;T&gt;&gt;::divrReV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;T&gt;& Y );
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_divrV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;complex&lt;T&gt;&gt;& Y, complex&lt;T&gt; A, complex&lt;T&gt; B );
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_divrReV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;T&gt;& Y, complex&lt;T&gt; A, complex&lt;T&gt; B );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_divrV( Z, X, Y:fVector; size:UInt );
<BR>procedure VFx_divrV( Z, X, Y:fVector; size:UInt; A, B:Single );
<BR>procedure VCF_divrV( Z, X, Y:cfVector; size:UInt );
<BR>procedure VCF_divrReV( Z, X:cfVector; Y:fVector; size:UInt );
<BR>procedure VCFx_divrV( Z, X, Y:cfVector; size:UInt; A, B:fComplex );
<BR>procedure VCFx_divrReV( Z, X:cfVector; Y:fVector; size:UInt; A, B:fComplex );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Z<sub>i</sub> = Y<sub>i</sub> / X<sub>i</sub>
<BR>expanded versions: Z<sub>i</sub> = Y<sub>i</sub> / (A*X<sub>i</sub>+B)
<BR>The complex floating-point versions exist in two variants: in the first variant (e.g., <I>VCF_divrV,&nbsp;&nbsp; VCFx_divrV</I>), X, Y, and Z are all complex; in the second variant, Y is real-valued (e.g., <I>VCF_divrReV</I> - &quot;division in reverse order: divide a real vector by a complex one&quot;).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#divrC">VF_divrC</a>,&nbsp;&nbsp; <a href="#addV">VF_addV</a>,&nbsp;&nbsp; <a href="#mulV">VF_mulV</a>,&nbsp;&nbsp; <a href="#modV">VF_modV</a>,&nbsp;&nbsp; <a href="#visV">VF_visV</a>,&nbsp;&nbsp; <a href="#redV">VF_redV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="divV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_divV</b></font></td><td width="33%"><font size="+1"><b>VD_divV</b></font></td><td><font size="+1"><b>VE_divV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFs_divV</b></font></td><td width="33%"><font size="+1"><b>VDs_divV</b></font></td><td><font size="+1"><b>VEs_divV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_divV</b></font></td><td width="33%"><font size="+1"><b>VDx_divV</b></font></td><td><font size="+1"><b>VEx_divV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_divV</b></font></td><td width="33%"><font size="+1"><b>VCD_divV</b></font></td><td><font size="+1"><b>VCE_divV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_divReV</b></font></td><td width="33%"><font size="+1"><b>VCD_divReV</b></font></td><td><font size="+1"><b>VCE_divReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_divV</b></font></td><td width="33%"><font size="+1"><b>VCDx_divV</b></font></td><td><font size="+1"><b>VCEx_divV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_divReV</b></font></td><td width="33%"><font size="+1"><b>VCDx_divReV</b></font></td><td><font size="+1"><b>VCEx_divReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_divV</b></font></td><td width="33%"><font size="+1"><b>VPD_divV</b></font></td><td><font size="+1"><b>VPE_divV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_divReV</b></font></td><td width="33%"><font size="+1"><b>VPD_divReV</b></font></td><td><font size="+1"><b>VPE_divReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_divV</b></font></td><td width="20%"><font size="+1"><b>VBI_divV</b></font></td><td width="20%"><font size="+1"><b>VSI_divV</b></font></td><td width="20%"><font size="+1"><b>VLI_divV</b></font></td><td><font size="+1"><b>VQI_divV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_divV</b></font></td><td width="20%"><font size="+1"><b>VUB_divV</b></font></td><td width="20%"><font size="+1"><b>VUS_divV</b></font></td><td width="20%"><font size="+1"><b>VUL_divV</b></font></td><td><font size="+1"><b>VUI_divV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Divide two vectors</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_divV( fVector Z, fVector X, fVector Y, ui size );
<BR>void VFs_divV( fVector Z, fVector X, fVector Y, ui size, float C );
<BR>void VFx_divV( fVector Z, fVector X, fVector Y, ui size, float A, float B );
<BR>void VCF_divV( cfVector Z, cfVector X, cfVector Y, ui size );
<BR>void VCF_divReV( cfVector Z, cfVector X, fVector Y, ui size );
<BR>void VCFx_divV( cfVector Z, cfVector X, cfVector Y, ui size, fComplex A, fComplex B );
<BR>void VCFx_divReV( cfVector Z, cfVector X, fVector Y, ui size, fComplex A, fComplex B );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::divV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y );
<BR>void vector&lt;T&gt;::s_divV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y, T C );
<BR>void vector&lt;T&gt;::x_divV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y, T A, T B );
<BR>void vector&lt;complex&lt;T&gt;&gt;::divV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;complex&lt;T&gt;&gt;& Y );
<BR>void vector&lt;complex&lt;T&gt;&gt;::divReV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;T&gt;& Y );
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_divV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;complex&lt;T&gt;&gt;& Y, complex&lt;T&gt; A, complex&lt;T&gt; B );
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_divReV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;T&gt;& Y, complex&lt;T&gt; A, complex&lt;T&gt; B );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_divV( Z, X, Y:fVector; size:UInt );
<BR>procedure VFs_divV( Z, X, Y:fVector; size:UInt; C:Single );
<BR>procedure VFx_divV( Z, X, Y:fVector; size:UInt; A, B:Single );
<BR>procedure VCF_divV( Z, X, Y:cfVector; size:UInt );
<BR>procedure VCF_divReV( Z, X:cfVector; Y:fVector; size:UInt );
<BR>procedure VCFx_divV( Z, X, Y:cfVector; size:UInt; A, B:fComplex );
<BR>procedure VCFx_divrReV( Z, X:cfVector; Y:fVector; size:UInt; A, B:fComplex );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Z<sub>i</sub> = X<sub>i</sub> / Y<sub>i</sub>
<BR>scaled versions: Z<sub>i</sub> = C * (X<sub>i</sub> / Y<sub>i</sub>)
<BR>expanded versions: Z<sub>i</sub> = (A*X<sub>i</sub>+B) / Y<sub>i</sub>
<BR>The complex floating-point versions exist in two variants: in the first variant (e.g., <I>VCF_divV,&nbsp;&nbsp; VCFx_divV</I>), X, Y, and Z are all complex; in the second variant, Y is real-valued (e.g., <I>VCF_divReV</I> - &quot;divide by a real vector&quot;).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#divC">VF_divC</a>,&nbsp;&nbsp; <a href="#addV">VF_addV</a>,&nbsp;&nbsp; <a href="#mulV">VF_mulV</a>,&nbsp;&nbsp; <a href="#modV">VF_modV</a>,&nbsp;&nbsp; <a href="#visV">VF_visV</a>,&nbsp;&nbsp; <a href="#redV">VF_redV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="drawAxes"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_drawAxes</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Draws a Cartesian coordinate system.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void V_drawAxes( long double Xmin, long double Xmax, long double Ymin, long double Ymax );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure V_drawAxes( xmin, xmax, ymin, ymax:Extended );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A Cartesian coordinate system is drawn with the axes scaled according to the values passed as Xmin, Xmax, Ymin, and Ymax. Ten subdivision lines are drawn on each axis. No adjustment of this scaling is performed; if automatic fine-tuning of the scaling is desired, call <I><a href="#findAxes">V_findAxes</a></I> instead. Before using this function, either <I><a href="#initGraph">V_initGraph</a></I> or <I><a href="#initPlot">V_initPlot</a></I> has to be called. <I>V_drawAxes</I> is used internally by all functions of the AutoPlot family.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#findAxes">V_findAxes</a>,&nbsp;&nbsp; <a href="#initPlot">V_initPlot</a>,&nbsp;&nbsp; <a href="#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#xyDataPlot">VF_xyDataPlot</a></I>,&nbsp;&nbsp;<a href="HANDBOOK.HTM#chap4_12">chapter&nbsp;4.12</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="DtoF"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_DtoF</b></font></td><td><font size="+1"><b>V_DtoE</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Data type conversions. See <I><a href="#FtoD">V_FtoD</a></I>.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="element"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_element</b></font></td><td width="33%"><font size="+1"><b>VD_element</b></font></td><td><font size="+1"><b>VE_element</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_element</b></font></td><td width="33%"><font size="+1"><b>VCD_element</b></font></td><td><font size="+1"><b>VCE_element</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_element</b></font></td><td width="33%"><font size="+1"><b>VPD_element</b></font></td><td><font size="+1"><b>VPE_element</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_element</b></font></td><td width="20%"><font size="+1"><b>VBI_element</b></font></td><td width="20%"><font size="+1"><b>VSI_element</b></font></td><td width="20%"><font size="+1"><b>VLI_element</b></font></td><td><font size="+1"><b>VQI_element</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_element</b></font></td><td width="20%"><font size="+1"><b>VUB_element</b></font></td><td width="20%"><font size="+1"><b>VUS_element</b></font></td><td width="20%"><font size="+1"><b>VUL_element</b></font></td><td><font size="+1"><b>VUI_element</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Returns the value of a vector element</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_element( fVector X, ui pos );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::element( ui pos );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_element( X:fVector; pos:UInt ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The element at the position pos is returned.<BR>Pascal/Delphi only: As fComplex and fPolar return values are not possible, the <I>VCF_</I> and <I>VPF_</I> versions store X<sub>pos</sub> into the variable xpos.
<BR>This function is needed to read elements of dynamically allocated vectors, for which older versions of Borland C++ had a pointer arithmetics bug, and Pascal/Delphi - unlike C - does not provide an own mechanism at all.
<BR><I>VF_element</I> is &quot;read-only&quot;. This means, you c a n n o t write something like
<BR><font face="courier new">VF_element( X, 4 ) := 5;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>X[pos] (except Pascal/Delphi complex versions)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#Pelement">VF_Pelement</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="equ0"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_equ0</b></font></td><td width="33%"><font size="+1"><b>VD_equ0</b></font></td><td><font size="+1"><b>VE_equ0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_equ0</b></font></td><td width="33%"><font size="+1"><b>VCD_equ0</b></font></td><td><font size="+1"><b>VCE_equ0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_equ0</b></font></td><td width="33%"><font size="+1"><b>VPD_equ0</b></font></td><td><font size="+1"><b>VPE_equ0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_equ0</b></font></td><td width="20%"><font size="+1"><b>VBI_equ0</b></font></td><td width="20%"><font size="+1"><b>VSI_equ0</b></font></td><td width="20%"><font size="+1"><b>VLI_equ0</b></font></td><td><font size="+1"><b>VQI_equ0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_equ0</b></font></td><td width="20%"><font size="+1"><b>VUB_equ0</b></font></td><td width="20%"><font size="+1"><b>VUS_equ0</b></font></td><td width="20%"><font size="+1"><b>VUL_equ0</b></font></td><td><font size="+1"><b>VUI_equ0</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>(Re-) initialize a vector with zero.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_equ0( fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::equ0();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_equ0( X:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X<sub>i</sub> = 0</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#equ1">VF_equ1</a>,&nbsp;&nbsp; <a href="#equC">VF_equC</a>,&nbsp;&nbsp; <a href="#equV">VF_equV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="equ1"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_equ1</b></font></td><td width="33%"><font size="+1"><b>VD_equ1</b></font></td><td><font size="+1"><b>VE_equ1</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_equ1</b></font></td><td width="33%"><font size="+1"><b>VCD_equ1</b></font></td><td><font size="+1"><b>VCE_equ1</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_equ1</b></font></td><td width="33%"><font size="+1"><b>VPD_equ1</b></font></td><td><font size="+1"><b>VPE_equ1</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initialize a vector with 1.0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_equ1( fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::equ1();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_equ1( X:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X<sub>i</sub> = 1.0
<BR>In the cartesian complex versions, the imaginary parts are set to zero. In the polar complex versions, all elements are set to {1.0 @ 0}.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#equ0">VF_equ0</a>,&nbsp;&nbsp; <a href="#equm1">VF_equm1</a>,&nbsp;&nbsp; <a href="#equC">VF_equC</a>,&nbsp;&nbsp; <a href="#equV">VF_equV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="equC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_equC</b></font></td><td width="33%"><font size="+1"><b>VD_equC</b></font></td><td><font size="+1"><b>VE_equC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_equC</b></font></td><td width="33%"><font size="+1"><b>VCD_equC</b></font></td><td><font size="+1"><b>VCE_equC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_equC</b></font></td><td width="33%"><font size="+1"><b>VPD_equC</b></font></td><td><font size="+1"><b>VPE_equC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_equC</b></font></td><td width="20%"><font size="+1"><b>VBI_equC</b></font></td><td width="20%"><font size="+1"><b>VSI_equC</b></font></td><td width="20%"><font size="+1"><b>VLI_equC</b></font></td><td><font size="+1"><b>VQI_equC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_equC</b></font></td><td width="20%"><font size="+1"><b>VUB_equC</b></font></td><td width="20%"><font size="+1"><b>VUS_equC</b></font></td><td width="20%"><font size="+1"><b>VUL_equC</b></font></td><td><font size="+1"><b>VUI_equC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initializes a vector with a constant value.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_equC( fVector X, ui size, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::equC( T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_equC( X:fVector; size:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X<sub>i</sub> = C</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#equ0">VF_equ0</a>,&nbsp;&nbsp; <a href="#equ1">VF_equ1</a>,&nbsp;&nbsp; <a href="#equV">VF_equV</a>,&nbsp;&nbsp; <a href="#comb">VF_comb</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="equm1"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_equm1</b></font></td><td width="33%"><font size="+1"><b>VD_equm1</b></font></td><td><font size="+1"><b>VE_equm1</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_equm1</b></font></td><td width="33%"><font size="+1"><b>VCD_equm1</b></font></td><td><font size="+1"><b>VCE_equm1</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_equm1</b></font></td><td width="33%"><font size="+1"><b>VPD_equm1</b></font></td><td><font size="+1"><b>VPE_equm1</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initialize a vector with -1.0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_equm1( fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::equm1();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_equm1( X:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X<sub>i</sub> = -1.0
<BR>In the cartesian complex versions, the imaginary parts are set to zero. In the polar complex versions, all elements are set to { 1.0 @ <font face="symbol">p</font> }.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#equ0">VF_equ0</a>,&nbsp;&nbsp; <a href="#equ1">VF_equ1</a>,&nbsp;&nbsp; <a href="#equC">VF_equC</a>,&nbsp;&nbsp; <a href="#equV">VF_equV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="equV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_equV</b></font></td><td width="33%"><font size="+1"><b>VD_equV</b></font></td><td><font size="+1"><b>VE_equV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_equV</b></font></td><td width="33%"><font size="+1"><b>VCD_equV</b></font></td><td><font size="+1"><b>VCE_equV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_equV</b></font></td><td width="33%"><font size="+1"><b>VDx_equV</b></font></td><td><font size="+1"><b>VEx_equV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_equV</b></font></td><td width="33%"><font size="+1"><b>VCDx_equV</b></font></td><td><font size="+1"><b>VCEx_equV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_equV</b></font></td><td width="33%"><font size="+1"><b>VPD_equV</b></font></td><td><font size="+1"><b>VPE_equV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_equV</b></font></td><td width="20%"><font size="+1"><b>VBI_equV</b></font></td><td width="20%"><font size="+1"><b>VSI_equV</b></font></td><td width="20%"><font size="+1"><b>VLI_equV</b></font></td><td><font size="+1"><b>VQI_equV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_equV</b></font></td><td width="20%"><font size="+1"><b>VUB_equV</b></font></td><td width="20%"><font size="+1"><b>VUS_equV</b></font></td><td width="20%"><font size="+1"><b>VUL_equV</b></font></td><td><font size="+1"><b>VUI_equV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Copies one vector to another.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_equV( fVector Y, fVector X, ui size );
<BR>void VFx_equV( fVector Y, fVector X, ui size, float A, float B );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::equV( const vector&lt;T&gt;& X );
<BR>void vector&lt;T&gt;::x_equV( const vector&lt;T&gt;& X, T A, T B );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_equV( Y, X:fVector; size:UInt );
<BR>procedure VFx_equV( Y, X:fVector; size:UInt; A, B:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = X<sub>i</sub>
<BR>expanded versions: Y<sub>i</sub> = A * X<sub>i</sub> + B</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#equ0">VF_equ0</a>,&nbsp;&nbsp; <a href="#equ1">VF_equ1</a>,&nbsp;&nbsp; <a href="#equC">VF_equC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="erf"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_erf</b></font></td><td width="33%"><font size="+1"><b>VD_erf</b></font></td><td><font size="+1"><b>VE_erf</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_erf</b></font></td><td width="33%"><font size="+1"><b>VDx_erf</b></font></td><td><font size="+1"><b>VEx_erf</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Error function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_erf( fVector Y, fVector X, ui size );
<BR>int VFx_erf( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::erf( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_erf( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_erf( Y,X:fVector; size:UInt ): IntBool;
<BR>function VFx_erf( Y,X:fVector; size:UInt; 
 A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = erf( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * erf( A*X<sub>i</sub>+B )</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>this function should be error-proof.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#erfc">VF_erfc</a>,&nbsp;&nbsp; <a href="#Gauss">VF_Gauss</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="erfc"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_erfc</b></font></td><td width="33%"><font size="+1"><b>VD_erfc</b></font></td><td><font size="+1"><b>VE_erfc</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_erfc</b></font></td><td width="33%"><font size="+1"><b>VDx_erfc</b></font></td><td><font size="+1"><b>VEx_erfc</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Complementary error function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_erfc( fVector Y, fVector X, ui size );
<BR>int VFx_erfc( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::erfc( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_erfc( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_erfc( Y,X:fVector; size:UInt ): IntBool;
<BR>function VFx_erfc( Y,X:fVector; size:UInt; 
 A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = 1.0 - erf( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * (1.0 - erf( A*X<sub>i</sub>+B ))</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>this function should be error-proof.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#erf">VF_erf</a>,&nbsp;&nbsp; <a href="#Gauss">VF_Gauss</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="Euclid"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_Euclid</b></font></td><td width="33%"><font size="+1"><b>VD_Euclid</b></font></td><td><font size="+1"><b>VE_Euclid</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Calculates the Euclidean norm of a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_Euclid( fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::Euclid();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_Euclid( X:fVector; size:UInt ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>norm = sqrt( sum( X<sub>i</sub><sup>2</sup> ) )
<BR>The Euclidean norm of a vector is defined as the square-root of the scalar product of the vector with itself.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none (but beware of a possible overflow!)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The Euclidean norm is returned</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ssq">VF_ssq</a>,&nbsp;&nbsp; <a href="#rms">VF_rms</a>,&nbsp;&nbsp; <a href="#scalprod">VF_scalprod</a>,&nbsp;&nbsp; <a href="#xprod">VF_xprod</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="exp"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_exp</b></font></td><td width="33%"><font size="+1"><b>VD_exp</b></font></td><td><font size="+1"><b>VE_exp</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_exp</b></font></td><td width="33%"><font size="+1"><b>VCD_exp</b></font></td><td><font size="+1"><b>VCE_exp</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_exp</b></font></td><td width="33%"><font size="+1"><b>VDx_exp</b></font></td><td><font size="+1"><b>VEx_exp</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_exp</b></font></td><td width="33%"><font size="+1"><b>VCDx_exp</b></font></td><td><font size="+1"><b>VCEx_exp</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_exptoP</b></font></td><td width="33%"><font size="+1"><b>VCD_exptoP</b></font></td><td><font size="+1"><b>VCE_exptoP</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Exponential function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_exp( fVector Y, fVector X, ui size );
<BR>int VFx_exp( fVector Y, fVector X, ui size, float A, float B, float C );
<BR>int VCF_exptoP( pfVector Y, cfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::exp( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_exp( const vector&lt;T&gt;& X, T A, T B, T C );
<BR>int vector&lt;polar&lt;T&gt;&gt;::exptoP( const vector&lt;complex&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_exp( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_exp( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;
<BR>function VCF_exptoP( Y:pfVector; X:cfVector; size:UInt ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = exp( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * exp( A*X<sub>i</sub>+B )
<BR>Euler's constant <I>e</I> is raised to the X<sub>i</sub>'th power.
<BR>For cartesian complex numbers, the result can be stored either in cartesian complex format (<I>VCF_exp</I>), or in polar coordinates (<I>VCF_exptoP</I>).
<BR>Variants of the exponential function, like its complement (<I><a href="#expc">VF_expc</a></I>), the hyperbolic functions (e.g. <I><a href="#sinh">VF_sinh</a></I>), or the Gaussian distribution (<I><a href="#Gauss">VF_Gauss</a></I>) are also available; see <a href="HANDBOOK.HTM#chap4_6_7">chapter&nbsp;4.6.7</a> about &quot;Exponentials&quot; before using <I>VF_exp</I> for sums or other combinations of exponentials - maybe the desired function already exists.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#log">VF_log</a>,&nbsp;&nbsp; <a href="#expc">VF_expc</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#sinh">VF_sinh</a>,&nbsp;&nbsp; <a href="#exp2">VF_exp2</a>,&nbsp;&nbsp; <a href="#Gauss">VF_Gauss</a>,&nbsp;&nbsp; <a href="#log">VPF_logtoC</a>,&nbsp;&nbsp; exp</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="exp2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_exp2</b></font></td><td width="33%"><font size="+1"><b>VD_exp2</b></font></td><td><font size="+1"><b>VE_exp2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_exp2</b></font></td><td width="33%"><font size="+1"><b>VDx_exp2</b></font></td><td><font size="+1"><b>VEx_exp2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Exponential function to the basis 2</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_exp2( fVector Y, fVector X, ui size );
<BR>int VFx_exp2( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::exp2( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_exp2( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_exp2( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_exp2( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = 2 <sup>X</sup><font size="-1">i</font>
<BR>expanded versions: Y<sub>i</sub> = C * 2 <sup>(A*X</sup><font size="-1">i</font><sup>+B)</sup>
<BR>Two is raised to the X<sub>i</sub>'th power. These function names are used as synonyms for <I><a href="#pow2">VF_pow2</a></I> etc.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#exp">VF_exp</a>,&nbsp;&nbsp; <a href="#exp10">VF_exp10</a>,&nbsp;&nbsp; <a href="#ipow2">VF_ipow2</a>,&nbsp;&nbsp; <a href="#scale2">VF_scale2</a>,&nbsp;&nbsp; <a href="#log2">VF_log2</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="exp10"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_exp10</b></font></td><td width="33%"><font size="+1"><b>VD_exp10</b></font></td><td><font size="+1"><b>VE_exp10</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_exp10</b></font></td><td width="33%"><font size="+1"><b>VDx_exp10</b></font></td><td><font size="+1"><b>VEx_exp10</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Exponential function to the basis 10</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_exp10( fVector Y, fVector X, ui size );
<BR>int VFx_exp10( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::exp10( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_exp10( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_exp10( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_exp10( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = 10 <sup>X</sup><font size="-1">i</font>
<BR>expanded versions: Y<sub>i</sub> = C * 10 <sup>(A*X</sup><font size="-1">i</font><sup>+B)</sup>
<BR>Ten is raised to the X<sub>i</sub>'th power. These function names are used as synonyms for <I><a href="#pow10">VF_pow10</a></I> etc.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#exp">VF_exp</a>,&nbsp;&nbsp; <a href="#exp2">VF_exp2</a>,&nbsp;&nbsp; <a href="#ipow10">VF_ipow10</a>,&nbsp;&nbsp; <a href="#scale10">VF_scale10</a>,&nbsp;&nbsp; <a href="#log10">VF_log10</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="expArbBase"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_expArbBase</b></font></td><td width="33%"><font size="+1"><b>VD_expArbBase</b></font></td><td><font size="+1"><b>VE_expArbBase</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_expArbBase</b></font></td><td width="33%"><font size="+1"><b>VCD_expArbBase</b></font></td><td><font size="+1"><b>VCE_expArbBase</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_expArbBase</b></font></td><td width="33%"><font size="+1"><b>VDx_expArbBase</b></font></td><td><font size="+1"><b>VEx_expArbBase</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_expArbBase</b></font></td><td width="33%"><font size="+1"><b>VCDx_expArbBase</b></font></td><td><font size="+1"><b>VCEx_expArbBase</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Exponential function of an arbitrary base</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_expArbBase( fVector Y, fVector X, ui size, float Base );
<BR>int VFx_expArbBase( fVector Y, fVector X, ui size, float Base, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::expArbBase( const vector&lt;T&gt;& X, T Base );
<BR>int vector&lt;T&gt;::x_expArbBase( const vector&lt;T&gt;& X, T Base, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_expArbBase( Y, X:fVector; size:UInt; Base:Single ): IntBool;
<BR>function VFx_expArbBase( Y, X:fVector; size:UInt; Base, A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = Base <sup>X</sup><font size="-1">i</font>
<BR>expanded versions: Y<sub>i</sub> = C * Base <sup>(A*X</sup><font size="-1">i</font><sup>+B)</sup>
<BR>Base must be positive and non-zero in the real-number versions. In the complex versions, Base must be non-zero.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#exp">VF_exp</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="expc"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_expc</b></font></td><td width="33%"><font size="+1"><b>VD_expc</b></font></td><td><font size="+1"><b>VE_expc</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_expc</b></font></td><td width="33%"><font size="+1"><b>VDx_expc</b></font></td><td><font size="+1"><b>VEx_expc</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Complementary exponential function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_expc( fVector Y, fVector X, ui size );
<BR>int VFx_expc( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::expc( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_expc( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_expc( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_expc( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = 1 - exp( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * (1 - exp [A*X<sub>i</sub> + B ])
<BR>The difference between 1.0 and the exponential function of X<sub>i</sub> is calculated. Note that the expc function is directly available from the 80x87 coprocessor in high accuracy; in fact, it is the exponential function itself that is internally calculated via the expc function. The expc function is often encountered in the natural sciences for the description of decay and growth processes.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#log">VF_log</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#sinh">VF_sinh</a>,&nbsp;&nbsp; <a href="#exp2">VF_exp2</a>,&nbsp;&nbsp; <a href="#Gauss">VF_Gauss</a></I>,&nbsp;&nbsp;exp</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="expmx2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_expmx2</b></font></td><td width="33%"><font size="+1"><b>VD_expmx2</b></font></td><td><font size="+1"><b>VE_expmx2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_expmx2</b></font></td><td width="33%"><font size="+1"><b>VDx_expmx2</b></font></td><td><font size="+1"><b>VEx_expmx2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Exponential function of the negative square of the argument</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_expmx2( fVector Y, fVector X, ui size );
<BR>int VFx_expmx2( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::expmx2( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_expmx2( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_expmx2( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_expmx2( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = exp( -X<sub>i</sub><sup>2</sup> )
<BR>expanded versions: Y<sub>i</sub> = C * exp( -(A*X<sub>i</sub>+B)<sup>2</sup> )
<BR>This function yields a bell-shaped curve similar to the Gaussian function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>This function should be error-proof.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#log">VF_log</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; <a href="#Gauss">VF_Gauss</a>,&nbsp;&nbsp; <a href="#sech2">VF_sech2</a>,&nbsp;&nbsp; <a href="#Lorentz">VF_Lorentz</a>,&nbsp;&nbsp; exp</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="FFT"></a><a name="FFTtoC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_FFT</b></font></td><td width="33%"><font size="+1"><b>VD_FFT</b></font></td><td><font size="+1"><b>VE_FFT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_FFTtoC</b></font></td><td width="33%"><font size="+1"><b>VD_FFTtoC</b></font></td><td><font size="+1"><b>VE_FFTtoC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_FFT</b></font></td><td width="33%"><font size="+1"><b>VCD_FFT</b></font></td><td><font size="+1"><b>VCE_FFT</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Fast Fourier transform</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_FFT( fVector Y, fVector X, ui size, int dir );
<BR>void VCF_FFT( cfVector Y, cfVector X, ui size, int dir );
<BR>void VF_FFTtoC( cfVector Y, fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::FFT( const vector&lt;T&gt;& X, int dir=1 );
<BR>void vector&lt;complex&lt;T&gt;&gt;::FFT( const vector&lt;complex&lt;T&gt;&gt;& X, int dir=1 );
<BR>void vector&lt;complex&lt;T&gt;&gt;::FFTtoC( const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_FFT( Y, X:fVector; size:UInt; dir:Integer );
<BR>procedure VCF_FFT( Y, X:cfVector; size:UInt; dir:Integer );
<BR>procedure VF_FFTtoC( Y:cfVector; X:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The Fourier transform of X is calculated and stored in Y. The forward transform is obtained by setting dir = 1, the inverse (or backward) transform by setting dir = -1. A Fast Fourier Transform algorithm is used that requires size to be a power of 2.
<BR>Complex version: Both X and the output Y are complex vectors.
<BR>Real-to-complex version: The input vector X is real. The output vector is complex. As this function can only perform a forward transform, no argument &quot;dir&quot; is needed.
<BR>Purely real version: For the forward transform, X is a real vector. The output Y is also defined as fVector, although it consists of complex numbers. These are packed in a special way such as to fit into the same amount of memory as the original real vector X. The order of storage in Y is indicated in the following table (N=size, U is the uncompressed Fourier Transform of X):
<BR>&nbsp;
<table border width="100%">
<tr valign="TOP">
<td>Y<sub>0</sub></td><td>Y<sub>1</sub></td><td>Y<sub>2</sub>
</td><td>Y<sub>3</sub></td><td>&nbsp;&nbsp;.....&nbsp;&nbsp;
</td><td>Y<sub>N-2</sub></td><td>Y<sub>N-1</sub></td></tr>
<tr valign="TOP">
<td>U<sub>0</sub>.Re</td><td>U<sub>N/2</sub>.Re</td><td>U<sub>1</sub>.Re
</td><td>U<sub>1</sub>.Im</td><td>&nbsp;&nbsp;.....&nbsp;&nbsp;
</td><td>U<sub>N/2-1</sub>.Re</td><td>U<sub>N/2-1</sub>.Im</td></tr></table>
<BR>The reason for this packing is the following. If the size real data points of X represent a function of the time, X = g(t), then the forward transform yields a function U = G(f) in the frequency domain. In principle, U consists of size+1 complex data points: size/2 points for positive frequencies, another size/2 points for negative frequencies, and one point at frequency zero.
<BR>For the Fourier Transform of a real vector, the symmetry relation G(-f) = |G(f)|<sup>*</sup> holds (the asterisc denoting the complex conjugate). This means that the points at negative frequencies need not be stored; all information is already contained in the positive frequency half. Moreover, the zeroth and the size2'th element of the transform are both purely real. Therefore, only these two real and size/2-1 complex data points have to be stored - which exactly fit into the same amount of memory as the original size real data points of X. This allows X to be overwritten by its transform, if desired.
<P>For the real version of the inverse transform, X has to be a complex vector packed in the way just described, and a real-valued vector Y is obtained.
<P>About special versions with the prefixes <I>VFs_</I> and <I>VFl_</I>, consult <a href="HANDBOOK.HTM#chap4_8">chapter&nbsp;4.8.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If size is not a power of 2, an error message &quot;Size must be an integer power of 2&quot; is generated and the program aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#filter">VF_filter</a>,&nbsp;&nbsp; <a href="#convolve">VF_convolve</a>,&nbsp;&nbsp; <a href="#autocorr">VF_autocorr</a>,&nbsp;&nbsp; <a href="#xcorr">VF_xcorr</a>,&nbsp;&nbsp; <a href="#spectrum">VF_spectrum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="filter"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_filter</b></font></td><td width="33%"><font size="+1"><b>VD_filter</b></font></td><td><font size="+1"><b>VE_filter</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_filter</b></font></td><td width="33%"><font size="+1"><b>VCD_filter</b></font></td><td><font size="+1"><b>VCE_filter</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Frequency filtering</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_filter(fVector Y, fVector X, fVector Flt, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::filter( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Flt );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_filter( Y, X, Flt:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A frequency filter Flt is applied to the vector X. Internally, this is done by performing a Fourier transform on X, multiplying the transform with Flt and transforming the product back into the time domain.
<P>Complex versions: X, Y and the filter Flt are complex vectors.
<BR>Real versions: X and Y are real. Flt has to be in the packed complex format that is obtained by Fourier transforming a real vector with <I><a href="#FFT">VF_FFT</a></I> (see that function for the description of the packed complex format) or by using <I><a href="#convolve">VF_convolve</a></I>.
<P>For purely real filter functions known analytically, construct your filter by first evaluating it for a real vector of size/2+1 elements, and subsequently copy this real vector into Flt, as in the following example (<I>f<sub>Nyquist</sub></I> = 0.5 / <I>sampling_interval</I>; the desired cutoff frequency is <I>f<sub>CutOff</sub></I>):<BR>&nbsp;</td></tr>
<tr valign="TOP">
<td>Example C/C++:</td><td><font face="courier new">float Coeffs[3] = {1.0, 1.4142135, 1.0}; 
<BR>fVector Flt = <a href="#vector0">VF_vector0</a>( size );
<BR>fVector RealFlt = <a href="#vector">VF_vector</a>( size/2+1 );
<BR>fVector Freq = VF_vector( size/2+1 );
<BR><a href="#ramp">VF_ramp</a>( Freq, size/2+1, 0, (fNyquist / fCutOff) / (size/2) );
<BR>&nbsp;&nbsp;&nbsp;  /* reduced frequencies from 0 to fNyquist / fCutOff */
<BR><a href="#poly">VF_poly</a>( RealFlt, Freq, size/2+1, Coeffs, 2 );
<BR><a href="#inv">VF_inv</a>( RealFlt, RealFlt, size/2+1 );
<BR>&nbsp;&nbsp;&nbsp;  /*  calc. response from coeffs of this 2nd order filter */
<BR><a href="#RetoC">VF_RetoC</a>( (cfVector)Flt, RealFlt, size/2 ); 
<BR>&nbsp;&nbsp;&nbsp; /* the imaginary elements remain 0 */
<BR>Flt[1] = RealFlt[ size/2 ];   /* response at Nyquist frequency */</font><BR>&nbsp;</td></tr>
<tr valign="TOP">
<td>The same example for Pascal/Delphi:</td><td><font face="courier new">const Coeffs: array[0..2] of Single = (1.0, 1.4142135, 1.0);
<BR>var Flt, RealFlt, Freq: fVector;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;size_2: UInt;
<BR>begin
<BR>&nbsp;&nbsp;...
<BR>&nbsp;&nbsp;size_2 := size div 2;
<BR>&nbsp;&nbsp;Flt := <a href="#vector0">VF_vector0</a>( size );
<BR>&nbsp;&nbsp;RealFlt := <a href="#vector">VF_vector</a>( size_2+1 );
<BR>&nbsp;&nbsp;Freq := VF_vector( size_2+1 );
<BR>&nbsp;&nbsp;<a href="#ramp">VF_ramp</a>( Freq, size_2+1, 0, (fNyquist / fCutOff) / (size_2) ); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* reduced frequencies from 0 to fNyquist / fCutOff *)
<BR>&nbsp;&nbsp;<a href="#poly">VF_poly</a>( RealFlt, Freq, size_2+1, @Coeffs, 2 );
<BR>&nbsp;&nbsp;<a href="#inv">VF_inv</a>( RealFlt, RealFlt, size_2+1 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*  calc. response from coeffs of this 2nd order filter *)
<BR>&nbsp;&nbsp;<a href="#RetoC">VF_RetoC</a>( cfVector(Flt), RealFlt, size_2 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* the imaginary elements remain 0 *)
<BR>&nbsp;&nbsp;<a href="#Pelement">VF_Pelement</a>( Flt, 1 )^ := <a href="#element">VF_element</a>( RealFlt, size_2 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* response at Nyquist frequency *)
<BR>&nbsp;&nbsp;...
<BR>end;</font>
<P>If X is non-periodic, both ends of the filtered function may be spoiled by wrap-around. See <I><a href="#convolve">VF_convolve</a></I> about how to avoid end-effects by embedding X in a larger vector or by removing a possible linear trend.
<BR>About special versions with the prefixes <I>VFs_</I> and <I>VFl_</I>, consult <a href="HANDBOOK.HTM#chap4_8">chapter&nbsp;4.8.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If size is not a power of 2, <I><a href="#FFT">VF_FFT</a></I> (on which <I>VF_filter</I> is based) complains &quot;Size must be an integer power of 2&quot; and the program is aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#FFT">VF_FFT</a>,&nbsp;&nbsp; <a href="#convolve">VF_convolve</a>,&nbsp;&nbsp; <a href="#autocorr">VF_autocorr</a>,&nbsp;&nbsp; <a href="#xcorr">VF_xcorr</a>,&nbsp;&nbsp; <a href="#spectrum">VF_spectrum</a>,&nbsp;&nbsp; <a href="#smooth">VF_smooth</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="findAxes"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_findAxes</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Calculate an appropriate scaling and draw a Cartesian coordinate system.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void V_findAxes( long double Xmin, long double Xmax, long double Ymin, long double Ymax );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure V_findAxes( xmin, xmax, ymin, ymax:Extended );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function will rarely be called by the user, but is used internally in <I><a href="#xyAutoPlot">VF_xyAutoPlot</a></I> and other plotting functions. According to the x- and y ranges given in the parameters Xmin, Xmax, Ymin and Ymax, a linear Cartesian coordinate system is drawn with ten subdivisions both for the abscissa and the ordinate. If necessary, the x and y ranges are enlarged so as to meet the following conditions:
<BR>1. Every subdivision line represents an exact (and not only a rounded) value.
<BR>2. If the range of one axis or both includes zero, zero falls exactly on a subdivision line.
<P>If the automatic scaling is not desired, use <I><a href="#drawAxes">V_drawAxes</a></I> instead.
<BR>Before calling <I>V_findAxes</I>, the plotting routines have to be initialized by either <I><a href="#initGraph">V_initGraph</a></I> or <I><a href="#initPlot">V_initPlot</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#drawAxes">V_drawAxes</a>,&nbsp;&nbsp; <a href="#initPlot">V_initPlot</a>,&nbsp;&nbsp; <a href="#xyAutoPlot">VF_xyAutoPlot</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="floor"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_floor</b></font></td><td width="33%"><font size="+1"><b>VD_floor</b></font></td><td><font size="+1"><b>VE_floor</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_floortoI</b></font></td><td width="33%"><font size="+1"><b>VD_floortoI</b></font></td><td><font size="+1"><b>VE_floortoI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_floortoBI</b></font></td><td width="33%"><font size="+1"><b>VD_floortoBI</b></font></td><td><font size="+1"><b>VE_floortoBI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_floortoSI</b></font></td><td width="33%"><font size="+1"><b>VD_floortoSI</b></font></td><td><font size="+1"><b>VE_floortoSI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_floortoLI</b></font></td><td width="33%"><font size="+1"><b>VD_floortoLI</b></font></td><td><font size="+1"><b>VE_floortoLI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_floortoQI</b></font></td><td width="33%"><font size="+1"><b>VD_floortoQI</b></font></td><td><font size="+1"><b>VE_floortoQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_floortoU</b></font></td><td width="33%"><font size="+1"><b>VD_floortoU</b></font></td><td><font size="+1"><b>VE_floortoU</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_floortoUB</b></font></td><td width="33%"><font size="+1"><b>VD_floortoUB</b></font></td><td><font size="+1"><b>VE_floortoUB</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_floortoUS</b></font></td><td width="33%"><font size="+1"><b>VD_floortoUS</b></font></td><td><font size="+1"><b>VE_floortoUS</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_floortoUL</b></font></td><td width="33%"><font size="+1"><b>VD_floortoUL</b></font></td><td><font size="+1"><b>VE_floortoUL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_floortoUI</b></font></td><td width="33%"><font size="+1"><b>VD_floortoUI</b></font></td><td><font size="+1"><b>VE_floortoUI</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Rounding towards minus infinity</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_floor( fVector Y, fVector X, ui size );
<BR>int VF_floortoI( iVector Y, fVector X, ui size );
<BR>int VF_floortoLI( liVector Y, fVector X, ui size );
<BR>int VF_floortoU( uVector Y, fVector X, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all others)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::floor( const vector&lt;T&gt;& X );
<BR>int vector&lt;int&gt;::floortoI( const vector&lt;T&gt;& X );
<BR>int vector&lt;long&gt;::floortoLI( const vector&lt;T&gt;& X );
<BR>int vector&lt;unsigned&gt;::floortoU( const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_floor( Y, X:fVector; size:UInt ):IntBool;
<BR>function VF_floortoI( Y:iVector; X:fVector; size:UInt ):IntBool;
<BR>function VF_floortoLI( Y:liVector; X:fVector; size:UInt ):IntBool;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all others)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of X is rounded to the nearest whole number that is less than or equal to the input number and the result stored in Y. The functions <I>VF_floortoI,&nbsp;&nbsp; VF_floortoLI,&nbsp;&nbsp; VF_floortoU</I>, etc. convert the result to the various integer data types (in the cases mentioned, to the types int, long int, or unsigned, respectively).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors are handled by setting the result to the extreme value possible. Negative numbers in the versions <I>VF_floortoU,&nbsp;&nbsp; VF_floortoUS,&nbsp;&nbsp; VF_floortoUL</I>, and <I>VF_floortoUI</I> lead to DOMAIN errors; they are handled by setting the result to 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#round">VF_round</a>,&nbsp;&nbsp; <a href="#ceil">VF_ceil</a>,&nbsp;&nbsp; <a href="#chop">VF_chop</a>,&nbsp;&nbsp; <a href="#trunc">VF_trunc</a>,&nbsp;&nbsp; ceil,&nbsp;&nbsp; floor</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="flush0"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_flush0</b></font></td><td width="33%"><font size="+1"><b>VD_flush0</b></font></td><td><font size="+1"><b>VE_flush0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_flush0</b></font></td><td width="33%"><font size="+1"><b>VCD_flush0</b></font></td><td><font size="+1"><b>VCE_flush0</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sets vector elements with an absolute value less than a certain threshold to 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_flush0( fVector Y, fVector X, ui size, float AbsMin );
<BR>void VCF_flush0( fVector Y, fVector X, ui size, fComplex AbsMin );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::flush0( const vector&lt;T&gt;& X, T AbsMin );
<BR>void vector&lt;T&gt;::flush0( const vector&lt;T&gt;& X, complex&lt;T&gt; AbsMin );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_flush0( Y, X:fVector; size:UInt; AbsMin:Single );
<BR>procedure VCF_flush0( Y, X:cfVector; size:UInt; AbsMin:fComplex );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>i</sub>, if | X<sub>i</sub> | &gt;= AbsMin,
<BR>Y<sub>i</sub> = 0, otherwise
<BR>The complex versions treat the real and imaginary parts separately, using the real and imaginary parts of AbsMin to determine where to cut. If only the imaginary part is to be edited, set the real part of AbsMin to zero, e.g. (for C/C++):
<BR><font face="courier new">VCF_flush0( Y, X, size, fcplx( 0, 1.e-6 ));</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#limit">VF_limit</a>,&nbsp;&nbsp; <a href="#maxC">VF_maxC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="fmodC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_fmodC</b></font></td><td width="33%"><font size="+1"><b>VD_fmodC</b></font></td><td><font size="+1"><b>VE_fmodC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_fmodV</b></font></td><td width="33%"><font size="+1"><b>VD_fmodV</b></font></td><td><font size="+1"><b>VE_fmodV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_fmodV</b></font></td><td width="33%"><font size="+1"><b>VDx_fmodV</b></font></td><td><font size="+1"><b>VEx_fmodV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Floating-point modulo division</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_fmodC( fVector Y, fVector X, ui size, float C );
<BR>void VF_fmodV( fVector Z, fVector X, fVector Y, ui size );
<BR>void VFx_fmodV( fVector Z, fVector X, fVector Y, ui size, float A, float B );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::fmodC( const vector&lt;T&gt;& X, T C );
<BR>void vector&lt;T&gt;::fmodV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y );
<BR>void vector&lt;T&gt;::x_fmodV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y, T A, T B );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td>These functions are not defined. Use <I><a href="#modC">VF_modC</a>,&nbsp;&nbsp; <a href="#modV">VF_modV</a></I>, etc.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>These functions have been included in order to provide consistency with ANSI C function names. They are implemented as macros that call <I><a href="#modC">VF_modC</a>,&nbsp;&nbsp; <a href="#modV">VF_modV</a>,&nbsp;&nbsp; <a href="#modV">VFx_modV</a></I> etc. See these functions for details.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="fprint"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_fprint</b></font></td><td width="33%"><font size="+1"><b>VD_fprint</b></font></td><td><font size="+1"><b>VE_fprint</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_fprint</b></font></td><td width="33%"><font size="+1"><b>VCD_fprint</b></font></td><td><font size="+1"><b>VCE_fprint</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_fprint</b></font></td><td width="33%"><font size="+1"><b>VPD_fprint</b></font></td><td><font size="+1"><b>VPE_fprint</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_fprint</b></font></td><td width="20%"><font size="+1"><b>VBI_fprint</b></font></td><td width="20%"><font size="+1"><b>VSI_fprint</b></font></td><td width="20%"><font size="+1"><b>VLI_fprint</b></font></td><td><font size="+1"><b>VQI_fprint</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_fprint</b></font></td><td width="20%"><font size="+1"><b>VUB_fprint</b></font></td><td width="20%"><font size="+1"><b>VUS_fprint</b></font></td><td width="20%"><font size="+1"><b>VUL_fprint</b></font></td><td><font size="+1"><b>VUI_fprint</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>print a vector to a stream</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_fprint( FILE *stream, fVector X, ui size, unsigned nperline, unsigned linewidth );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::fprint( FILE *stream, unsigned nperline, unsigned linewidth );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_fprint( var Stream:Text; X:fVector; size, nperline, linewidth:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>size elements of X are written to stream, nperline in each line of linewidth characters.
<P>Printing starts always with a new line. This may lead to an empty line at the beginning. Especially the first line of a file is reserved for a possible headline.
<P>Each line begins with the index of the first element printed into that line. The index is followed by a colon and by the requested nperline elements.
<BR>Cartesian complex numbers are printed in braces, with the real and imaginary parts separated by a komma: {Re, Im}. Polar complex numbers are also written in braces, with the Mag and Arg parts separated by an at-sign: {Mag @ Arg}.
<P>In contrast to <I><a href="#write">VF_write</a></I> and <I><a href="#nwrite">VF_nwrite</a></I>, it is not possible to override the automatic choice of the format used for printing. The number of digits per element is determined by the available space, which depends in turn on the parameters nperline and linewidth.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>if nperline exceeds the maximum number of entries possible for the linewidth chosen, an error message &quot;Cannot use requested format (too many entries per line)!&quot; is generated; in this case, the program chooses the maximum number nperline possible.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cprint">VF_cprint</a>,&nbsp;&nbsp; <a href="#print">VF_print</a>,&nbsp;&nbsp; <a href="#write">VF_write</a>,&nbsp;&nbsp; <a href="#store">VF_store</a>,&nbsp;&nbsp; fprintf</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="free"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_free</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>De-allocate a single vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>void V_free( void *X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>procedure V_free( Ptr:Pointer );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector X is freed (i.e. de-allocated). <I>V_free</I> should be used only for the de-allocation of vectors which have previously be allocated by one of the functions of the <I><a href="#vector">VF_vector</a></I> or <I><a href="#vector0">VF_vector0</a></I> family. To free several vectors simultaneously, use <I><a href="#nfree">V_nfree</a></I> (C/C++ only).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Trying to free a vector that has already been freed, or that has never been allocated memory, leads to a warning message &quot;Cannot free non-existent vector&quot;. Program execution is continued without freeing anything in this case.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#nfree">V_nfree</a>,&nbsp;&nbsp; <a href="#freeAll">V_freeAll</a>,&nbsp;&nbsp; <a href="#vector">VF_vector</a>,&nbsp;&nbsp; <a href="#vector0">VF_vector0</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="freeAll"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_freeAll</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>De-allocate all vectors (and matrices)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>void V_freeAll( void );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>procedure V_freeAll;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>All vectors and matrices previously allocated by one of the functions of the <I><a href="#vector">VF_vector</a>,&nbsp;&nbsp; <a href="#vector0">VF_vector0</a></I>, or <I><a href="MATRIX.HTM#matrix">MF_matrix</a></I> families are freed.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#free">V_free</a>,&nbsp;&nbsp; <a href="#nfree">V_nfree</a>,&nbsp;&nbsp; <a href="#vector">VF_vector</a>,&nbsp;&nbsp; <a href="#vector0">VF_vector0</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="frexp"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_frexp</b></font></td><td width="33%"><font size="+1"><b>VD_frexp</b></font></td><td><font size="+1"><b>VE_frexp</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Split up the elements of a vector into their mantissa and exponent parts.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_frexp( fVector Mant, iVector Exp, fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::frexp( vector&lt;int&gt; Exp, const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td>These functions are not available for Pascal/Delphi;</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The function is implemented as a macro calling <I><a href="#mantexp">VF_mantexp</a></I>; the name <I>VF_frexp</I> is included only to maintain consistency with the ANSI C function name frexp. For details, see <I><a href="#mantexp">VF_mantexp</a></I> and <I>frexp</I>.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="fsum"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%">
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>VI_fsum</b></font></td><td width="25%"><font size="+1"><b>VSI_fsum</b></font></td><td width="25%"><font size="+1"><b>VLI_fsum</b></font></td><td><font size="+1"><b>VQI_fsum</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>VU_fsum</b></font></td><td width="25%"><font size="+1"><b>VUS_fsum</b></font></td><td width="25%"><font size="+1"><b>VUL_fsum</b></font></td><td><font size="+1"><b>VUI_fsum</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="16%">Function</td><td>sum of the elements of an integer vector, returned in floating-point</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="16%">Syntax C/C++</td><td><font face="courier new">#include &lt;VIstd.h&gt;
<BR>double VI_fsum( iVector X, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VBI_,&nbsp;&nbsp; VSI_,&nbsp;&nbsp; VLI_,&nbsp;&nbsp; VU_,&nbsp;&nbsp; VUB_,&nbsp;&nbsp; VUS_,&nbsp;&nbsp; VUL_,&nbsp;&nbsp; VUI_</I>)
<BR><font face="courier new">extended VQI_fsum( qiVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>double vector&lt;int&gt;::fsum();
<BR>extended vector&lt;quad&gt;::fsum();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VIstd;
<BR>function VI_fsum( X:iVector; size:UInt ); Double;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VBI_,&nbsp;&nbsp; VSI_,&nbsp;&nbsp; VLI_,&nbsp;&nbsp; VU_,&nbsp;&nbsp; VUB_,&nbsp;&nbsp; VUS_,&nbsp;&nbsp; VUL_</I>)
<BR><font face="courier new">function VQI_fsum( X:qiVector; size:UInt ); Extended;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="16%">Description</td><td>The elements of X are summed up. In order to avoid possible overflow, the sum is accumulated in a floating-point number. The 8, 16, and 32 bit variants return the result in <B>double</B> precision, whereas the 64 bit variant, <I>VQI_fsum</I>, returns an <B>extended</B>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="16%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="16%">Return value</td><td>the sum in floating-point format</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="16%">See also</td><td><I><a href="#sum">VF_sum</a>,&nbsp;&nbsp; <a href="#mean">VF_mean</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="FtoD"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_FtoD</b></font></td><td width="25%"><font size="+1"><b>V_FtoE</b></font></td><td width="25%"><font size="+1"><b>V_CFtoCD</b></font></td><td><font size="+1"><b>V_CFtoCE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_DtoF</b></font></td><td width="25%"><font size="+1"><b>V_DtoE</b></font></td><td width="25%"><font size="+1"><b>V_CDtoCF</b></font></td><td><font size="+1"><b>V_CDtoCE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_EtoF</b></font></td><td width="25%"><font size="+1"><b>V_EtoD</b></font></td><td width="25%"><font size="+1"><b>V_CEtoCF</b></font></td><td><font size="+1"><b>V_CEtoCD</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Data type interconversions.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VDstd.h&gt;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(always include the <font face="courier new">&lt;V..std.h&gt;</font> file of the destination data-type!)
<BR><font face="courier new">void V_FtoD( dVector Y, fVector X, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;double&gt;::FtoD( const vector&lt;float&gt;& Y );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VDstd;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(always include the unit of the destination data-type!)
<BR><font face="courier new">procedure V_FtoD( Y:dVector; X:fVector; size:UInt );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of X is converted from the data type specified for X to the data type specified for Y and stored in Y.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors in the course of the &quot;down-conversions&quot; (e.g., <I>V_EtoF</I>); are silently handled: the extreme value possible for the destination data type is stored in Y with the correct sign. <I>_matherr</I> is not called.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ItoF">V_ItoF</a>,&nbsp;&nbsp; <a href="#round">V_roundtoI</a>,&nbsp;&nbsp; <a href="#round">V_roundtoLI</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="Gauss"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_Gauss</b></font></td><td width="33%"><font size="+1"><b>VD_Gauss</b></font></td><td><font size="+1"><b>VE_Gauss</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Gaussian normal distribution function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_Gauss( fVector Y, fVector X, ui size, float Wid, float Cent, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::Gauss( const vector&lt;T&gt;& X, T Wid, T Cent, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_Gauss( Y, X:fVector; size:UInt; Wid, Cent, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = C / (Wid * sqrt(2*<font face="symbol">p</font>)) * exp( -0.5*((X<sub>i</sub>-Cent) / Wid)<sup>2</sup> )
<BR>Wid = width of the distribution
<BR>Cent = center of the distribution
<BR>C is a scaling factor; for C = 1.0, the distribution is normalized.
<BR>For Wid = 0, the normal distribution is in fact a delta distribution with Y = C * INF at X = Cent and Y = 0 at all other values of X.
<BR>Since infinities are not supported, the existence of a point X = Cent will lead to a SING error in case Wid is zero.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>SING errors may occur only for a Wid of zero. They are handled with the default result set to &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#expmx2">VF_expmx2</a>,&nbsp;&nbsp; <a href="#erf">VF_erf</a>,&nbsp;&nbsp; <a href="#sech2">VF_sech2</a>,&nbsp;&nbsp; <a href="#Lorentz">VF_Lorentz</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="getCoordSystem"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_getCoordSystem</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Store the scalings and position of the current coordinate system used for <I>VectorLib</I> plotting operations</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void V_getCoordSystem( VCOORDSYSTEM *csys );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure V_getCoordSystem( var csys: VCOORDSYSTEM );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>If one wants to &quot;hop&quot; between several coordinate systems, displayed in one and the same window, one has to store the specifications (position and scalings) of each coordinate system separately, using this function. 
<BR>The address of a struct VCOORDSYSTEM is needed as the argument. VCOORDSYSTEM is defined in <font face="courier new">&lt;Vgraph.h&gt;</font> (C/C++) or the unit Vgraph (Pascal/Delphi).</td></tr>
<tr valign="TOP">
<td>Example C/C++</td><td><font face="courier new">VCOORDSYSTEM csys1;
<BR>&nbsp;&nbsp;&nbsp;....
<BR>&nbsp;&nbsp;/* create the first plot: */
<BR><a href="#setPlotRegion">V_setPlotRegion</a>( 0, 0, 339, 200 );
<BR><a href="#xyAutoPlot">VF_xyAutoPlot</a>( X1, Y1, size1, PS_SOLID, LightGreen );
<BR>V_getCoordSystem( &csys1 ); /* store for later */
<BR>&nbsp;&nbsp;&nbsp;/* create the second plot: */
<BR>V_setPlotRegion( 340, 0, 679, 200 );
<BR>VF_xyAutoPlot( X2, Y2, size2, PS_SOLID, LightRed );
<BR>&nbsp;&nbsp;&nbsp;/* go back to the first plot: */
<BR><a href="#setCoordSystem">VF_setCoordSystem</a>( &csys1 );
<BR>&nbsp;&nbsp;&nbsp;/* add an additional DataPlot: */
<BR><a href="#xyDataPlot">VF_xyDataPlot</a>( X1, Z1, size1, PS_SOLID, LightBlue );</font></td></tr>
<tr valign="TOP">
<td>Example Pascal/Delphi</td><td><font face="courier new">var cxyx1: VCOORDSYSTEM;
<BR>begin
<BR>&nbsp;&nbsp;&nbsp;....
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(* create the first plot: *)
<BR>&nbsp;&nbsp;&nbsp;<a href="#setPlotRegion">V_setPlotRegion</a>( 0, 0, 339, 200 );
<BR>&nbsp;&nbsp;&nbsp;<a href="#xyAutoPlot">VF_xyAutoPlot</a>( X1, Y1, size1, PS_SOLID, LightGreen );
<BR>&nbsp;&nbsp;&nbsp;V_getCoordSystem( csys1 ); (* store for later *)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(* create the second plot: *)
<BR>&nbsp;&nbsp;&nbsp;V_setPlotRegion( 340, 0, 679, 200 );
<BR>&nbsp;&nbsp;&nbsp;VF_xyAutoPlot( X2, Y2, size2, PS_SOLID, LightRed );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(* go back to the first plot: *)
<BR>&nbsp;&nbsp;&nbsp;<a href="#setCoordSystem">VF_setCoordSystem</a>( csys1 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(* add an additional DataPlot: *)
<BR>&nbsp;&nbsp;&nbsp;<a href="#xyDataPlot">VF_xyDataPlot</a>( X1, Z1, size1, PS_SOLID, LightBlue );
<BR>end;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#setCoordSystem">V_setCoordSystem</a>,&nbsp;&nbsp; <a href="#setPlotRegion">V_setPlotRegion</a>,&nbsp;&nbsp; <a href="#continuePlot">V_continuePlot</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="getFPAccuracy"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_getFPAccuracy</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Test the actual precision the coprocessor is switched to</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>unsigned  V_getFPAccuracy( void );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>function V_getFPAccuracy: UInt;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function reads the FPU Control-Word. If the FPU is set to <B>float / Single</B> precision, 1 is returned. In case of <B>double</B> precision, the return value is 2, and <B>extended</B> precision yields 3. In order to change the coprocessor precision, use the (non-standardized) functions offered by the various compilers, or the <I>OptiVec</I> function <I><a href="#setFPAccuracy">V_setFPAccuracy</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>1, 2, or 3</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#setFPAccuracy">V_setFPAccuracy</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="getRspEdit"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_getRspEdit</b></font></td><td width="33%"><font size="+1"><b>VD_getRspEdit</b></font></td><td><font size="+1"><b>VE_getRspEdit</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Read the present threshold for the editing of the filter in <I><a href="#convolve">VF_convolve</a></I> and <I><a href="#deconvolve">VF_deconvolve</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>fComplex VF_getRspEdit( void );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>complex &lt;T&gt; vector&lt;T&gt;::getRspEdit();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_getRspEdit( var Trunc:fComplex );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The threshold for the treatment of round-off errors in the functions for convolution and deconvolution is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>present threshold.
<BR>real part: acts on the real parts of the filter elements<BR>imaginary part: acts on the imaginary parts of the filter elements</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#setRspEdit">VF_setRspEdit</a>,&nbsp;&nbsp; <a href="#convolve">VF_convolve</a>,&nbsp;&nbsp; <a href="#deconvolve">VF_deconvolve</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="Hanning"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_Hanning</b></font></td><td width="33%"><font size="+1"><b>VD_Hanning</b></font></td><td><font size="+1"><b>VE_Hanning</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;Hanning&quot; window for use in spectral analysis</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_Hanning( fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::Hanning();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_Hanning( X:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X<sub>i</sub> = 0.5 * (1 - cos( 2 <font face="symbol">p</font> i / (size-1) ))</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#Welch">VF_Welch</a>,&nbsp;&nbsp; <a href="#Parzen">VF_Parzen</a>,&nbsp;&nbsp; <a href="#spectrum">VF_spectrum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="hypC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_hypC</b></font></td><td width="33%"><font size="+1"><b>VD_hypC</b></font></td><td><font size="+1"><b>VE_hypC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Quotient of X<sub>i</sub> over the sum of X<sub>i</sub> and a constant.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_hypC( fVector Y, fVector X, ui size, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::hypC( const vector&lt;T&gt;& X, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_hypC( Y, X:fVector; size:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = hyp( X<sub>i</sub>, C ) = X<sub>i</sub> / (X<sub>i</sub> + C)
<BR>The function calculating Y<sub>i</sub> according to this formula is dubbed &quot;hyp&quot; for its formal similarity to the expression constructing a hyperbola.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#hypV">VF_hypV</a>,&nbsp;&nbsp; <a href="#redC">VF_redC</a>,&nbsp;&nbsp; <a href="#addC">VF_addC</a>,&nbsp;&nbsp; <a href="#subC">VF_subC</a>,&nbsp;&nbsp; <a href="#divC">VF_divC</a>,&nbsp;&nbsp; <a href="#visC">VF_visC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="hypV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_hypV</b></font></td><td width="33%"><font size="+1"><b>VD_hypV</b></font></td><td><font size="+1"><b>VE_hypV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_hypV</b></font></td><td width="33%"><font size="+1"><b>VDx_hypV</b></font></td><td><font size="+1"><b>VEx_hypV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Quotient of X<sub>i</sub> over the sum of X<sub>i</sub> and Y<sub>i</sub></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_hypV( fVector Z, fVector X, fVector Y, ui size );
<BR>void VFx_hypV( fVector Z, fVector X, fVector Y, ui size, float A, float B );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::hypV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y );
<BR>void vector&lt;T&gt;::x_hypV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y, T A, T B );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_hypV( Z, X, Y:fVector; size:UInt );
<BR>procedure VFx_hypV( Z, X, Y:fVector; size:UInt; A, B:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Z<sub>i</sub> = hyp( X<sub>i</sub>, Y<sub>i</sub> ) = X<sub>i</sub> / (X<sub>i</sub> + Y<sub>i</sub>)
<BR>expanded versions: Z<sub>i</sub> = hyp( A*X<sub>i</sub>+B), Y<sub>i</sub> )</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#hypC">VF_hypC</a>,&nbsp;&nbsp; <a href="#redV">VF_redV</a>,&nbsp;&nbsp; <a href="#addV">VF_addV</a>,&nbsp;&nbsp; <a href="#subV">VF_subV</a>,&nbsp;&nbsp; <a href="#divV">VF_divV</a>,&nbsp;&nbsp; <a href="#visV">VF_visV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="hypotC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_hypotC</b></font></td><td width="33%"><font size="+1"><b>VD_hypotC</b></font></td><td><font size="+1"><b>VE_hypotC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Pythagoras &quot;hypotenuse&quot; function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_hypotC( fVector Y, fVector X, ui size, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::hypotC( const vector&lt;T&gt;& X, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_hypotC( Y, X:fVector; size:UInt; C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = sqrt( X<sub>i</sub><sup>2</sup> + C<sup>2</sup> )
<BR>This is a variant of the famous Pythagorean theorem for the hypotenuse of a right triangle.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of HUGE_VAL. Unlike the treatment of the ANSI C function hypot by several compilers, only an overflowing final result is regarded as an error. Intermediate overflows (by the calculation of the square) are avoided by appropriate scaling.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#hypotV">VF_hypotV</a>,&nbsp;&nbsp; <a href="#redC">VF_redC</a>,&nbsp;&nbsp; <a href="#visC">VF_visC</a>,&nbsp;&nbsp; <a href="#abs">VCF_abs</a>,&nbsp;&nbsp; hypot</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="hypotV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_hypotV</b></font></td><td width="33%"><font size="+1"><b>VD_hypotV</b></font></td><td><font size="+1"><b>VE_hypotV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_hypotV</b></font></td><td width="33%"><font size="+1"><b>VDx_hypotV</b></font></td><td><font size="+1"><b>VEx_hypotV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Pythagoras &quot;hypotenuse&quot; function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_hypotV( fVector Z, fVector X, fVector Y, ui size );
<BR>int VFx_hypotV( fVector Z, fVector X, fVector Y, ui size, float A, float B );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::hypotV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y );
<BR>int vector&lt;T&gt;::x_hypotV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y, T A, T B );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_hypotV( Z, X, Y:fVector; size:UInt ): IntBool;
<BR>function VFx_hypotV( Z, X, Y:fVector; size:UInt; A, B:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal version: Y<sub>i</sub> = sqrt( X<sub>i</sub><sup>2</sup> + Y<sub>i</sub><sup>2</sup> )
<BR>expanded version: Y<sub>i</sub> = sqrt( (A*X<sub>i</sub>+B)<sup>2</sup> + Y<sub>i</sub><sup>2</sup> )
<BR>These are variants of the Pythagoras formula for the hypotenuse of a right triangle.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of HUGE_VAL. (Intermediate overflows are avoided by appropriate scaling.)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#redC">VF_redC</a>,&nbsp;&nbsp; <a href="#visC">VF_visC</a>,&nbsp;&nbsp; <a href="#abs">VCF_abs</a>,&nbsp;&nbsp; hypot</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="imag"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_imag</b></font></td><td width="33%"><font size="+1"><b>VCD_imag</b></font></td><td><font size="+1"><b>VCE_imag</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_imag</b></font></td><td width="33%"><font size="+1"><b>VPD_imag</b></font></td><td><font size="+1"><b>VPE_imag</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Extracts the imaginary part from a complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VCF_imag( fVector Im, cfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::imag( const vector&lt;complex&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VCF_imag( Im:fVector; X:cfVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Identical to the <I><a href="#CtoIm">VF_CtoIm</a></I> and <I><a href="#PtoIm">VF_PtoIm</a></I> families. See these functions for details.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ImtoC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ImtoC</b></font></td><td width="33%"><font size="+1"><b>VD_ImtoC</b></font></td><td><font size="+1"><b>VE_ImtoC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Overwrites the imaginary part of a cartesian-complex vector with a real-valued vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VF_ImtoC( cfVector Y, fVector Im, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;complex&lt;T&gt;&gt;::ImtoC( const vector&lt;T&gt;& Im );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VF_ImtoC( X:cfVector; Im:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The imaginary part of the complex vector Y is overwritten with the elements of the real-valued vector Im. The real part of Y is not affected.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#CtoReIm">VF_CtoReIm</a>,&nbsp;&nbsp; <a href="#ReImtoC">VF_ReImtoC</a>,&nbsp;&nbsp; <a href="#RetoC">VF_RetoC</a>,&nbsp;&nbsp; <a href="#CtoIm">VF_CtoIm</a>,&nbsp;&nbsp; <a href="#PolartoC">VF_PolartoC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="indpick"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_indpick</b></font></td><td width="33%"><font size="+1"><b>VD_indpick</b></font></td><td><font size="+1"><b>VE_indpick</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_indpick</b></font></td><td width="33%"><font size="+1"><b>VCD_indpick</b></font></td><td><font size="+1"><b>VCE_indpick</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_indpick</b></font></td><td width="33%"><font size="+1"><b>VPD_indpick</b></font></td><td><font size="+1"><b>VPE_indpick</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_indpick</b></font></td><td width="20%"><font size="+1"><b>VBI_indpick</b></font></td><td width="20%"><font size="+1"><b>VSI_indpick</b></font></td><td width="20%"><font size="+1"><b>VLI_indpick</b></font></td><td><font size="+1"><b>VQI_indpick</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_indpick</b></font></td><td width="20%"><font size="+1"><b>VUB_indpick</b></font></td><td width="20%"><font size="+1"><b>VUS_indpick</b></font></td><td width="20%"><font size="+1"><b>VUL_indpick</b></font></td><td><font size="+1"><b>VUI_indpick</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Fill a vector with elements &quot;picked&quot; from another one according to their indices.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_indpick( fVector Y, uiVector Ind, ui size, fVector X );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::indpick( const vector&lt;ui&gt;& Ind, const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_indpick( Y:fVector; Ind:uVector; size:UInt; X:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X[ Ind<sub>i</sub> ],&nbsp;&nbsp;&nbsp;i=0,..size-1
<BR>The vector Y is filled with size elements taken from X according to their indices specified in Ind. The parameter size refers to Y and Ind. The size of X is unimportant, as long as the elements specified in Ind exist.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#indput">VF_indput</a>,&nbsp;&nbsp; <a href="#subvector">VF_subvector</a>,&nbsp;&nbsp; <a href="#sortind">VF_sortind</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="indput"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_indput</b></font></td><td width="33%"><font size="+1"><b>VD_indput</b></font></td><td><font size="+1"><b>VE_indput</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_indput</b></font></td><td width="33%"><font size="+1"><b>VCD_indput</b></font></td><td><font size="+1"><b>VCE_indput</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_indput</b></font></td><td width="33%"><font size="+1"><b>VPD_indput</b></font></td><td><font size="+1"><b>VPE_indput</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_indput</b></font></td><td width="20%"><font size="+1"><b>VBI_indput</b></font></td><td width="20%"><font size="+1"><b>VSI_indput</b></font></td><td width="20%"><font size="+1"><b>VLI_indput</b></font></td><td><font size="+1"><b>VQI_indput</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_indput</b></font></td><td width="20%"><font size="+1"><b>VUB_indput</b></font></td><td width="20%"><font size="+1"><b>VUS_indput</b></font></td><td width="20%"><font size="+1"><b>VUL_indput</b></font></td><td><font size="+1"><b>VUI_indput</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Distribute the elements of one vector to the places within another vector specified by their indices.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_indput( fVector Y, fVector X, uiVector Ind, ui sizex );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::indput( const vector&lt;T&gt;& X, const vector&lt;ui&gt;& Ind );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_indput( Y, X:fVector; Ind:uVector; sizex:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y[ Ind<sub>i</sub> ] = X<sub>i</sub>,&nbsp;&nbsp;&nbsp;i=0,..sizex-1
<BR>The sizex elements of X are put into the places of Y according to the indices specified in Ind. The parameter sizex refers to X and Ind. The size of Y is unimportant, as long as the elements specified in Ind exist.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#indpick">VF_indpick</a>,&nbsp;&nbsp; <a href="#subvector">VF_subvector</a>,&nbsp;&nbsp; <a href="#sortind">VF_sortind</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="initGraph"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_initGraph</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initializes Borland's graphics system and the plotting functions of the <I>VectorLib</I> library (DOS only).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void V_initGraph( char *pathtodriver );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure V_initGraph( BGI_path:String );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>In DOS programs, this function is used to initialize Borland's graphics system by calling Borland's function <I>initgraph</I> and to initialize the <I>VectorLib</I> plotting functions (by internally calling <I><a href="#initPlot">V_initPlot</a></I>).
<BR>The search-path for graphics driver files has to be passed as a pointer to the string pathtodriver (see Borland's function <I>initgraph</I> for details).
<BR>The function uses <I>initgraph</I> to automatically detect the graphics driver present. This automatic detection ensures that programs may run on different PC systems without changes in the source code. If, however, it causes problems or for other reasons is not desired, do not use <I>V_initGraph</I> (but first <I>initgraph</I> and then <I><a href="#initPlot">V_initPlot</a></I>). The global variable <I>V_gmode</I> is set to the graphics mode with the highest resolution possible for the detected graphics driver. If <I>initgraph</I> has already been called, do not use <I>V_initGraph</I>, but call only <I><a href="#initPlot">V_initPlot</a></I>. Normally, <I>V_initGraph</I> will be called at the beginning of a program that uses graphics; to switch back into text mode within the program, use restorecrtmode. The next call to one of the AutoPlot functions switches again into graphics mode. You may also do that yourself by using 
<BR><font face="courier new">&nbsp;&nbsp;setgraphmode( V_gmode );</font>
<BR>(to do this, the declaration
<BR><font face="courier new">&nbsp;&nbsp;external int V_gmode;</font>
<BR>has to appear in the module containing this call).
<BR>At the end of the program, free the memory allocated for graphics operations and go back to the standard mode with <I>closegraph</I>.
<P>Windows programs do not use the BGI routines. Consequently, BGI initialization is available only under DOS, but not under Windows. <I><a href="#initPlot">V_initPlot</a></I> has to be used in order to prepare the <I>OptiVec</I> plotting operations under Windows.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>In case of failure, <I>grapherrormsg</I> is called, the appropriate error message displayed and the program aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#initPlot">V_initPlot</a>,&nbsp;&nbsp; <a href="#setPlotRegion">V_setPlotRegion</a>,&nbsp;&nbsp; <a href="#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#yAutoPlot">VF_yAutoPlot</a>,&nbsp;&nbsp; <a href="#xyDataPlot">VF_xyDataPlot</a>,&nbsp;&nbsp; <a href="#autoPlot">VCF_autoPlot</a>,&nbsp;&nbsp; initgraph,&nbsp;&nbsp; closegraph</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="initPlot"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_initPlot</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initialize the global variables used by the plotting functions</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>#ifdef _Windows
<BR>&nbsp;&nbsp;&nbsp;&nbsp;void V_initPlot( HWND vwindow, HDC vdc );
<BR>#else
<BR>&nbsp;&nbsp;&nbsp;&nbsp;void V_initPlot( int graphmode );
<BR>#endif</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><u>for Delphi:</u>
<BR><font face="courier new">uses Vgraph;
<BR>procedure V_initPlot( VPaintBox: TPaintBox );</font>
<BR><u>for Borland Pascal:</u>
<BR><font face="courier new">uses Vgraph;
<BR>{$ifdef Windows}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;procedure V_initPlot( vwindow:HWND; vdc:HDC );
<BR>{$else}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;procedure V_initPlot( graphmode:Integer );
<BR>{$endif}</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><u>DOS programs:</u> If the graphics system has been initialized by a call to <I>initgraph,&nbsp;&nbsp; V_initPlot</I> is used to initialize the global constants necessary for the operation of the <I>VectorLib</I> plotting functions like <I><a href="#xyAutoPlot">VF_xyAutoPlot</a></I>. If the graphics system is not yet initialized, use <I><a href="#initGraph">V_initGraph</a></I> to initialize both the basic graphics system and the plotting functions; a call to <I>V_initPlot</I> is not necessary then. graphmode is the graphics mode set by <I>initgraph</I>.
<P><u>C/C++ and Pascal Windows programs:</u>
<BR>vwindow is the handle for a window and vdc the handle of a device context. As long as these handles remain valid, future plotting operations (like <I><a href="#xyAutoPlot">VF_xyAutoPlot</a></I>) will be directed to the window specified by vwindow and use the fonts defined in the device context vdc. Be sure that vwindow and vdc are still valid when a plotting operation is performed; if in doubt, call <I>V_initPlot</I> again. The natural place to call <I>V_initPlot</I> is in the virtual element function <I>Paint</I>. Then, the handle of the actual window is made available as &quot;HWindow&quot; by OWL, and the device context is the same as passed as a parameter to <I>Paint</I>.
<P><u>Delphi programs:</u>
<BR>VPaintBox is the paint box into which you wish to get a <I>VectorLib</I> plot. All future <I>VectorLib</I> plotting operations are directed into this paint box, unless you call <I>V_initPlot</I> again, with a new paint box as parameter.
<P><u>all targets (DOS and Windows):</u>
<BR><I>V_initPlot</I> reserves the rightmost about 2/3 of the screen for following plotting operations, leaving one line empty at the top of the screen and a few lines at the bottom. To override this, call <I><a href="#setPlotRegion">V_setPlotRegion</a></I> after <I>V_initPlot</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#initGraph">V_initGraph</a>,&nbsp;&nbsp; <a href="#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#findAxes">V_findAxes</a>,&nbsp;&nbsp; <a href="#drawAxes">V_drawAxes</a>,&nbsp;&nbsp; <a href="#setPlotRegion">V_setPlotRegion</a>,&nbsp;&nbsp; <a href="#initPrint">V_initPrint</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="initPrint"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_initPrint</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initialize <I>VectorLib</I> plotting functions for use with a printer. Windows only!</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void V_initPrint( HDC printdc );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure V_initPrint( printdc: HDC );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function exists only for Windows. It tells the <I>VectorLib</I> plotting functions to send their output to the printer context specified as printdc. By default, one whole page is reserved for the printout. To change this, call <I><a href="#setPlotRegion">V_setPlotRegion</a></I> after <I>V_initPrint</I>.
<BR>To switch back to screen output, call <I><a href="#initPlot">V_initPlot</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#initPlot">V_initPlot</a>,&nbsp;&nbsp; <a href="#setPlotRegion">V_setPlotRegion</a>,&nbsp;&nbsp; <a href="#xyAutoPlot">VF_xyAutoPlot</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="insert"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_insert</b></font></td><td width="33%"><font size="+1"><b>VD_insert</b></font></td><td><font size="+1"><b>VE_insert</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_insert</b></font></td><td width="33%"><font size="+1"><b>VCD_insert</b></font></td><td><font size="+1"><b>VCE_insert</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_insert</b></font></td><td width="33%"><font size="+1"><b>VPD_insert</b></font></td><td><font size="+1"><b>VPE_insert</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_insert</b></font></td><td width="20%"><font size="+1"><b>VBI_insert</b></font></td><td width="20%"><font size="+1"><b>VSI_insert</b></font></td><td width="20%"><font size="+1"><b>VLI_insert</b></font></td><td><font size="+1"><b>VQI_insert</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_insert</b></font></td><td width="20%"><font size="+1"><b>VUB_insert</b></font></td><td width="20%"><font size="+1"><b>VUS_insert</b></font></td><td width="20%"><font size="+1"><b>VUL_insert</b></font></td><td><font size="+1"><b>VUI_insert</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Insert an element into a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_insert( fVector X, ui size, ui pos, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::insert( ui pos, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_insert( X:fVector; size, pos:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This is one of the few functions where the input vector is changed itself (instead of being mapped onto an output vector). A new element is inserted at the position pos and has the value C. Elements before pos are unchanged, elements from pos on are shifted one position higher; the last element is lost. (If you wish to save the last element, choose size big enough to have a dummy element at the end of the vector; now it will be the dummy that gets lost.)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#delete">VF_delete</a>,&nbsp;&nbsp; <a href="#rotate">VF_rotate</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="integralC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_integralC</b></font></td><td width="33%"><font size="+1"><b>VD_integralC</b></font></td><td><font size="+1"><b>VE_integralC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Integral of an array plotted over an equally-spaced abscissa.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_integralC( fVector X, ui size, float DeltaT );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::integralC( T DeltaT );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_integralC( X:fVector; size:UInt; DeltaT:Single ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector X is assumed to be a function of a variable t; the t values themselves are equally spaced, so that only the spacing DeltaT is needed. The area under X, i.e. the integral of X over t from t<sub>0</sub> to t<sub>size-1</sub> is calculated. If not only the value of the integral is of interest, but a point-by-point integration has to be performed, <I><a href="#runintegralC">VF_runintegralC</a></I> should be used.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The value of the integral is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#integralV">VF_integralV</a>,&nbsp;&nbsp; <a href="#runintegralC">VF_runintegralC</a>,&nbsp;&nbsp; <a href="#derivC">VF_derivC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="integralV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_integralV</b></font></td><td width="33%"><font size="+1"><b>VD_integralV</b></font></td><td><font size="+1"><b>VE_integralV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Integral</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_integralV( fVector X, fVector Y, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::integralV( const vector&lt;T&gt;& Y );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_integralV( X, Y:fVector; size:UInt ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector Y is assumed to be a function of X; the integral of Y over X is calculated. If the elements of X are regularly spaced with a constant difference between them, the integral is obtained more efficiently by <I><a href="#integralC">VF_integralC</a></I>. If not only the value of the integral is of interest, but a point-by-point integration has to be performed, <I><a href="#runintegralV">VF_runintegralV</a></I> may be used.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The value of the integral is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#integralC">VF_integralC</a>,&nbsp;&nbsp; <a href="#runintegralV">VF_runintegralV</a>,&nbsp;&nbsp; <a href="#derivV">VF_derivV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="intfrac"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_intfrac</b></font></td><td width="33%"><font size="+1"><b>VD_intfrac</b></font></td><td><font size="+1"><b>VE_intfrac</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Split up the elements of a vector into their integer and fractional parts.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_intfrac( fVector IntPart, fVector FracPart, fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::intfrac( vector&lt;T&gt; FracPart, const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_intfrac( IntPart, FracPart, X:fVector; size:UInt ):IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The integer parts of the elements of X are stored in IntPart, the fractional parts in FracPart. Notice that IntPart is a floating-point vector, even though it contains integer numbers (which might be larger than could be stored in the integer data types).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mantexp">VF_mantexp</a></I>,&nbsp;&nbsp;modf (C/C++ only)</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="inv"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_inv</b></font></td><td width="33%"><font size="+1"><b>VD_inv</b></font></td><td><font size="+1"><b>VE_inv</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_inv</b></font></td><td width="33%"><font size="+1"><b>VDx_inv</b></font></td><td><font size="+1"><b>VEx_inv</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_inv</b></font></td><td width="33%"><font size="+1"><b>VCD_inv</b></font></td><td><font size="+1"><b>VCE_inv</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_inv</b></font></td><td width="33%"><font size="+1"><b>VCDx_inv</b></font></td><td><font size="+1"><b>VCEx_inv</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_inv</b></font></td><td width="33%"><font size="+1"><b>VPD_inv</b></font></td><td><font size="+1"><b>VPE_inv</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Inverse</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_inv( fVector Y, fVector X, ui size );
<BR>int VFx_inv( fVector Y, fVector X, ui size, float A, float B );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::inv( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_inv( const vector&lt;T&gt;& X, T A, T B );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_inv( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_inv( Y, X:fVector; size:UInt; A, B:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = 1.0 / X<sub>i</sub>
<BR>expanded versions: Y<sub>i</sub> = 1.0 / (A*X<sub>i</sub>+B)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>SING and OVERFLOW errors lead to a result of  &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#divrC">VF_divrC</a>,&nbsp;&nbsp; <a href="#divrV">VF_divrV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ipow"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ipow</b></font></td><td width="33%"><font size="+1"><b>VD_ipow</b></font></td><td><font size="+1"><b>VE_ipow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_ipow</b></font></td><td width="33%"><font size="+1"><b>VDx_ipow</b></font></td><td><font size="+1"><b>VEx_ipow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFu_ipow</b></font></td><td width="33%"><font size="+1"><b>VDu_ipow</b></font></td><td><font size="+1"><b>VEu_ipow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFux_ipow</b></font></td><td width="33%"><font size="+1"><b>VDux_ipow</b></font></td><td><font size="+1"><b>VEux_ipow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_ipow</b></font></td><td width="33%"><font size="+1"><b>VCD_ipow</b></font></td><td><font size="+1"><b>VCE_ipow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_ipow</b></font></td><td width="33%"><font size="+1"><b>VCDx_ipow</b></font></td><td><font size="+1"><b>VCEx_ipow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFu_ipow</b></font></td><td width="33%"><font size="+1"><b>VCDu_ipow</b></font></td><td><font size="+1"><b>VCEu_ipow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFux_ipow</b></font></td><td width="33%"><font size="+1"><b>VCDux_ipow</b></font></td><td><font size="+1"><b>VCEux_ipow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_ipow</b></font></td><td width="33%"><font size="+1"><b>VPD_ipow</b></font></td><td><font size="+1"><b>VPE_ipow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPFu_ipow</b></font></td><td width="33%"><font size="+1"><b>VPDu_ipow</b></font></td><td><font size="+1"><b>VPEu_ipow</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Raise each element of a vector to a specified integer power.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_ipow( fVector Y, fVector X, ui size, int Expo );
<BR>int VFx_ipow( fVector Y, fVector X, ui size, int Expo, float A, float B, float C );
<BR>int VFu_ipow( fVector Y, fVector X, ui size, int Expo );
<BR>int VFux_ipow( fVector Y, fVector X, ui size, int Expo, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::ipow( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_ipow( const vector&lt;T&gt;& X, T A, T B, T C );
<BR>int vector&lt;T&gt;::u_ipow( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::ux_ipow( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_ipow( Y, X:fVector; size:UInt; ipow:Integer ): IntBool;
<BR>function VFx_ipow( Y, X:fVector; size:UInt; ipow:Integer; A, B, C:Single ): IntBool;
<BR>function VFu_ipow( Y, X:fVector; size:UInt; ipow:Integer ): IntBool;
<BR>function VFux_ipow( Y, X:fVector; size:UInt; ipow:Integer; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = X<sub>i</sub><sup>Expo</sup>
<BR>expanded versions: Y<sub>i</sub> = C * (A*X<sub>i</sub>+B)<sup>Expo</sup>
<BR>If Expo is larger than a data-type dependent threshold (which will be a very rare occasion), <I>VF_ipow</I> does not calculate the result itself, but calls <I><a href="#pow">VF_pow</a></I>, which is safer and faster in this case.
<BR>The &quot;unprotected&quot; versions (prefix <I>VFu_</I> and <I>VFux_</I>) do not perform any error handling and do not redirect calls to <I><a href="#pow">VF_pow</a></I>. These simplifications make them very fast, but also risky; they should be used very carefully.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>SING errors occur, if zero is raised to a negative power; the default result is &#177;HUGE_VAL, as in the case of OVERFLOW errors.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#poly">VF_poly</a>,&nbsp;&nbsp; <a href="#pow2">VF_pow2</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a></I>,&nbsp;&nbsp;pow</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ipow10"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ipow10</b></font></td><td width="33%"><font size="+1"><b>VD_ipow10</b></font></td><td><font size="+1"><b>VE_ipow10</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Integer powers of 10</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_ipow10( fVector Y, iVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::ipow10( const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_ipow10( Y:fVector; X:iVector; size:UInt ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = 10<sup>X</sup><font size="-1">i</font>
<BR>Notice: this function (and not <I><a href="#pow10">VF_pow10</a></I> !) is the vectorized form of the function pow10 defined in Borland C/C++.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#pow10">VF_pow10</a>,&nbsp;&nbsp; <a href="#scale10">VF_scale10</a>,&nbsp;&nbsp; <a href="#log10">VF_log10</a>,&nbsp;&nbsp; <a href="#ipow">VF_ipow</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; pow</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ipow2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ipow2</b></font></td><td width="33%"><font size="+1"><b>VD_ipow2</b></font></td><td><font size="+1"><b>VE_ipow2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Integer powers of 2</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_ipow2( fVector Y, iVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::ipow2( const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;</font>
<font face="courier new">function VF_ipow2( Y:fVector; X:iVector; size:UInt ):</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = 2<sup>X</sup><font size="-1">i</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#pow2">VF_pow2</a>,&nbsp;&nbsp; <a href="#scale2">VF_scale2</a>,&nbsp;&nbsp; <a href="#log2">VF_log2</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; pow</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="iselementC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_iselementC</b></font></td><td width="33%"><font size="+1"><b>VD_iselementC</b></font></td><td><font size="+1"><b>VE_iselementC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_iselementC</b></font></td><td width="33%"><font size="+1"><b>VCD_iselementC</b></font></td><td><font size="+1"><b>VCE_iselementC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_iselementC</b></font></td><td width="33%"><font size="+1"><b>VPD_iselementC</b></font></td><td><font size="+1"><b>VPE_iselementC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_iselementC</b></font></td><td width="20%"><font size="+1"><b>VBI_iselementC</b></font></td><td width="20%"><font size="+1"><b>VSI_iselementC</b></font></td><td width="20%"><font size="+1"><b>VLI_iselementC</b></font></td><td><font size="+1"><b>VQI_iselementC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_iselementC</b></font></td><td width="20%"><font size="+1"><b>VUB_iselementC</b></font></td><td width="20%"><font size="+1"><b>VUS_iselementC</b></font></td><td width="20%"><font size="+1"><b>VUL_iselementC</b></font></td><td><font size="+1"><b>VUI_iselementC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Test if one or more elements of a table are equal to C.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>int VF_iselementC( fVector Tab, ui size, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::iselementC( T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_iselementC( Tab:fVector; size:UInt; C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector Tab is searched for the value C. If one or more elements are equal to C, TRUE (+1) is returned, otherwise FALSE (0). No ordering of Tab is assumed and a linear search performed. A related function that finds the table element closest (but not necessarily equal) to C is <I><a href="#searchC">VF_searchC</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>TRUE (+1), if C is an element of X, otherwise FALSE (0).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#searchC">VF_searchC</a>,&nbsp;&nbsp; <a href="#iselementV">VF_iselementV</a>,&nbsp;&nbsp; lfind,&nbsp;&nbsp; lsearch</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="iselementV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_iselementV</b></font></td><td width="33%"><font size="+1"><b>VD_iselementV</b></font></td><td><font size="+1"><b>VE_iselementV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_iselementV</b></font></td><td width="33%"><font size="+1"><b>VCD_iselementV</b></font></td><td><font size="+1"><b>VCE_iselementV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_iselementV</b></font></td><td width="33%"><font size="+1"><b>VPD_iselementV</b></font></td><td><font size="+1"><b>VPE_iselementV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_iselementV</b></font></td><td width="20%"><font size="+1"><b>VBI_iselementV</b></font></td><td width="20%"><font size="+1"><b>VSI_iselementV</b></font></td><td width="20%"><font size="+1"><b>VLI_iselementV</b></font></td><td><font size="+1"><b>VQI_iselementV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_iselementV</b></font></td><td width="20%"><font size="+1"><b>VUB_iselementV</b></font></td><td width="20%"><font size="+1"><b>VUS_iselementV</b></font></td><td width="20%"><font size="+1"><b>VUL_iselementV</b></font></td><td><font size="+1"><b>VUI_iselementV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Test for each element of a vector, if an identical element is present in a table.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>ui VF_iselementV( fVector Y, fVector X, ui sizex, fVector Tab, ui sizetab );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>ui vector&lt;T&gt;::iselementV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Tab );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_iselementV( Y, X:fVector; sizex:UInt; Tab:fVector; sizetab:UInt ):UInt;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The table Tab is searched for each of the elements of X. For those elements of X which are found in Tab, the corresponding element of Y is set to +1 (in the complex versions: {1, 0} ). No ordering of X and Tab is assumed and a linear search for each X<sub>i</sub> performed. A related function that finds the table element closest (but not necessarily equal) to each element of X is <I><a href="#searchV">VF_searchV</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The number of elements of X for which an element of Tab was found is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#searchV">VF_searchV</a>,&nbsp;&nbsp; <a href="#iselementC">VF_iselementC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ismonoton"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ismonoton</b></font></td><td width="33%"><font size="+1"><b>VD_ismonoton</b></font></td><td><font size="+1"><b>VE_ismonoton</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Test if the elements of a vector are monotonously increasing or decreasing</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>int VF_ismonoton( fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::ismonoton( const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_ismonoton( X:fVector; size:UInt ): Integer;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector X is analyzed. If the elements are in strict descending order, -1 is returned; if they are either constant or in strict ascending order, +1 is returned. Otherwise the return value is 0. If X contains passages that are increasing as well as passages that remain at a constant value, X is regarded as monotonous only if the increasing passage follows the constant passage, but not the other way round. Thus, the series 0, 0, 0, 1, 2, 3 will be accepted as monotonous (return value +1), whereas the series 1, 2, 3, 4, 4, 4 will not (return value 0). Also the initially constant, then falling series 0, 0, 0, -1, -2, -3 will not be regarded as monotonous.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>+1 in case of monotonous rise, or if all elements are identical, -1 in case of monotonously falling values, 0 if neither of these conditions is fulfilled.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sort">VF_sort</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ItoF"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_ItoF</b></font></td><td width="33%"><font size="+1"><b>V_ItoD</b></font></td><td><font size="+1"><b>V_ItoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_BItoF</b></font></td><td width="33%"><font size="+1"><b>V_BItoD</b></font></td><td><font size="+1"><b>V_BItoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_SItoF</b></font></td><td width="33%"><font size="+1"><b>V_SItoD</b></font></td><td><font size="+1"><b>V_SItoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_LItoF</b></font></td><td width="33%"><font size="+1"><b>V_LItoD</b></font></td><td><font size="+1"><b>V_LItoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_QItoF</b></font></td><td width="33%"><font size="+1"><b>V_QItoD</b></font></td><td><font size="+1"><b>V_QItoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_UtoF</b></font></td><td width="33%"><font size="+1"><b>V_UtoD</b></font></td><td><font size="+1"><b>V_UtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_UBtoF</b></font></td><td width="33%"><font size="+1"><b>V_UBtoD</b></font></td><td><font size="+1"><b>V_UBtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_UStoF</b></font></td><td width="33%"><font size="+1"><b>V_UStoD</b></font></td><td><font size="+1"><b>V_UStoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_ULtoF</b></font></td><td width="33%"><font size="+1"><b>V_ULtoD</b></font></td><td><font size="+1"><b>V_ULtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_UItoF</b></font></td><td width="33%"><font size="+1"><b>V_UItoD</b></font></td><td><font size="+1"><b>V_UItoE</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Convert integer numbers into floating-point data types.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(always the include-file belonging to the destination type!)
<BR><font face="courier new">void V_ItoF( fVector Y, iVector X, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(all other functions of this family are similar)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;float&gt;::ItoF( const vector&lt;int&gt;& Y );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(always the unit belonging to the destination type!)
<BR><font face="courier new">procedure V_ItoF( Y:fVector; X:iVector; size:UInt );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(all other functions of this family are similar)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of X is converted from the data type int, byte, short int, long int, quad, unsigned, unsigned byte, unsigned short, unsigned long, or ui, resp., into the data type float, double, or extended, resp., and stored in Y. For the inverse procedure, i.e. the conversion of floating-point numbers to integers, the functions of the <I><a href="#round">VF_roundtoI</a>,&nbsp;&nbsp; <a href="#floor">VF_floortoI</a>,&nbsp;&nbsp; <a href="#ceil">VF_ceiltoI</a></I>, and <I><a href="#chop">VF_choptoI</a></I> families have to be used.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#roundtoI">VF_roundtoI</a>,&nbsp;&nbsp; <a href="#floor">VF_floortoI</a>,&nbsp;&nbsp; <a href="#ceil">VF_ceiltoI</a>,&nbsp;&nbsp; <a href="#chop">VF_choptoI</a>,&nbsp;&nbsp; <a href="#trunc">VF_trunctoI</a>,&nbsp;&nbsp; <a href="#ItoBI">V_ItoLI</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ItoBI"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_ItoBI</b></font></td><td width="25%"><font size="+1"><b>V_ItoSI</b></font></td><td width="25%"><font size="+1"><b>V_ItoLI</b></font></td><td><font size="+1"><b>V_ItoQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_BItoI</b></font></td><td width="25%"><font size="+1"><b>V_BItoSI</b></font></td><td width="25%"><font size="+1"><b>V_BItoLI</b></font></td><td><font size="+1"><b>V_BItoQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_SItoI</b></font></td><td width="25%"><font size="+1"><b>V_SItoBI</b></font></td><td width="25%"><font size="+1"><b>V_SItoLI</b></font></td><td><font size="+1"><b>V_SItoQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_LItoI</b></font></td><td width="25%"><font size="+1"><b>V_LItoBI</b></font></td><td width="25%"><font size="+1"><b>V_LItoSI</b></font></td><td><font size="+1"><b>V_LItoQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_QItoI</b></font></td><td width="25%"><font size="+1"><b>V_QItoBI</b></font></td><td width="25%"><font size="+1"><b>V_QItoSI</b></font></td><td><font size="+1"><b>V_QItoLI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_UtoUB</b></font></td><td width="25%"><font size="+1"><b>V_UtoUS</b></font></td><td width="25%"><font size="+1"><b>V_UtoUL</b></font></td><td><font size="+1"><b>V_UtoUI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_UBtoU</b></font></td><td width="25%"><font size="+1"><b>V_UBtoUS</b></font></td><td width="25%"><font size="+1"><b>V_UBtoUL</b></font></td><td><font size="+1"><b>V_UBtoUI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_UStoU</b></font></td><td width="25%"><font size="+1"><b>V_UStoUB</b></font></td><td width="25%"><font size="+1"><b>V_UStoUL</b></font></td><td><font size="+1"><b>V_UStoUI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_ULtoU</b></font></td><td width="25%"><font size="+1"><b>V_ULtoUB</b></font></td><td width="25%"><font size="+1"><b>V_ULtoUS</b></font></td><td><font size="+1"><b>V_ULtoUI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_UItoU</b></font></td><td width="25%"><font size="+1"><b>V_UItoUB</b></font></td><td width="25%"><font size="+1"><b>V_UItoUS</b></font></td><td><font size="+1"><b>V_UItoUL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_ItoU</b></font></td><td width="25%"><font size="+1"><b>V_BItoUB</b></font></td><td width="25%"><font size="+1"><b>V_SItoUS</b></font></td><td><font size="+1"><b>V_LItoUL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>V_UtoI</b></font></td><td width="25%"><font size="+1"><b>V_UBtoBI</b></font></td><td width="25%"><font size="+1"><b>V_UStoSI</b></font></td><td><font size="+1"><b>V_ULtoLI</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Interconversion of the integer data types</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VLIstd.h&gt;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(or <font face=" courier new">&lt;VIstd.h&gt;, &lt;VUstd.h&gt;</font>,..., resp., depending on the
destination data type!)
<BR><font face="courier new">void V_ItoLI( liVector Y, iVector X, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(all other functions of this family are similar)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;long&gt;::ItoLI( const vector&lt;long&gt;& Y );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VLIstd;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(always the unit belonging to the destination type!)
<BR><font face="courier new">procedure V_ItoLI( Y:liVector; X:iVector; size:UInt );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(all other functions of this family are similar)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of the vector X is converted into the desired data type and stored in Y.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>see <a href="HANDBOOK.HTM#chap5_2">chapter&nbsp;5.2.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ItoF">V_ItoF</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="Kepler"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_Kepler</b></font></td><td width="33%"><font size="+1"><b>VD_Kepler</b></font></td><td><font size="+1"><b>VE_Kepler</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_Kepler</b></font></td><td width="33%"><font size="+1"><b>VDx_Kepler</b></font></td><td><font size="+1"><b>VEx_Kepler</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Angular position of a planet according to Kepler's Second Law</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_Kepler( fVector Y, fVector X, ui size, float T, float e );
<BR>int VFx_Kepler( fVector Y, fVector X, ui size, float T, float e, float A, float B );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::Kepler( const vector&lt;T&gt;& X, T t, T e );
<BR>int vector&lt;T&gt;::x_Kepler( const vector&lt;T&gt;& X, T t, T e, T A, T B );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>function VF_Kepler( Y, X:fVector; size:UInt; T, e:Single ): IntBool;
<BR>function VFx_Kepler( Y, X:fVector; size:UInt; T, e, A, B:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = Kepler( X<sub>i</sub>/T, e );
<BR>expanded versions: Y<sub>i</sub> = Kepler( (A*X<sub>i</sub>+B)/T, e );
<BR>The time-dependent angular position of a planet is calculated from its round-trip time T and its eccentricity e.
<BR>T must be non-zero; e may take on values 0 &lt;= e &lt;= 1. While there is no analytic solution to this problem, described by Johannes Kepler's Second Law, an efficient iterative algorithm is known and is used here. This algorithm is fast and stable up to the hyperbolic limit, e = 1.0.
<BR>Rather than treating the problem in terms of the reduced time m = t/T (like it is done in Astronomy textbooks), <I>VF_Kepler</I> expects the real times in X and divides them internally by T.
<P>As there may hardly be any occasions when one might wish to scale the obtained angular position by a constant, no multiplication by C is included in the <I>VFx_</I> version which, consequently, has only A and B as additional arguments (unlike most of the other &quot;expanded versions&quot; of <I>VectorLib</I> math functions).
<P>This function may not be called while the FPU is set to reduced accuracy, or else it might hang in an infinite loop. See <I><a href="#setFPAccuracy">V_setFPAccuracy</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>e negative or e greater than 1.0 leads to an &quot;Invalid parameter(s)&quot; error. T = 0 leads to all Y<sub>i</sub> = 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="Langevin"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_Langevin</b></font></td><td width="33%"><font size="+1"><b>VD_Langevin</b></font></td><td><font size="+1"><b>VE_Langevin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_Langevin</b></font></td><td width="33%"><font size="+1"><b>VDx_Langevin</b></font></td><td><font size="+1"><b>VEx_Langevin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Langevin function of dielectric relaxation</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_Langevin( fVector Y, fVector X, ui size );
<BR>int VFx_Langevin( fVector Y, fVector X, ui size, 
 float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::Langevin( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_Langevin( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>function VF_Langevin( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_Langevin( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = cot( X<sub>i</sub> ) - 1/X<sub>i</sub>;
<BR>expanded versions: x = A * X<sub>i</sub> + B;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y<sub>i</sub> = C * (cot(x) - 1/x);
<BR>The Langevin function has an S-shaped graph and describes, e.g., dielectric relaxation phenomena.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>This function should be error-proof.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0).</td></tr></table></td></tr>
</table>


<P>&nbsp;<P><a name="ldexp"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ldexp</b></font></td><td width="33%"><font size="+1"><b>VD_ldexp</b></font></td><td><font size="+1"><b>VE_ldexp</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Scale by an integer power of 2.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_ldexp( fVector Y, fVector X, ui size, int expo );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::ldexp( const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td>These functions are absent. Use VF_scale2 etc.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>These functions are implemented as alias names for <I><a href="#scale2">VF_scale2</a></I> etc., in order to maintain consistency with the ANSI C function name <I>ldexp</I>. For details, see <I><a href="#scale2">VF_scale2</a></I>.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="limit"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_limit</b></font></td><td width="33%"><font size="+1"><b>VD_limit</b></font></td><td><font size="+1"><b>VE_limit</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_limit</b></font></td><td width="33%"><font size="+1"><b>VCD_limit</b></font></td><td><font size="+1"><b>VCE_limit</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Limit the values of the elements of a vector to a specified range.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_limit( fVector Y, fVector X, ui size, float Min, float Max );
<BR>void VCF_limit( cfVector Y, cfVector X, ui size, fComplex Min, fComplex Max );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::limit( const vector&lt;T&gt;& X, T Min, T Max );
<BR>void vector&lt;complex&lt;T&gt;&gt;::limit( const vector&lt;complex&lt;T&gt;&gt;& X, complex&lt;T&gt; Min, complex&lt;T&gt; Max );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_limit( Y, X:fVector; size:UInt; Min, Max:Single );
<BR>procedure VCF_limit( Y, X:cfVector; size:UInt; Min, Max:fComplex );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><u>Real version:</u><BR>Y<sub>i</sub> = X<sub>i</sub> , if Min &lt;= X<sub>i</sub> &lt;= Max
<BR>Y<sub>i</sub> = Max, if X<sub>i</sub> &gt; Max
<BR>Y<sub>i</sub> = Min, if X<sub>i</sub> &lt; Min
<BR>This function may be seen as a combination of <I><a href="#maxC">VF_maxC</a></I> and <I><a href="#minC">VF_minC</a></I>.
<BR><u>Complex version:</u>
<BR>Similar to the real version, but the real and imaginary parts are limited separately to the ranges specified in the respective parts of Min and Max.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#maxC">VF_maxC</a>,&nbsp;&nbsp; <a href="#minC">VF_minC</a>,&nbsp;&nbsp; <a href="#min">VF_min</a>,&nbsp;&nbsp; <a href="#flush0">VF_flush0</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="lincomb"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_lincomb</b></font></td><td width="33%"><font size="+1"><b>VD_lincomb</b></font></td><td><font size="+1"><b>VE_lincomb</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_lincomb</b></font></td><td width="33%"><font size="+1"><b>VCD_lincomb</b></font></td><td><font size="+1"><b>VCE_lincomb</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>linear combination of two vectors</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_lincomb( fVector Z, fVector X, fVector Y, ui size, float CX, float CY );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::lincomb( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y, T CX, T CY );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_lincomb( Z, X, Y:fVector; size:UInt; CX, CY:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Z<sub>i</sub> = CX * X<sub>i</sub> + CY * Y<sub>i</sub></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#addV">VFx_addV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="linregress"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_linregress</b></font></td><td width="33%"><font size="+1"><b>VD_linregress</b></font></td><td><font size="+1"><b>VE_linregress</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Linear regression</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_linregress( fVector Param, fVector X, fVector Y, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::linregress( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_linregress( Param, X, Y:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The X-Y data are fitted to a straight line y = ax + b; the parameters a and b are determined in such a way that the quantity
<BR>h<sup>2</sup> = sum( (Y<sub>i</sub> - y(x=X<sub>i</sub>) )<sup>2</sup> )
<BR>is minimized. Uncertainties da and db are also determined. On output, Param is filled with the 5 elements {a, da, b, db, h<sup>2</sup>} in the order indicated.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#linregresswW">VF_linregresswW</a>,&nbsp;&nbsp; <a href="#corrcoeff">VF_corrcoeff</a>,&nbsp;&nbsp; <a href="#chi2">VF_chi2</a>,&nbsp;&nbsp; <a href="MATRIX.HTM#linfit">VF_linfit</a>,&nbsp;&nbsp; <a href="MATRIX.HTM#nonlinfit">VF_nonlinfit</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="linregresswW"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_linregresswW</b></font></td><td width="33%"><font size="+1"><b>VD_linregresswW</b></font></td><td><font size="+1"><b>VE_linregresswW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Linear regression with weights</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_linregresswW( fVector Param, fVector X, fVector Y, fVector InvVar, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::linregresswW( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y, const vector&lt;T&gt;& InvVar );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_linregresswW( Param, X, Y, InvVar:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The X-Y data are weighted with the inverse of their variances and fitted to a straight line <I>y = ax + b;</I> the parameters <I>a</I> and <I>b</I> are determined in such a way as to minimize the merit function
<BR><font face="symbol">c</font><sup>2</sup> = sum( (1 / Var<sub>i</sub>) * (Y<sub>i</sub> - y(x=X<sub>i</sub>) )<sup>2</sup> )
<BR>(see also <I><a href="#chi2">VF_chi2</a></I>). The inverse of the variance of each data point has to be passed to the function in the vector InvVar. Uncertainties <I>da</I> and <I>db</I> are also determined. On output, <I>Param</I> is filled with the 5 elements {<I>a, da, b, db, <font face="symbol">c</font><sup>2</sup></I>} in the order indicated.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#linregress">VF_linregress</a>,&nbsp;&nbsp; <a href="#corrcoeff">VF_corrcoeff</a>,&nbsp;&nbsp; <a href="#chi2">VF_chi2</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="LItoF"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_LItoF</b></font></td><td width="33%"><font size="+1"><b>V_LItoD</b></font></td><td><font size="+1"><b>V_LItoE</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Data type interconversions. See <I><a href="#ItoF">V_ItoF</a></I>!</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ln"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ln</b></font></td><td width="33%"><font size="+1"><b>VD_ln</b></font></td><td><font size="+1"><b>VE_ln</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_ln</b></font></td><td width="33%"><font size="+1"><b>VCD_ln</b></font></td><td><font size="+1"><b>VCE_ln</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_ln</b></font></td><td width="33%"><font size="+1"><b>VDx_ln</b></font></td><td><font size="+1"><b>VEx_ln</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_ln</b></font></td><td width="33%"><font size="+1"><b>VCDx_ln</b></font></td><td><font size="+1"><b>VCEx_ln</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_lntoC</b></font></td><td width="33%"><font size="+1"><b>VPD_lntoC</b></font></td><td><font size="+1"><b>VPE_lntoC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Natural logarithm</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_ln( fVector Y, fVector X, ui size );
<BR>int VFx_ln( fVector Y, fVector X, ui size, float A, float B, float C );
<BR>int VPF_lntoC( cfVector Y, pfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::ln( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_ln( const vector&lt;T&gt;& X, T A, T B, T C );
<BR>int vector&lt;complex&lt;T&gt;&gt;::lntoC( const vector&lt;polar&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_ln( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_ln( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;
<BR>function VPF_lntoC( Y:cfVector; X:pfVector; size:UInt ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>These function names are synonyms for the functions of the <I><a href="#log">VF_log</a></I> family. See <I><a href="#log">VF_log</a></I> for details.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="localmaxima"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_localmaxima</b></font></td><td width="33%"><font size="+1"><b>VD_localmaxima</b></font></td><td><font size="+1"><b>VE_localmaxima</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the indices of local maxima</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>ui VF_localmaxima( uiVector Ind, fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>ui vector&lt;ui&gt;::localmaxima( const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_localmaxima( Ind:uVector; X:fVector; size:UInt ):UInt;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The indices of local maxima in X are stored in Ind and the number of local maxima is returned (this is the number of elements of Ind). A local maximum is defined as one element of X that is greater than both its neighbours to the right and to the left. That means that the zero'th and the last element of X (which have only one neighbour) cannot be local maxima. Also, if two adjacent elements are equal, none of them can be a local maximum.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>number of local maxima found</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#maxind">VF_maxind</a>,&nbsp;&nbsp; <a href="#max">VF_max</a>,&nbsp;&nbsp; <a href="#indpick">VF_indpick</a>,&nbsp;&nbsp; <a href="#localminima">VF_localminima</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="localminima"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_localminima</b></font></td><td width="33%"><font size="+1"><b>VD_localminima</b></font></td><td><font size="+1"><b>VE_localminima</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the indices of local minima</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>ui VF_localminima( uiVector Ind, fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>ui vector&lt;ui&gt;::localminima( const vector&lt;T&gt;& Ind );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_localminima( Ind:uVector; X:fVector; size:UInt ):UInt;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The indices of local minima in X are stored in Ind and the number of local minima is returned (this is the number of elements of Ind). A local minimum is defined as one element of X that is smaller than both its neighbours to the right and to the left. That means that the zero'th and the last element of X (which have only one neighbour) cannot be local minima. Also, if two adjacent elements are equal, none of them can be a local minimum.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>number of local minima found</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#minind">VF_minind</a>,&nbsp;&nbsp; <a href="#min">VF_min</a>,&nbsp;&nbsp; <a href="#indpick">VF_indpick</a>,&nbsp;&nbsp; <a href="#localmaxima">VF_localmaxima</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="log"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_log</b></font></td><td width="33%"><font size="+1"><b>VD_log</b></font></td><td><font size="+1"><b>VE_log</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_log</b></font></td><td width="33%"><font size="+1"><b>VCD_log</b></font></td><td><font size="+1"><b>VCE_log</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_log</b></font></td><td width="33%"><font size="+1"><b>VDx_log</b></font></td><td><font size="+1"><b>VEx_log</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_log</b></font></td><td width="33%"><font size="+1"><b>VCDx_log</b></font></td><td><font size="+1"><b>VCEx_log</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_logtoC</b></font></td><td width="33%"><font size="+1"><b>VPD_logtoC</b></font></td><td><font size="+1"><b>VPE_logtoC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Natural logarithm</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_log( fVector Y, fVector X, ui size );
<BR>int VFx_log( fVector Y, fVector X, ui size, float A, float B, float C );
<BR>int VPF_logtoC( cfVector Y, pfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::log( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_log( const vector&lt;T&gt;& X, T A, T B, T C );
<BR>int vector&lt;complex&lt;T&gt;&gt;::logtoC( const vector&lt;polar&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_log( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_log( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;
<BR>function VPF_logtoC( Y:cfVector; X:pfVector; size:UInt ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = ln( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * ln( A*X<sub>i</sub>+B )
<BR>The &quot;logarithmus naturalis&quot;, i.e. the logarithm to the basis of Euler's constant <I>e</I> is calculated.
<BR>The logarithm of polar complex numbers is most naturally stored in cartesian format, as log{Mag@Arg} = {Mag,Arg}. Therefore, the <I>VPF_</I> version exists only with the result in a cfVector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Real versions: DOMAIN errors occur in the case of negative X<sub>i</sub> (including -0.0), with NAN (&quot;not-a-number&quot;) as the default result. SING errors occur for X<sub>i</sub>= +0.0 and yield a result of -HUGE_VAL. In the complex version, numbers with an imaginary part of zero are always treated as real numbers; therefore, an argument {0, 0} is treated as a real 0, causing a SING error with the default result {-HUGE_VAL, 0}.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#exp">VF_exp</a>,&nbsp;&nbsp; <a href="#log2">VF_log2</a>,&nbsp;&nbsp; <a href="#log10">VF_log10</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; log</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="log10"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_log10</b></font></td><td width="33%"><font size="+1"><b>VD_log10</b></font></td><td><font size="+1"><b>VE_log10</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_log10</b></font></td><td width="33%"><font size="+1"><b>VCD_log10</b></font></td><td><font size="+1"><b>VCE_log10</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_log10</b></font></td><td width="33%"><font size="+1"><b>VDx_log10</b></font></td><td><font size="+1"><b>VEx_log10</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_log10</b></font></td><td width="33%"><font size="+1"><b>VCDx_log10</b></font></td><td><font size="+1"><b>VCEx_log10</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_log10toC</b></font></td><td width="33%"><font size="+1"><b>VPD_log10toC</b></font></td><td><font size="+1"><b>VPE_log10toC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Decadic logarithm</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_log10( fVector Y, fVector X, ui size );
<BR>int VFx_log10( fVector Y, fVector X, ui size, float A, float B, float C );
<BR>int VPF_log10toC( cfVector Y, pfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::log10( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_log10( const vector&lt;T&gt;& X, T A, T B, T C );
<BR>int vector&lt;complex&lt;T&gt;&gt;::log10toC( const vector&lt;polar&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_log10( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_log10( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;
<BR>function VPF_log10toC( Y:cfVector; X:pfVector; size:UInt ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = lg( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * lg( A*X<sub>i</sub>+B )
<BR>The decadic logarithm (to the basis of 10) is calculated.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Real versions: DOMAIN errors occur in the case of negative X<sub>i</sub> (including -0.0), with NAN (&quot;not-a-number&quot;) as the default result. SING errors occur for X<sub>i</sub>= +0.0 and yield a result of -HUGE_VAL. In the complex version, numbers with an imaginary part of zero are always treated as real numbers; therefore, an argument {0, 0} is treated as a real 0, causing a SING error with the default result {-HUGE_VAL, 0}.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#pow10">VF_pow10</a>,&nbsp;&nbsp; <a href="#log">VF_log</a>,&nbsp;&nbsp; <a href="#log2">VF_log2</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#_log10">log10</a></I> (the latter function is defined in ANSI C; for Pascal, it is available in the unit XMATH coming with <I>OptiVec</I>).</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="log2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_log2</b></font></td><td width="33%"><font size="+1"><b>VD_log2</b></font></td><td><font size="+1"><b>VE_log2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_log2</b></font></td><td width="33%"><font size="+1"><b>VCD_log2</b></font></td><td><font size="+1"><b>VCE_log2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_log2</b></font></td><td width="33%"><font size="+1"><b>VDx_log2</b></font></td><td><font size="+1"><b>VEx_log2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_log2</b></font></td><td width="33%"><font size="+1"><b>VCDx_log2</b></font></td><td><font size="+1"><b>VCEx_log2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_log2toC</b></font></td><td width="33%"><font size="+1"><b>VPD_log2toC</b></font></td><td><font size="+1"><b>VPE_log2toC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Binary logarithm</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_log2( fVector Y, fVector X, ui size );
<BR>int VFx_log2( fVector Y, fVector X, ui size, float A, float B, float C );
<BR>int VPF_log2toC( cfVector Y, pfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::log2( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_log2( const vector&lt;polar&lt;T&gt;&gt;& X, T A, T B, T C );
<BR>int vector&lt;complex&lt;T&gt;&gt;::log2toC( const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_log2( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_log2( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;
<BR>function VPF_log2toC( Y:cfVector; X:pfVector; size:UInt ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = lb( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * lb( A*X<sub>i</sub>+B )
<BR>The binary logarithm (to the basis 2) is calculated.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Real versions: DOMAIN errors occur in the case of negative X<sub>i</sub> (including -0.0), with NAN (&quot;not-a-number&quot;) as the default result. SING errors occur for X<sub>i</sub>= +0.0 and yield a result of -HUGE_VAL. In the complex version, numbers with an imaginary part of zero are always treated as real numbers; therefore, an argument {0, 0} is treated as a real 0, causing a SING error with the default result {-HUGE_VAL, 0}.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#pow2">VF_pow2</a>,&nbsp;&nbsp; <a href="#log">VF_log</a>,&nbsp;&nbsp; <a href="#log10">VF_log10</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#_log2">log2</a></I> (the latter function is neither defined in ANSI C nor in Pascal/Delphi, but an addition contained in &lt;xmath.h&gt; or in the unit XMATH).</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="Lorentz"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_Lorentz</b></font></td><td width="33%"><font size="+1"><b>VD_Lorentz</b></font></td><td><font size="+1"><b>VE_Lorentz</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Lorentzian lineshape function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_Lorentz( fVector Y, fVector X, ui size, float Wid, float Cent, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::Lorentz( const vector&lt;T&gt;& X, T Wid, T Cent, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_Lorentz( Y, X:fVector; size:UInt; Wid, Cent, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = C * Wid<sup>2</sup> / ( (X<sub>i</sub> - Cent)<sup>2</sup> + Wid<sup>2</sup> )
<BR>Wid = width of the resonance line
<BR>Cent = centre of the line
<BR>C is a scaling factor; at the center of the line (X<sub>i</sub>=Cent), the amplitude Y<sub>i</sub> equals C. This is even true for a width of zero.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>This function should be error-proof.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#Gauss">VF_Gauss</a>,&nbsp;&nbsp; <a href="#sech2">VF_sech2</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="MagArgtoP"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_MagArgtoP</b></font></td><td width="33%"><font size="+1"><b>VD_MagArgtoP</b></font></td><td><font size="+1"><b>VE_MagArgtoP</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Construct a polar complex vector from separate vectors for magnitude and argument</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_MagArgtoP( pfVector Y, fVector Mag, fVector Arg, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;polar&lt;T&gt;&gt;::MagArgtoP( const vector&lt;T&gt;& Mag, const vector&lt;T&gt;& Arg );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_MagArgtoP( X:pfVector; Mag, Arg:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The polar complex vector Y is constructed from the two real vectors Mag and Arg.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PtoMagArg">VF_PtoMagArg</a>,&nbsp;&nbsp; <a href="#ReImtoC">VF_ReImtoC</a>,&nbsp;&nbsp; <a href="#MagtoP">VF_MagtoP</a>,&nbsp;&nbsp; <a href="#ArgtoP">VF_ArgtoP</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="MagArgtoPrincipal"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_MagArgtoPrincipal</b></font></td><td width="33%"><font size="+1"><b>VD_MagArgtoPrincipal</b></font></td><td><font size="+1"><b>VE_MagArgtoPrincipal</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Construct a polar complex vector from separate vectors for magnitude and argument, reducing to the principal value</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_MagArgtoPrincipal( pfVector Y, fVector Mag, fVector Arg, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;polar&lt;T&gt;&gt;::MagArgtoPrincipal( const vector&lt;T&gt;& Mag, const vector&lt;T&gt;& Arg );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_MagArgtoPrincipal( X:pfVector; Mag, Arg:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The polar complex vector Y is constructed from the two real vectors Mag and Arg. The arguments are reduced to the principal value,  -<font face="symbol">p</font> &lt; Arg &lt;= +<font face="symbol">p</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#principal">VPF_principal</a>,&nbsp;&nbsp; <a href="#MagArgtoP">VF_MagArgtoP</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="MagtoP"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_MagtoP</b></font></td><td width="33%"><font size="+1"><b>VD_MagtoP</b></font></td><td><font size="+1"><b>VE_MagtoP</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Overwrite the Mag part of a polar complex vector with a real vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_MagtoP( pfVector Y, fVector Mag, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;polar&lt;T&gt;&gt;::MagtoP( const vector&lt;T&gt;& Mag );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_MagtoP( X:pfVector; Mag:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The Mag part of the polar complex vector Y is overwritten with the elements of the real-valued vector Mag. The Arg part of Y is not affected.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PtoMagArg">VF_PtoMagArg</a>,&nbsp;&nbsp; <a href="#MagArgtoP">VF_MagArgtoP</a>,&nbsp;&nbsp; <a href="#ArgtoP">VF_ArgtoP</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="mantexp"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_mantexp</b></font></td><td width="33%"><font size="+1"><b>VD_mantexp</b></font></td><td><font size="+1"><b>VE_mantexp</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Split up the elements of a vector into their mantissa and exponent parts</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_mantexp( fVector MantPart, iVector ExpPart, fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::mantexp( vector&lt;int&gt; ExpPart, const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_mantexp( MantPart:fVector; ExpPart:iVector; X:fVector; size:UInt ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The elements of X are split up into their mantissa, stored in MantPart, and exponent, stored as ints in ExpPart.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#scale2">VF_scale2</a>,&nbsp;&nbsp; <a href="#intfrac">VF_intfrac</a>,&nbsp;&nbsp; frexp</I> (only C/C++),&nbsp;&nbsp;<I>ldexp</I> (only C/C++)</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="max"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_max</b></font></td><td width="33%"><font size="+1"><b>VD_max</b></font></td><td><font size="+1"><b>VE_max</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_max</b></font></td><td width="20%"><font size="+1"><b>VBI_max</b></font></td><td width="20%"><font size="+1"><b>VSI_max</b></font></td><td width="20%"><font size="+1"><b>VLI_max</b></font></td><td><font size="+1"><b>VQI_max</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_max</b></font></td><td width="20%"><font size="+1"><b>VUB_max</b></font></td><td width="20%"><font size="+1"><b>VUS_max</b></font></td><td width="20%"><font size="+1"><b>VUL_max</b></font></td><td><font size="+1"><b>VUI_max</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the largest element of a vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_max( fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::_max();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_max( X:fVector; size:UInt ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector X is searched for its largest element, whose value is returned. In order to avoid confusion with the macro "max" in C/C++, the VecObj version of this function is written with a leading underbar as "_max".</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>maximum value encountered.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#min">VF_min</a>,&nbsp;&nbsp; <a href="#absmax">VF_absmax</a>,&nbsp;&nbsp; <a href="#runmax">VF_runmax</a>,&nbsp;&nbsp; <a href="#maxind">VF_maxind</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="maxC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_maxC</b></font></td><td width="33%"><font size="+1"><b>VD_maxC</b></font></td><td><font size="+1"><b>VE_maxC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_maxC</b></font></td><td width="20%"><font size="+1"><b>VBI_maxC</b></font></td><td width="20%"><font size="+1"><b>VSI_maxC</b></font></td><td width="20%"><font size="+1"><b>VLI_maxC</b></font></td><td><font size="+1"><b>VQI_maxC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_maxC</b></font></td><td width="20%"><font size="+1"><b>VUB_maxC</b></font></td><td width="20%"><font size="+1"><b>VUS_maxC</b></font></td><td width="20%"><font size="+1"><b>VUL_maxC</b></font></td><td><font size="+1"><b>VUI_maxC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Compare each element of a vector to a constant and take the larger of the two.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_maxC( fVector Y, fVector X, ui size, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::maxC( const vector&lt;T&gt;& X, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_maxC( Y, X:fVector; size:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>i</sub>, if X<sub>i</sub> &gt; C
<BR>Y<sub>i</sub> = C, if X<sub>i</sub> &lt;= C</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#maxV">VF_maxV</a>,&nbsp;&nbsp; <a href="#minC">VF_minC</a>,&nbsp;&nbsp; <a href="#max">VF_max</a>,&nbsp;&nbsp; <a href="#absmax">VF_absmax</a>,&nbsp;&nbsp; <a href="#limit">VF_limit</a>,&nbsp;&nbsp; <a href="#flush0">VF_flush0</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="maxind"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_maxind</b></font></td><td width="33%"><font size="+1"><b>VD_maxind</b></font></td><td><font size="+1"><b>VE_maxind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_maxind</b></font></td><td width="20%"><font size="+1"><b>VBI_maxind</b></font></td><td width="20%"><font size="+1"><b>VSI_maxind</b></font></td><td width="20%"><font size="+1"><b>VLI_maxind</b></font></td><td><font size="+1"><b>VQI_maxind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_maxind</b></font></td><td width="20%"><font size="+1"><b>VUB_maxind</b></font></td><td width="20%"><font size="+1"><b>VUS_maxind</b></font></td><td width="20%"><font size="+1"><b>VUL_maxind</b></font></td><td><font size="+1"><b>VUI_maxind</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the largest element of a vector and its index.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_maxind( ui *Ind, fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::maxind( ui *Ind );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_maxind( var Ind:UInt; X:fVector; size:UInt ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector X is searched for its largest element; its value is returned. At the address passed as Ind, the index of this element is stored.In the case of several maxima of equal height, the first one is chosen (i.e., the smallest index is stored in Ind).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>maximum value encountered.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#max">VF_max</a>,&nbsp;&nbsp; <a href="#minind">VF_minind</a>,&nbsp;&nbsp; <a href="#absmax">VF_absmax</a>,&nbsp;&nbsp; <a href="#runmax">VF_runmax</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="maxReIm"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_maxReIm</b></font></td><td width="33%"><font size="+1"><b>VCD_maxReIm</b></font></td><td><font size="+1"><b>VCE_maxReIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the largest real and imaginary parts occurring in a vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>fComplex VCF_maxReIm( cfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>complex&lt;T&gt; vector&lt;complex&lt;T&gt;&gt;::maxReIm();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VCF_maxReIm( var Max:fComplex; X:cfVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector X is separately searched for its largest real and imaginary parts. These are packed together and either returned as an fComplex (in C/C++) or stored in Max (in Pascal/Delphi):
<BR>Max.Re: largest real part encountered,
<BR>Max.Im: largest imaginary part encountered.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td><u>C/C++:</u>
<BR>struct or class instance of type fComplex (dComplex, eComplex, resp.), in which the maxima of the real and imaginary parts of X are packed together.
<BR><u>Pascal/Delphi:</u>
<BR>since Pascal does not allow complex return values, the result is stored in the variable Max.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#minReIm">VCF_minReIm</a>,&nbsp;&nbsp; <a href="#absmaxReIm">VCF_absmaxReIm</a>,&nbsp;&nbsp; <a href="#absmax">VCF_absmax</a>,&nbsp;&nbsp; <a href="#absmaxind">VCF_absmaxind</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="maxV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_maxV</b></font></td><td width="33%"><font size="+1"><b>VD_maxV</b></font></td><td><font size="+1"><b>VE_maxV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_maxV</b></font></td><td width="20%"><font size="+1"><b>VBI_maxV</b></font></td><td width="20%"><font size="+1"><b>VSI_maxV</b></font></td><td width="20%"><font size="+1"><b>VLI_maxV</b></font></td><td><font size="+1"><b>VQI_maxV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_maxV</b></font></td><td width="20%"><font size="+1"><b>VUB_maxV</b></font></td><td width="20%"><font size="+1"><b>VUS_maxV</b></font></td><td width="20%"><font size="+1"><b>VUL_maxV</b></font></td><td><font size="+1"><b>VUI_maxV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Compare each element of a vector to the corresponding element of another vector and take the larger of the two.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_maxV( fVector Z, fVector X, fVector Y, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::maxV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_maxV( Z, X, Y:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Z<sub>i</sub> = X<sub>i</sub>, if X<sub>i</sub> &gt; Y<sub>i</sub>
<BR>Z<sub>i</sub> = Y<sub>i</sub>, if X<sub>i</sub> &lt;= Y<sub>i</sub></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#minV">VF_minV</a>,&nbsp;&nbsp; <a href="#maxC">VF_maxC</a>,&nbsp;&nbsp; <a href="#max">VF_max</a>,&nbsp;&nbsp; <a href="#absmax">VF_absmax</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="mean"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_mean</b></font></td><td width="33%"><font size="+1"><b>VD_mean</b></font></td><td><font size="+1"><b>VE_mean</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_mean</b></font></td><td width="33%"><font size="+1"><b>VCD_mean</b></font></td><td><font size="+1"><b>VCE_mean</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_mean</b></font></td><td width="20%"><font size="+1"><b>VBI_mean</b></font></td><td width="20%"><font size="+1"><b>VSI_mean</b></font></td><td width="20%"><font size="+1"><b>VLI_mean</b></font></td><td><font size="+1"><b>VQI_mean</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_mean</b></font></td><td width="20%"><font size="+1"><b>VUB_mean</b></font></td><td width="20%"><font size="+1"><b>VUS_mean</b></font></td><td width="20%"><font size="+1"><b>VUL_mean</b></font></td><td><font size="+1"><b>VUI_mean</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Mean of a one-dimensional distribution</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_mean( fVector X, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_,&nbsp;&nbsp; VCF_,&nbsp;&nbsp; VCD_,&nbsp;&nbsp; VCE_</I>)
<BR><font face="courier new">double VI_mean( iVector X, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VBI_,&nbsp;&nbsp; VSI_,&nbsp;&nbsp; VLI_,&nbsp;&nbsp; VU_,&nbsp;&nbsp; VUB_,&nbsp;&nbsp; VUS_,&nbsp;&nbsp; VUL_,&nbsp;&nbsp; VUI_</I>)
<BR><font face="courier new">extended VQI_mean( qiVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::mean();
<BR>double vector&lt;int&gt;::mean();
<BR>extended vector&lt;quad&gt;::mean();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_mean( X:fVector; size:UInt ): Single;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
<BR><font face="courier new">procedure VCF_mean( var Mean:fComplex; X:cfVector; size:UInt );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_</I>)
<BR><font face="courier new">function VI_mean( X:iVector; size:UInt ); Double;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VBI_,&nbsp;&nbsp; VSI_,&nbsp;&nbsp; VLI_,&nbsp;&nbsp; VU_,&nbsp;&nbsp; VUB_,&nbsp;&nbsp; VUS_,&nbsp;&nbsp; VUL_</I>)
<BR><font face="courier new">function VQI_mean( X:qiVector; size:UInt ); Extended;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>mean = (1 / size) * sum( X<sub>i</sub> )
<BR>Integer versions: the mean of a distribution consisting of whole numbers generally is a fractional, i.e. a floating-point number. Therefore, the return value of the 8, 16, and 32-bit integer versions is a double. For the 64-bit integer version, <I>VQI_mean</I>, the return value is an extended.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>Mean of the vector elements (except complex versions in Pascal/Delphi)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#meanwW">VF_meanwW</a>,&nbsp;&nbsp; <a href="#median">VF_median</a>,&nbsp;&nbsp; <a href="#meanvar">VF_meanvar</a>,&nbsp;&nbsp; <a href="#fsum">VI_fsum</a>,&nbsp;&nbsp; <a href="#varianceC">VF_varianceC</a>,&nbsp;&nbsp; <a href="#linregress">VF_linregress</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="meanabs"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_meanabs</b></font></td><td width="33%"><font size="+1"><b>VD_meanabs</b></font></td><td><font size="+1"><b>VE_meanabs</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Mean of the absolute values of a one-dimensional distribution</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_meanabs( fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::meanabs();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_meanabs( X:fVector; size: UInt ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>meanabs = (1 / size) * sum(| X<sub>i</sub> |)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>Mean of the absolute values of all vector elements</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mean">VF_mean</a>,&nbsp;&nbsp; <a href="#sumabs">VF_sumabs</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="meanvar"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_meanvar</b></font></td><td width="33%"><font size="+1"><b>VD_meanvar</b></font></td><td><font size="+1"><b>VE_meanvar</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Mean and variance of a one-dimensional distribution</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_meanvar( float *Var, fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::meanvar( T *Var );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_meanvar( var Variance:Single; X:fVector; size: UInt ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>mean = (1 / size) * sum( X<sub>i</sub> )
<BR>var = (1 / (size-1)) * sum( (X<sub>i</sub> - mean)<sup>2</sup> )
<BR>Note that the denominator in the definition of var is size-1, whereas, in the routine <I><a href="#varianceC">VF_varianceC</a></I>, it is simply size.The reason for that difference is that here the mean is calculated first and then the variance is determined using this value, whereas in <I><a href="#varianceC">VF_varianceC</a></I>, the parameter C is pre-set. The mean is returned and the variance stored at the address passed as &quot;Var&quot; (C/C++), or in the variable &quot;variance&quot; (Pascal/Delphi).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>mean of the vector elements.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mean">VF_mean</a>,&nbsp;&nbsp; <a href="#varianceC">VF_varianceC</a>,&nbsp;&nbsp; <a href="#varianceV">VF_varianceV</a>,&nbsp;&nbsp; <a href="#sum">VF_sum</a>,&nbsp;&nbsp; <a href="#ssq">VF_ssq</a>,&nbsp;&nbsp; <a href="#ssqdevC">VF_ssqdevC</a>,&nbsp;&nbsp; <a href="#linregress">VF_linregress</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="meanvarwW"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_meanvarwW</b></font></td><td width="33%"><font size="+1"><b>VD_meanvarwW</b></font></td><td><font size="+1"><b>VE_meanvarwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Mean and variance with weights</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>float VF_meanvarwW( float *Var, fVector X, fVector Wt, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::meanvarwW( T *Var, const vector&lt;T&gt;& Wt );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_meanvarwW( var variance:Single; X, Wt:fVector; size:UInt ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>mean = (1 / sum( Wt<sub>i</sub> )) * sum( X<sub>i</sub> * Wt<sub>i</sub> )
<BR>var = (1 / sum( Wt<sub>i</sub> )) * sum( Wt<sub>i</sub> * (X<sub>i</sub> - mean)<sup>2</sup> ) 
<BR>The weighted mean is returned and the variance stored at the address passed as &quot;Var&quot; (C/C++) or in the variable &quot;variance&quot; (Pascal/Delphi).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>mean of the vector elements.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#meanwW">VF_meanwW</a>,&nbsp;&nbsp; <a href="#varianceCwW">VF_varianceCwW</a>,&nbsp;&nbsp; <a href="#varianceVwW">VF_varianceVwW</a>,&nbsp;&nbsp; <a href="#linregress">VF_linregress</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="meanwW"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_meanwW</b></font></td><td width="33%"><font size="+1"><b>VD_meanwW</b></font></td><td><font size="+1"><b>VE_meanwW</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_meanwW</b></font></td><td width="33%"><font size="+1"><b>VCD_meanwW</b></font></td><td><font size="+1"><b>VCE_meanwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Mean with weights</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_meanwW( fVector X, fVector Wt, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
<BR><font face="courier new">fComplex VCF_meanwW( cfVector X, fVector Wt, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_</I>)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::meanwW( const vector&lt;T&gt;& Wt );
<BR>fComplex vector&lt;complex&lt;T&gt;&gt;::meanwW( const vector&lt;T&gt;& Wt );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_meanwW( X, Wt:fVector; size:UInt ): Single;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_</I>)
<BR><font face="courier new">procedure VCF_meanwW( var Mean:fComplex; X:cfVector; Wt:fVector; size:UInt );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_</I>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>meanwW = (1 / sum( Wt<sub>i</sub> )) * sum( X<sub>i</sub> * Wt<sub>i</sub> )
<BR>Notice that, also in the complex version, the weights are always real rather than complex.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>weighted mean of the vector elements (except complex versions in Pascal/Delphi).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mean">VF_mean</a>,&nbsp;&nbsp; <a href="#sum">VF_sum</a>,&nbsp;&nbsp; <a href="#ssq">VF_ssq</a>,&nbsp;&nbsp; <a href="#ssqdevC">VF_ssqdevC</a>,&nbsp;&nbsp; <a href="#median">VF_median</a>,&nbsp;&nbsp; <a href="#meanvarwW">VF_meanvarwW</a>,&nbsp;&nbsp; <a href="#linregresswW">VF_linregresswW</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="median"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_median</b></font></td><td width="33%"><font size="+1"><b>VD_median</b></font></td><td><font size="+1"><b>VE_median</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Median of a one-dimensional distribution</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>float VF_median( fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::median();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_median( X:fVector; size:UInt ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The median of a distribution is defined as the value for which values above and below are equally probable, i.e., for which the number of elements greater and less than the median is equal. If the table X is ordered, the median is simply the element with the index (size+1)/2 (if size is odd) or the mean of the two central elements (if size is even). If a table is not ordered, <I>VF_median</I> finds its median by repeatedly scanning the table through, without actually sorting it.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The median is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mean">VF_mean</a>,&nbsp;&nbsp; <a href="#meanwW">VF_meanwW</a>,&nbsp;&nbsp; <a href="#sum">VF_sum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="min"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_min</b></font></td><td width="33%"><font size="+1"><b>VD_min</b></font></td><td><font size="+1"><b>VE_min</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_min</b></font></td><td width="20%"><font size="+1"><b>VBI_min</b></font></td><td width="20%"><font size="+1"><b>VSI_min</b></font></td><td width="20%"><font size="+1"><b>VLI_min</b></font></td><td><font size="+1"><b>VQI_min</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_min</b></font></td><td width="20%"><font size="+1"><b>VUB_min</b></font></td><td width="20%"><font size="+1"><b>VUS_min</b></font></td><td width="20%"><font size="+1"><b>VUL_min</b></font></td><td><font size="+1"><b>VUI_min</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Finds the smallest (or the most negative) element of a vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_min( fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::_min();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_min( X:fVector; size:UInt ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector X is searched for its smallest (or most negative) element. In order to avoid confusion with the macro "min" in C/C++, the VecObj version of this function is written with a leading underbar as "_min".</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>Minimum value encountered.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#absmin">VF_absmin</a>,&nbsp;&nbsp; <a href="#runmin">VF_runmin</a>,&nbsp;&nbsp; <a href="#minind">VF_minind</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="minC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_minC</b></font></td><td width="33%"><font size="+1"><b>VD_minC</b></font></td><td><font size="+1"><b>VE_minC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_minC</b></font></td><td width="20%"><font size="+1"><b>VBI_minC</b></font></td><td width="20%"><font size="+1"><b>VSI_minC</b></font></td><td width="20%"><font size="+1"><b>VLI_minC</b></font></td><td><font size="+1"><b>VQI_minC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_minC</b></font></td><td width="20%"><font size="+1"><b>VUB_minC</b></font></td><td width="20%"><font size="+1"><b>VUS_minC</b></font></td><td width="20%"><font size="+1"><b>VUL_minC</b></font></td><td><font size="+1"><b>VUI_minC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Compare each element of a vector to a constant and take the smaller of the two.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_minC( fVector Y, fVector X, ui size, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::minC( const vector&lt;T&gt;& X, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_minC( Y, X:fVector; size:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>i</sub>,&nbsp;&nbsp;if X<sub>i</sub> &lt;= C
<BR>Y<sub>i</sub> = C,&nbsp;&nbsp;if X<sub>i</sub> &gt; C</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#minV">VF_minV</a>,&nbsp;&nbsp; <a href="#maxC">VF_maxC</a>,&nbsp;&nbsp; <a href="#min">VF_min</a>,&nbsp;&nbsp; <a href="#absmin">VF_absmin</a>,&nbsp;&nbsp; <a href="#limit">VF_limit</a>,&nbsp;&nbsp; <a href="#flush0">VF_flush0</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="minind"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_minind</b></font></td><td width="33%"><font size="+1"><b>VD_minind</b></font></td><td><font size="+1"><b>VE_minind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_minind</b></font></td><td width="20%"><font size="+1"><b>VBI_minind</b></font></td><td width="20%"><font size="+1"><b>VSI_minind</b></font></td><td width="20%"><font size="+1"><b>VLI_minind</b></font></td><td><font size="+1"><b>VQI_minind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_minind</b></font></td><td width="20%"><font size="+1"><b>VUB_minind</b></font></td><td width="20%"><font size="+1"><b>VUS_minind</b></font></td><td width="20%"><font size="+1"><b>VUL_minind</b></font></td><td><font size="+1"><b>VUI_minind</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the smallest (or the most negative) element of a vector and its index.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_minind( ui *Ind, fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::minind( ui *Ind );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_minind( var Ind:UInt; X:fVector; size:UInt ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector X is searched for its smallest (or most negative) element; its value is returned. At the address passed as Ind, the index of this element is stored. In the case of several mimima of equal depth, the first one is chosen (i.e., the smallest of their indices is stored in Ind).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>minimum value encountered.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#min">VF_min</a>,&nbsp;&nbsp; <a href="#maxind">VF_maxind</a>,&nbsp;&nbsp; <a href="#absmin">VF_absmin</a>,&nbsp;&nbsp; <a href="#runmin">VF_runmin</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="minReIm"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_minReIm</b></font></td><td width="33%"><font size="+1"><b>VCD_minReIm</b></font></td><td><font size="+1"><b>VCE_minReIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Find the smallest (or most negative) real and imaginary parts occurring in a vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>fComplex VCF_minReIm( cfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>complex&lt;T&gt; vector&lt;complex&lt;T&gt;&gt;::minReIm();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VCF_minReIm( var Min:fComplex; X:cfVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector X is separately searched for its smallest real and imaginary parts. These are packed together and either returned as an fComplex (in C/C++) or stored in Min (in Pascal/Delphi):
<BR>Min.Re: smallest real part encountered,
<BR>Min.Im: smallest imaginary part encountered.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td><u>C/C++:</u>
<BR>struct or class instance of type fComplex (dComplex, eComplex, resp.), in which the minima of the real and imaginary parts of X are packed together.
<BR><u>Pascal/Delphi:</u>
<BR>since Pascal does not allow complex return values, the result is stored in the variable Min.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#maxReIm">VCF_maxReIm</a>,&nbsp;&nbsp; <a href="#absminReIm">VCF_absminReIm</a>,&nbsp;&nbsp; <a href="#absmin">VCF_absmin</a>,&nbsp;&nbsp; <a href="#absminind">VCF_absminind</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="minV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_minV</b></font></td><td width="33%"><font size="+1"><b>VD_minV</b></font></td><td><font size="+1"><b>VE_minV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_minV</b></font></td><td width="20%"><font size="+1"><b>VBI_minV</b></font></td><td width="20%"><font size="+1"><b>VSI_minV</b></font></td><td width="20%"><font size="+1"><b>VLI_minV</b></font></td><td><font size="+1"><b>VQI_minV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_minV</b></font></td><td width="20%"><font size="+1"><b>VUB_minV</b></font></td><td width="20%"><font size="+1"><b>VUS_minV</b></font></td><td width="20%"><font size="+1"><b>VUL_minV</b></font></td><td><font size="+1"><b>VUI_minV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Compare each element of a vector to the corresponding element of another vector and take the smaller of the two.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_minV( fVector Z, fVector X, fVector Y, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::minV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_minV( Z, X, Y:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Z<sub>i</sub> = X<sub>i</sub>,&nbsp;&nbsp;if X<sub>i</sub> &lt;= Y<sub>i</sub>
<BR>Z<sub>i</sub> = Y<sub>i</sub>,&nbsp;&nbsp;if X<sub>i</sub> &gt; Y<sub>i</sub></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#maxV">VF_maxV</a>,&nbsp;&nbsp; <a href="#minC">VF_minC</a>,&nbsp;&nbsp; <a href="#min">VF_min</a>,&nbsp;&nbsp; <a href="#absmin">VF_absmin</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="modC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_modC</b></font></td><td width="33%"><font size="+1"><b>VD_modC</b></font></td><td><font size="+1"><b>VE_modC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_modC</b></font></td><td width="20%"><font size="+1"><b>VBI_modC</b></font></td><td width="20%"><font size="+1"><b>VSI_modC</b></font></td><td width="20%"><font size="+1"><b>VLI_modC</b></font></td><td><font size="+1"><b>VQI_modC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_modC</b></font></td><td width="20%"><font size="+1"><b>VUB_modC</b></font></td><td width="20%"><font size="+1"><b>VUS_modC</b></font></td><td width="20%"><font size="+1"><b>VUL_modC</b></font></td><td><font size="+1"><b>VUI_modC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Modulus, i.e. the remainder of a division by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_modC( fVector Y, fVector X, ui size, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::modC( const vector&lt;T&gt;& X, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_modC( Y, X:fVector; size:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>i</sub> mod C
<BR>Floating-point versions: a constant C = 0.0 leads to all Y<sub>i</sub> being 0.0, independently of the X<sub>i</sub> values (as in the ANSI C math function <I>fmod </I>).
<BR>Integer versions: a constant C = 0 leads to a ZERODIVIDE error (as in the intrinsic &quot;%&quot; operation of ANSI C).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none (also the floating-point versions are treated as basic arithmetic rather than mathematical functions, despite their relation to the math function <I>fmod</I>).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#modV">VF_modV</a>,&nbsp;&nbsp; <a href="#addC">VF_addC</a>,&nbsp;&nbsp; <a href="#mulC">VF_mulC</a>,&nbsp;&nbsp; <a href="#divC">VF_divC</a>,&nbsp;&nbsp; <a href="#visC">VF_visC</a>,&nbsp;&nbsp; <a href="#redC">VF_redC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="modf"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_modf</b></font></td><td width="33%"><font size="+1"><b>VD_modf</b></font></td><td><font size="+1"><b>VE_modf</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Split up into integer and fractional parts.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_modf( fVector IntPart, fVector FracPart, fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::modf( vector&lt;T&gt; FracPart, const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td>These functions are absent. Use VF_intfrac etc.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>These functions are implemented as alias names for <I><a href="#intfrac">VF_intfrac</a></I> etc., in order to maintain consistency with the ANSI C function name <I>modf</I>. For details, see <I><a href="#intfrac">VF_intfrac</a></I>.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="modV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_modV</b></font></td><td width="33%"><font size="+1"><b>VD_modV</b></font></td><td><font size="+1"><b>VE_modV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_modV</b></font></td><td width="33%"><font size="+1"><b>VDx_modV</b></font></td><td><font size="+1"><b>VEx_modV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_modV</b></font></td><td width="20%"><font size="+1"><b>VBI_modV</b></font></td><td width="20%"><font size="+1"><b>VSI_modV</b></font></td><td width="20%"><font size="+1"><b>VLI_modV</b></font></td><td><font size="+1"><b>VQI_modV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_modV</b></font></td><td width="20%"><font size="+1"><b>VUB_modV</b></font></td><td width="20%"><font size="+1"><b>VUS_modV</b></font></td><td width="20%"><font size="+1"><b>VUL_modV</b></font></td><td><font size="+1"><b>VUI_modV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Modulus, i.e. the remainder of a division of corresponding vector elements</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_modV( fVector Z, fVector X, fVector Y, ui size );
<BR>void VFx_modV( fVector Z, fVector X, fVector Y, ui size, float A, float B );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::modV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y );
<BR>void vector&lt;T&gt;::x_modV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y, T A, T B );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_modV( Z, X, Y:fVector; size:UInt );
<BR>procedure VFx_modV( Z, X, Y:fVector; size:UInt; A, B:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Z<sub>i</sub> = X<sub>i</sub> mod Y<sub>i</sub>
<BR>expanded versions: Z<sub>i</sub> = (A * X<sub>i</sub> + B) mod Y<sub>i</sub>
<BR>Floating-point versions: an argument X<sub>i</sub> = 0.0 leads to Z<sub>i</sub> being 0.0, independently of Y<sub>i</sub> (as in the ANSI C math function <I>fmod</I>).
<BR>Integer versions: an argument X<sub>i</sub> = 0 leads to a ZERODIVIDE error (as in the intrinsic &quot;%&quot; operation of ANSI C).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none (also the floating-point versions are treated as basic arithmetic rather than mathematical functions, despite their relation to the math function <I>fmod</I>).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#modC">VF_modC</a>,&nbsp;&nbsp; <a href="#addV">VF_addV</a>,&nbsp;&nbsp; <a href="#mulV">VF_mulV</a>,&nbsp;&nbsp; <a href="#divV">VF_divV</a>,&nbsp;&nbsp; <a href="#visV">VF_visV</a>,&nbsp;&nbsp; <a href="#redV">VF_redV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="mulC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_mulC</b></font></td><td width="33%"><font size="+1"><b>VD_mulC</b></font></td><td><font size="+1"><b>VE_mulC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_mulC</b></font></td><td width="33%"><font size="+1"><b>VCD_mulC</b></font></td><td><font size="+1"><b>VCE_mulC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_mulReC</b></font></td><td width="33%"><font size="+1"><b>VCD_mulReC</b></font></td><td><font size="+1"><b>VCE_mulReC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_mulC</b></font></td><td width="33%"><font size="+1"><b>VPD_mulC</b></font></td><td><font size="+1"><b>VPE_mulC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_mulReC</b></font></td><td width="33%"><font size="+1"><b>VPD_mulReC</b></font></td><td><font size="+1"><b>VPE_mulReC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_mulC</b></font></td><td width="20%"><font size="+1"><b>VBI_mulC</b></font></td><td width="20%"><font size="+1"><b>VSI_mulC</b></font></td><td width="20%"><font size="+1"><b>VLI_mulC</b></font></td><td><font size="+1"><b>VQI_mulC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_mulC</b></font></td><td width="20%"><font size="+1"><b>VUB_mulC</b></font></td><td width="20%"><font size="+1"><b>VUS_mulC</b></font></td><td width="20%"><font size="+1"><b>VUL_mulC</b></font></td><td><font size="+1"><b>VUI_mulC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Multiply all vector elements by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_mulC( fVector Y, fVector X, ui size, float C );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_,&nbsp;&nbsp; VI_</I>, etc.)
<BR><font face="courier new">void VCF_mulC( cfVector Y, cfVector X, ui size, fComplex C );
<BR>void VCF_mulReC( cfVector Y, cfVector X, ui size, float CRe );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VPF_,&nbsp;&nbsp; VPD_,&nbsp;&nbsp; VPE_</I>)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::mulC( const vector&lt;T&gt;& X, T C );
<BR>void vector&lt;complex&lt;T&gt;&gt;::mulC( const vector&lt;complex&lt;T&gt;&gt;& X, complex&lt;T&gt; C );
<BR>void vector&lt;complex&lt;T&gt;&gt;::mulReC( const vector&lt;complex&lt;T&gt;&gt;& X, T CRe );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_mulC( Y, X:fVector; size:UInt; C:Single );
<BR>procedure VCF_mulC( Y, X:cfVector; size:UInt; C:fComplex );
<BR>procedure VCF_mulReC( Y, X:cfVector; size:UInt; CRe:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = C * X<sub>i</sub>
<BR>The complex floating-point versions exist in two variants, one for complex constants C, the other for real-valued constants CRe by which the complex vector is multiplied.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mulV">VF_mulV</a>,&nbsp;&nbsp; <a href="#addC">VF_addC</a>,&nbsp;&nbsp; <a href="#divC">VF_divC</a>,&nbsp;&nbsp; <a href="#divrC">VF_divrC</a>,&nbsp;&nbsp; <a href="#visC">VF_visC</a>,&nbsp;&nbsp; <a href="#redC">VF_redC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="mulV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_mulV</b></font></td><td width="33%"><font size="+1"><b>VD_mulV</b></font></td><td><font size="+1"><b>VE_mulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_mulV</b></font></td><td width="33%"><font size="+1"><b>VCD_mulV</b></font></td><td><font size="+1"><b>VCE_mulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_mulReV</b></font></td><td width="33%"><font size="+1"><b>VCD_mulReV</b></font></td><td><font size="+1"><b>VCE_mulReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_mulVconj</b></font></td><td width="33%"><font size="+1"><b>VCD_mulVconj</b></font></td><td><font size="+1"><b>VCE_mulVconj</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFs_mulV</b></font></td><td width="33%"><font size="+1"><b>VDs_mulV</b></font></td><td><font size="+1"><b>VEs_mulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_mulV</b></font></td><td width="33%"><font size="+1"><b>VDx_mulV</b></font></td><td><font size="+1"><b>VEx_mulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_mulV</b></font></td><td width="33%"><font size="+1"><b>VCDx_mulV</b></font></td><td><font size="+1"><b>VCEx_mulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_mulReV</b></font></td><td width="33%"><font size="+1"><b>VCDx_mulReV</b></font></td><td><font size="+1"><b>VCEx_mulReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_mulVconj</b></font></td><td width="33%"><font size="+1"><b>VCDx_mulVconj</b></font></td><td><font size="+1"><b>VCEx_mulVconj</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_mulV</b></font></td><td width="33%"><font size="+1"><b>VPD_mulV</b></font></td><td><font size="+1"><b>VPE_mulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_mulReV</b></font></td><td width="33%"><font size="+1"><b>VPD_mulReV</b></font></td><td><font size="+1"><b>VPE_mulReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_mulV</b></font></td><td width="20%"><font size="+1"><b>VBI_mulV</b></font></td><td width="20%"><font size="+1"><b>VSI_mulV</b></font></td><td width="20%"><font size="+1"><b>VLI_mulV</b></font></td><td><font size="+1"><b>VQI_mulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_mulV</b></font></td><td width="20%"><font size="+1"><b>VUB_mulV</b></font></td><td width="20%"><font size="+1"><b>VUS_mulV</b></font></td><td width="20%"><font size="+1"><b>VUL_mulV</b></font></td><td><font size="+1"><b>VUI_mulV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Multiply corresponding vector elements</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_mulV( fVector Z, fVector X, fVector Y, ui size );
<BR>void VFs_mulV( fVector Z, fVector X, fVector Y, ui size, float C );
<BR>void VFx_mulV( fVector Z, fVector X, fVector Y, ui size, float A, float B );
<BR>void VCF_mulV( cfVector Z, cfVector X, cfVector Y, ui size );
<BR>void VCF_mulReV( cfVector Z, cfVector X, fVector Y, ui size );
<BR>void VCF_mulVconj( cfVector Z, cfVector X, cfVector Y, ui size );
<BR>void VCFx_mulV( cfVector Z, cfVector X, cfVector Y, ui size, fComplex A, fComplex B );
<BR>void VCFx_mulReV( cfVector Z, cfVector X, fVector Y, ui size, fComplex A, fComplex B );
<BR>void VCFx_mulVconj( cfVector Z, cfVector X, cfVector Y, ui size, fComplex A, fComplex B );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::mulV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y );
<BR>void vector&lt;T&gt;::s_mulV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y, T C );
<BR>void vector&lt;T&gt;::x_mulV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y, T A, T B );
<BR>void vector&lt;complex&lt;T&gt;&gt;::mulV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;complex&lt;T&gt;&gt;& Y );
<BR>void vector&lt;complex&lt;T&gt;&gt;::mulReV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;T&gt;& Y );
<BR>void vector&lt;complex&lt;T&gt;&gt;::mulVconj( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;complex&lt;T&gt;&gt;& Y );
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_mulV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;complex&lt;T&gt;&gt;& Y, complex&lt;T&gt; A, complex&lt;T&gt; B );
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_mulReV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;T&gt;& Y, complex&lt;T&gt; A, complex&lt;T&gt; B );
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_mulVconj( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;complex&lt;T&gt;&gt;& Y, complex&lt;T&gt; A, complex&lt;T&gt; B );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_mulV( Z, X, Y:fVector; size:UInt );
<BR>procedure VFs_mulV( Z, X, Y:fVector; size:UInt; C:Single );
<BR>procedure VFx_mulV( Z, X, Y:fVector; size:UInt; A, B:Single );
<BR>procedure VCF_mulV( Z, X, Y:cfVector; size:UInt );
<BR>procedure VCF_mulReV( Z, X:cfVector; Y:fVector; size:UInt );
<BR>procedure VCF_mulVconj( Z, X, Y:cfVector; size:UInt );
<BR>procedure VCFx_mulV( Z, X, Y:cfVector; size:UInt; A, B:fComplex );
<BR>procedure VCFx_mulReV( Z, X:cfVector; Y:fVector; size:UInt; A, B:fComplex );</font></td></tr></table></td></tr>
<BR>procedure VCFx_mulVconj( Z, X, Y:cfVector; size:UInt; A, B:fComplex );
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Z<sub>i</sub> = X<sub>i</sub> * Y<sub>i</sub>
<BR>scaled versions (<i>VFs_</i> etc.): Z<sub>i</sub> = C * (X<sub>i</sub> * Y<sub>i</sub>)
<BR>expanded versions (<i>VFx_</i> etc.): Z<sub>i</sub> = (A * X<sub>i</sub> + B) * Y<sub>i</sub>
<BR>The complex floating-point versions exist in three variants: in the first variant (e.g. <I>VCF_mulV,&nbsp;&nbsp; VCFx_mulV</I>), X, Y, and Z are all complex; in the second variant, Y is real-valued (e.g. <I>VCF_mulReV</I> - &quot;multiply by a real vector&quot;); in the third variant, finally (e.g. <I>VCF_mulVconj,&nbsp;&nbsp; VCFx_mulVconj</I>), X is multiplied by the complex conjugate of Y instead of Y itself.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mulC">VF_mulC</a>,&nbsp;&nbsp; <a href="#addV">VF_addV</a>,&nbsp;&nbsp; <a href="#subV">VF_subV</a>,&nbsp;&nbsp; <a href="#divV">VF_divV</a>,&nbsp;&nbsp; <a href="#visV">VF_visV</a>,&nbsp;&nbsp; <a href="#redV">VF_redV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="neg"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_neg</b></font></td><td width="33%"><font size="+1"><b>VD_neg</b></font></td><td><font size="+1"><b>VE_neg</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_neg</b></font></td><td width="33%"><font size="+1"><b>VCD_neg</b></font></td><td><font size="+1"><b>VCE_neg</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_neg</b></font></td><td width="33%"><font size="+1"><b>VPD_neg</b></font></td><td><font size="+1"><b>VPE_neg</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_neg</b></font></td><td width="20%"><font size="+1"><b>VBI_neg</b></font></td><td width="20%"><font size="+1"><b>VSI_neg</b></font></td><td width="20%"><font size="+1"><b>VLI_neg</b></font></td><td><font size="+1"><b>VQI_neg</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Negation</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_neg( fVector Y, fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::neg( const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_neg( Y, X:fVector; size:UInt ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = - (X<sub>i</sub>)
<BR><I>VBI_,&nbsp;&nbsp; VSI_,&nbsp;&nbsp; VI_</I>, and <I>VLI_</I> versions only: the negation of the most negative number possible (-128 for byte/ByteInt, -32768 for short/SmallInt, -2147483648 for long/LongInt) is again the same - negative! - number. This is due to the implicit modulo-2<sup>n</sup> arithmetics, where the overflowing byte/ByteInt, +128, is stored as -128, the overflowing short/SmallInt, +32768, is stored as -32768, and the overflowing long/LongInt, +2147483648, is stored as -2147483648.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>By analogy with <I><a href="#abs">VF_abs</a></I>, the floating-point versions are treated as math functions. Therefore, they have a return value which, since no errors can occur, is always FALSE (0). The integer versions have no return value.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#abs">VF_abs</a>,&nbsp;&nbsp; <a href="#conj">VCF_conj</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="nfree"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_nfree</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>De-allocate memory occupied by one or more vectors.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>void V_nfree( unsigned numfree, ... );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td>This function is absent.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The parameter numfree &quot;tells&quot; the function how many vectors it has to free. These vectors follow in the parameter list after numfree. De-allocation of vectors not allocated by one of the functions of the <I><a href="#vector">VF_vector</a></I> or <I><a href="#vector0">VF_vector0</a></I> family is discouraged, especially in Windows programs.
<BR>Pascal/Delphi: since a variable number of parameters is not supported in Pascal language, this function is missing.</td></tr>
<tr valign="TOP">
<td>Example C/C++</td><td><font face="courier new">V_nfree( 3, X, Y, Z );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#free">V_free</a>,&nbsp;&nbsp; <a href="#freeAll">V_freeAll</a>,&nbsp;&nbsp; <a href="#vector">VF_vector</a>,&nbsp;&nbsp; <a href="#vector0">VF_vector0</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="noise"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_noise</b></font></td><td width="33%"><font size="+1"><b>VD_noise</b></font></td><td><font size="+1"><b>VE_noise</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initialize a vector with &quot;white&quot; noise</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>long VF_noise( fVector X, ui size, long seed, float Amp );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>long vector&lt;T&gt;::noise( long seed, T Amp );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_noise( X:fVector; size:UInt; Seed:LongInt; Amp:Single ): LongInt;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>White noise is generated with the amplitude Amp, i.e., the output values are between -Amp/2 and +Amp/2 (both extrema included). "seed" may be chosen completely arbitrary. Successive calls with the same seed yield identical results; for different values of seed, the obtained results are uncorrelated.
<P>Internally, these functions employ a 32-bit integer random number generator by H.W.Lewis, with additional steps (so-called &quot;Bays-Durham shuffle&quot;) to break sequential correlations. This ensures very good randomness, far superior to simpler generators (like the <I>rand</I> function shipped with C/C++ and the <I>Random</I> function of Pascal).
<P>A long value is returned which may be used as new seed for subsequent calls.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>last 32-bit random number internally generated; may be used as new seed value for future calls.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I>rand,&nbsp;&nbsp; random,&nbsp;&nbsp; <a href="#random">VF_random</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="norm"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_norm</b></font></td><td width="33%"><font size="+1"><b>VCD_norm</b></font></td><td><font size="+1"><b>VCE_norm</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_normtoC</b></font></td><td width="33%"><font size="+1"><b>VCD_normtoC</b></font></td><td><font size="+1"><b>VCE_normtoC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_norm</b></font></td><td width="33%"><font size="+1"><b>VPD_norm</b></font></td><td><font size="+1"><b>VPE_norm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Norm (square of the magnitude) of complex numbers.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd&gt;
<BR>void VCF_norm( fVector Norm, cfVector X, ui size );
<BR>void VPF_norm( fVector Norm, pfVector X, ui size );
<BR>void VCF_normtoC( cfVector Norm, cfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::norm( const vector&lt;complex&lt;T&gt;&gt;& X );
<BR>void vector&lt;complex&lt;T&gt;&gt;::normtoC( const vector&lt;complex&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VCF_norm( Norm:fVector; X:cfVector; size:UInt );
<BR>procedure VPF_norm( Norm:fVector; X:pfVector; size:UInt );
<BR>procedure VCF_normtoC( Norm, X:cfVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><i>VCF_norm</i> is identical to <I><a href="#CtoNorm">VF_CtoNorm</a></I>, and <i>VPF_norm</i> is identical to <I><a href="#PtoNorm">VF_PtoNorm</a></I>. See those functions for details.
<BR><I>VCF_normtoC</I> calculates the norm of a cartesian complex vector and stores it as a complex vector (with all imaginary parts equal to 0).</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="not"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_not</b></font></td><td width="20%"><font size="+1"><b>VBI_not</b></font></td><td width="20%"><font size="+1"><b>VSI_not</b></font></td><td width="20%"><font size="+1"><b>VLI_not</b></font></td><td><font size="+1"><b>VQI_not</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_not</b></font></td><td width="20%"><font size="+1"><b>VUB_not</b></font></td><td width="20%"><font size="+1"><b>VUS_not</b></font></td><td width="20%"><font size="+1"><b>VUL_not</b></font></td><td><font size="+1"><b>VUI_not</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Bit-wise complement</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VImath.h&gt;
<BR>void VI_not( iVector Y, iVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::not( const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VImath;
<BR>procedure VI_not( Y, X:iVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = ~(X<sub>i</sub>)
<BR>Each single bit of the element X<sub>i</sub> is inverted (i.e., it is 0 in Y<sub>i</sub>, if it was 1 in X<sub>i</sub>, and vice versa).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#and">VI_and</a>,&nbsp;&nbsp; <a href="#or">VI_or</a>,&nbsp;&nbsp; <a href="#neg">VI_neg</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="noteError"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_noteError</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Construct and print an error message</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>void V_noteError( char *fname, unsigned why );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>procedure V_noteError( fname:PChar; why:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>In case of an error, the math functions of <I>VectorLib</I> invoke the following steps:
<BR><u>C/C++:</u> First call <I>_matherr</I> (or <I>_matherrl</I>), then inspect the return value of <I>_matherr</I> (or <I>_matherrl</I>) and call <I>V_noteError</I> in case this return value was 0.
<P><u>Pascal/Delphi:</u> Call <I>V_noteError</I> if <I><a href="#FPErrorHandlingMode">V_FPErrorHandlingMode</a></I> contains fpErrorNote for the type of error that occurred. <I>V_noteError</I> then constructs the appropriate error message and passes it to <I><a href="#printErrorMsg">V_printErrorMsg</a></I>, which is the function in charge of actually printing the error message.
<P>By default, output is directed to the screen. This may be changed by a call to <I><a href="#setErrorEventFile">V_setErrorEventFile</a></I> (see <a href="HANDBOOK.HTM#chap5_3">chapter&nbsp;5.3</a>).
<P>&quot;fname&quot; is the name of the &quot;complaining&quot; function, and &quot;why&quot; specifies the reason for the complaint.
<BR><u>C/C++: </u>see the description of <I>_matherr</I> in your compiler's documentation for error codes.
<BR>How to call <I>V_noteError</I> from a user-defined <I>_matherr</I> function is described in <a href="HANDBOOK.HTM#chap5_3">chapter&nbsp;5.3.</a>.
<P><u>Pascal/Delphi:</u> The parameter &quot;why&quot; may take on the following values:
<BR>1 for DOMAIN errors
<BR>2 for SING errors
<BR>3 for OVERFLOW errors
<BR>4 for UNDERFLOW errors
<BR>5 for TLOSS errors
<P>This function will not be included in versions of <I>OptiVec</I> for compilers that do already offer the possibility of printing error messages simultaneously to the screen and to an event file.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#setErrorEventFile">V_setErrorEventFile</a>,&nbsp;&nbsp; <a href="#printErrorMsg">V_printErrorMsg</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="nread"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_nread</b></font></td><td width="33%"><font size="+1"><b>VD_nread</b></font></td><td><font size="+1"><b>VE_nread</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_nread</b></font></td><td width="33%"><font size="+1"><b>VCD_nread</b></font></td><td><font size="+1"><b>VCE_nread</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_nread</b></font></td><td width="33%"><font size="+1"><b>VPD_nread</b></font></td><td><font size="+1"><b>VPE_nread</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_nread</b></font></td><td width="20%"><font size="+1"><b>VBI_nread</b></font></td><td width="20%"><font size="+1"><b>VSI_nread</b></font></td><td width="20%"><font size="+1"><b>VLI_nread</b></font></td><td><font size="+1"><b>VQI_nread</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_nread</b></font></td><td width="20%"><font size="+1"><b>VUB_nread</b></font></td><td width="20%"><font size="+1"><b>VUS_nread</b></font></td><td width="20%"><font size="+1"><b>VUL_nread</b></font></td><td><font size="+1"><b>VUI_nread</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Read the columns of a table from a stream</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_nread( unsigned n, ui size, FILE *stream, ... );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_nread( VecList:^fVector; n:Word; size:UInt; var stream:Text );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description C/C++</td><td>n columns of a table are read into the vectors passed to <I>VF_nread</I>. The number of lines is specified as the number of elements of each vector, which is size.
<P>The entries of each line should be separated by spaces (' ') or tab characters ('\t').
<P>Each line must be terminated by a line-feed character ('\n'). The length of the lines is limited according the following rules:
<BR>- Either all lines have the same length. In this case, the length is determined automatically and might in principle be as large as 65535 characters.
<BR>- Or the maximum length is given by the number n of vectors to be read and by the data type:<br>&nbsp;
<table border width="100%">
<tr valign="TOP"><td><table width="100%"><tr><td width="60%"><I>VF_</I></td><td>&nbsp;24*n</td></tr></table></td>
<td><table width="100%"><tr><td width="20%"><I>VBI_,&nbsp;&nbsp; VUB_</I></td><td>13*n</td></tr></table></td></tr>
<tr valign="TOP"><td><table width="100%"><tr><td width="60%"><I>VD_</I></td><td>&nbsp;32*n</td></tr></table></td>
<td><table width="100%"><tr><td width="20%"><I>VSI_,&nbsp;&nbsp; VUS_</I></td><td>21*n</td></tr></table></td></tr>
<tr valign="TOP"><td><table width="100%"><tr><td width="60%"><I>VE_</I></td><td>&nbsp;40*n</td></tr></table></td>
<td><table width="100%"><tr><td width="20%"><I>VLI_,&nbsp;&nbsp; VUL_</I></td><td>37*n</td></tr></table></td></tr>
<tr valign="TOP"><td><table width="100%"><tr><td width="60%"><I>VCF_,&nbsp;&nbsp; VPF_</I></td><td>&nbsp;48*n</td></tr></table></td>
<td><table width="100%"><tr><td width="20%"><I>VQI_</I></td><td>32*n</td></tr></table></td></tr>
<tr valign="TOP"><td><table width="100%"><tr><td width="60%"><I>VCD_,&nbsp;&nbsp; VPD_</I></td><td>&nbsp;64*n</td></tr></table></td>
<td><table width="100%"><tr valign="top"><td width="20%"><I>VI_,&nbsp;&nbsp; VU_</I></td><td>as <I>VLI_,&nbsp;&nbsp; VUL_</I><BR>(in the 16-bit models as <I>VSI_,&nbsp;&nbsp; VUS_</I>)</td></tr></table></td></tr>
<tr valign="TOP"><td><table width="100%"><tr><td width="60%"><I>VCE_,&nbsp;&nbsp; VPE_</I></td><td>&nbsp;80*n</td></tr></table></td><td>&nbsp;</TD></tr></table>
<P>It is possible to read fewer vectors than there are columns in a table. In this case, the trailing columns are neglected. If, however, you try to read more vectors than there are columns, the result is undefined and might lead to an error.
<P>Complex versions (both cartesian and polar):
<BR>Real und imaginary (or Mag and Arg) parts may, but need not, be enclosed in braces { }. However, you must be consequent: Either all or no element may be written with braces.
<P>Whole-number versions except <I>VQI_nread</I>:
<BR>By default, the numbers to be read are interpreted as decimal numbers. You may use <I><a href="#setRadix">V_setRadix</a></I> to define any radix between 2 and 36.</td></tr>
<tr valign="TOP">
<td>Example C/C++</td><td><font face="courier new">VF_nread( 3, 100, DataFile, X, Y, Z );</font></td></tr>
<tr valign="TOP">
<td>Description Pascal/Delphi</td><td>n columns of a table are read into the vectors passed as the list VecList to <I>VF_nread</I>. The number of lines is specified as the number of elements of each vector, which is size.
<P>The entries of each line should be separated by spaces (' ') or tab characters (#9). Other separators are not allowed. Each line must be terminated by a line-feed character (#13).
<P>It is possible to read fewer vectors than there are columns in a table. In this case, the trailing columns are neglected. If, however, you try to read more vectors than there are columns, the result is undefined and might lead to an error.
<P>Complex versions (both cartesian and polar):
<BR>Real und imaginary (or Mag and Arg) parts may (but need not) be enclosed in braces { }. However, you must be consequent: Either all or no element may be written with braces.
<P>Whereas the C version of these functions follows the conventions of the C functions <I>strtod,&nbsp;&nbsp; strtol</I>, etc., the Pascal version has to follow the rules applying to the Pascal function <I>Read</I>. This makes the Pascal version much less flexible than the C version:
<BR>- no separation characters allowed other than ' ' and #9,
<BR>- no automatic truncation of overflowing numbers,
<BR>- no function <I><a href="#setRadix">V_setRadix</a></I></td></tr>
<tr valign="TOP">
<td>Example Pascal/Delphi</td><td><font face="courier new">var MyFile: Text;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;X, Y1, Y2: fVector;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;VList: array[0..2] of fVector;
<BR>begin
<BR>&nbsp;&nbsp;&nbsp;&nbsp;X := <a href="#vector">VF_vector</a>( 100 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Y1 := VF_vector( 100 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Y2 := VF_vector( 100 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;VList[0] := X; VList[1] := Y1; VList[2] := Y2;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Assign( MyFile, 'Myfile.DAT' );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Reset( MyFile );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;VF_nread( @VList, 3, 100, MyFile );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;...
<BR>end;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td><u>C/C++:</u>
<BR>Real, complex and quad versions:
<BR>Overflowing numbers are silently truncated to &#177;HUGE_VAL.
<BR>Whole-number versions except <I>VQI_nread</I>:
<BR>As long as the numbers can be represented as long or unsigned long, overflowing bits are ignored in the 16-bit versions.
<BR>Numbers beyond the long range yield -1 (signed types) or +HUGE_VAL (unsigned types).
<BR><u>Pascal/Delphi:</u>
<BR>Overflowing numbers or numbers otherwise not conforming to the format requirements lead to an I/O error.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#nwrite">VF_nwrite</a>,&nbsp;&nbsp; <a href="#read">VF_read</a>,&nbsp;&nbsp; <a href="#store">VF_store</a>,&nbsp;&nbsp; <a href="#recall">VF_recall</a></I>, strtod,&nbsp;&nbsp;strtol (C/C++ only)</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="nwrite"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_nwrite</b></font></td><td width="33%"><font size="+1"><b>VD_nwrite</b></font></td><td><font size="+1"><b>VE_nwrite</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_nwrite</b></font></td><td width="33%"><font size="+1"><b>VCD_nwrite</b></font></td><td><font size="+1"><b>VCE_nwrite</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_nwrite</b></font></td><td width="33%"><font size="+1"><b>VPD_nwrite</b></font></td><td><font size="+1"><b>VPE_nwrite</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_nwrite</b></font></td><td width="20%"><font size="+1"><b>VBI_nwrite</b></font></td><td width="20%"><font size="+1"><b>VSI_nwrite</b></font></td><td width="20%"><font size="+1"><b>VLI_nwrite</b></font></td><td><font size="+1"><b>VQI_nwrite</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_nwrite</b></font></td><td width="20%"><font size="+1"><b>VUB_nwrite</b></font></td><td width="20%"><font size="+1"><b>VUS_nwrite</b></font></td><td width="20%"><font size="+1"><b>VUL_nwrite</b></font></td><td><font size="+1"><b>VUI_nwrite</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Write vectors as the columns of a table into a stream.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_nwrite( FILE *stream, unsigned n, ui size, ... );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_nwrite( var stream:Text; VecList:^fVector; n:UInt; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description C/C++</td><td>n vectors are written in ASCII format as the columns of a table into stream. The number of lines is given by the number of elements of each vector: size.
<P>The default format and separation may be changed using <I><a href="#setWriteFormat">VF_setWriteFormat</a></I> and <I><a href="#setNWriteSeparate">VF_setNWriteSeparate</a></I>, respectively.</td></tr>
<tr valign="TOP">
<td>Example C/C++</td><td><font face="courier new">VF_nwrite( DataFile, 3, 100, X, Y, Z );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* generates a table with 3 columns and 100 lines;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the columns are given by X, Y and Z. */</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td>n vectors, passed as the list VecList, are written in ASCII format as the columns of a table into stream. The number of lines is given by the number of elements of each vector: size.
<P>The separation character(s) between columns may be changed using <I><a href="#setNWriteSeparate">VF_setNWriteSeparate</a></I>. By default, it is a tab character (#9).
<P>Please note that the Pascal version of these functions does not allow a free definition of the output format. Therefore, the function <I><a href="#setWriteFormat">VF_setWriteFormat</a></I> does not exist in the Pascal/Delphi version.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#write">VF_write</a>,&nbsp;&nbsp; <a href="#nread">VF_nread</a>,&nbsp;&nbsp; <a href="#store">VF_store</a>,&nbsp;&nbsp; <a href="#recall">VF_recall</a>,&nbsp;&nbsp; fprintf</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="OD"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_OD</b></font></td><td width="33%"><font size="+1"><b>VD_OD</b></font></td><td><font size="+1"><b>VE_OD</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_ODtoF</b></font></td><td width="33%"><font size="+1"><b>VU_ODtoD</b></font></td><td><font size="+1"><b>VU_ODtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUB_ODtoF</b></font></td><td width="33%"><font size="+1"><b>VUB_ODtoD</b></font></td><td><font size="+1"><b>VUB_ODtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUS_ODtoF</b></font></td><td width="33%"><font size="+1"><b>VUS_ODtoD</b></font></td><td><font size="+1"><b>VUS_ODtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_ODtoF</b></font></td><td width="33%"><font size="+1"><b>VUL_ODtoD</b></font></td><td><font size="+1"><b>VUL_ODtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUI_ODtoF</b></font></td><td width="33%"><font size="+1"><b>VUI_ODtoD</b></font></td><td><font size="+1"><b>VUI_ODtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VQI_ODtoF</b></font></td><td width="33%"><font size="+1"><b>VQI_ODtoD</b></font></td><td><font size="+1"><b>VQI_ODtoE</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Optical Density</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_OD( fVector OD, fVector X, fVector X0, ui size );
<BR>int VUS_ODtoF( fVector OD, usVector X, usVector X0, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::OD( const vector&lt;T&gt;& X, const vector&lt;T&gt;& X0 );
<BR>int vector&lt;flot&gt;::ODtoF( const vector&lt;unsigned&gt;& X, const vector&lt;unsigned&gt;& X0 );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_OD( OD, X, X0:fVector; size:UInt ): IntBool;
<BR>function VUS_ODtoF( OD:fVector; X, X0:usVector; size:UInt ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>OD<sub>i</sub> = log10( X0<sub>i</sub>/X<sub>i</sub> ) for (X0<sub>i</sub> &gt;= ODThresh0 && X<sub>i</sub> &gt;= ODThresh),
<BR>OD<sub>i</sub> = 0.0 otherwise
<BR>The &quot;optical density&quot; is calculated for positive, non-zero input numbers. By default, ODThresh and ODThresh0 are 0.001 for the versions with floating-point input vectors (<I>VF_OD,&nbsp;&nbsp; VD_OD</I>, and <I>VE_OD</I>), and 1 for the versions with unsigned-integer input vectors.
<BR>The typical application of these functions would be an absorption measurement with a spectrometer, where each element of X corresponds to the light intensity at one specific wavelength, transmitted through the sample, and each element of X0 corresponds to the light intensity measured through air or through a reference sample. Normally, the intensity data will have been digitized with 12-bit or 16-bit precision. In this case, <I>VUS_ODtoF</I> or <I>VUS_ODtoD</I> will be the appropriate functions. For the rare cases of 8-bit or higher than 16-bit digitization, use the <I>VUB_</I> or <I>VUL_</I> versions.
<BR>You might wish to accumulate several measurements before calculating the OD. For example, repeated measurements in a usVector may be accumulated into a ulVector by <I><a href="#accV">VUL_accVUS</a></I>, before the OD is calculated by <I>VUL_ODtoD</I>. Similarly, you might accumulate 32-bit data into a qiVector by <I><a href="#accV">VQI_accVUL</a></I> and call then, e.g., <I>VQI_ODtoE</I>.
<P>In order to cut off experimental noise, the input-number threshold below which the OD is corrected to 0.0 may be set to arbitrary positive values by <I><a href="#setODThresh">VF_setODThresh</a>,&nbsp;&nbsp; <a href="#setODThresh">VUS_setODThresh</a></I>, etc.
<P>If background values have to be taken into account, please use the functions of the <I><a href="#ODwDark">VF_ODwDark</a></I> family.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ODwDark">VF_ODwDark</a>,&nbsp;&nbsp; <a href="#log10">VF_log10</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ODwDark"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ODwDark</b></font></td><td width="33%"><font size="+1"><b>VD_ODwDark</b></font></td><td><font size="+1"><b>VE_ODwDark</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_ODtoFwDark</b></font></td><td width="33%"><font size="+1"><b>VU_ODtoDwDark</b></font></td><td><font size="+1"><b>VU_ODtoEwDark</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUB_ODtoFwDark</b></font></td><td width="33%"><font size="+1"><b>VUB_ODtoDwDark</b></font></td><td><font size="+1"><b>VUB_ODtoEwDark</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUS_ODtoFwDark</b></font></td><td width="33%"><font size="+1"><b>VUS_ODtoDwDark</b></font></td><td><font size="+1"><b>VUS_ODtoEwDark</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_ODtoFwDark</b></font></td><td width="33%"><font size="+1"><b>VUL_ODtoDwDark</b></font></td><td><font size="+1"><b>VUL_ODtoEwDark</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUI_ODtoFwDark</b></font></td><td width="33%"><font size="+1"><b>VUI_ODtoDwDark</b></font></td><td><font size="+1"><b>VUI_ODtoEwDark</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VQI_ODtoFwDark</b></font></td><td width="33%"><font size="+1"><b>VQI_ODtoDwDark</b></font></td><td><font size="+1"><b>VQI_ODtoEwDark</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Optical Density with background subtraction</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_ODwDark( fVector OD, fVector X, fVector XDark, fVector X0, fVector X0Dark, ui size );
<BR>int VUS_ODtoFwDark( fVector OD, usVector X, usVector XDark, usVector X0, usVector X0Dark, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::ODwDark( const vector&lt;T&gt;& X, const vector&lt;T&gt;& XDark, const vector&lt;T&gt;& X0, const vector&lt;T&gt;& X0Dark );
<BR>int vector&lt;float&gt;::ODtoFwDark( const vector&lt;unsigned&gt;& X, const vector&lt;unsigned&gt;& XDark, const vector&lt;unsigned&gt;& X0, const vector&lt;unsigned&gt;& X0Dark );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_ODwDark( OD, X, XDark, X0, X0Dark:fVector; size:UInt ): IntBool;
<BR>function VUS_ODtoFwDark( OD:fVector; X, XDark, X0, X0Dark:usVector; size:UInt ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>xx<sub>i</sub> = X<sub>i</sub> - X<sub>i</sub>Dark
<BR>x0<sub>i</sub> = X0<sub>i</sub> - X0<sub>i</sub>Dark
<BR>OD<sub>i</sub> = log10( x0<sub>i</sub>/xx<sub>i</sub> ),&nbsp;&nbsp;(x0<sub>i</sub> &gt;= ODThresh0 && xx<sub>i</sub> &gt;= ODThresh),
<BR>OD<sub>i</sub> = 0.0&nbsp;&nbsp;otherwise
<P>Dark currents XDark, X0Dark are subtracted from measured intensity data X, X0. The optical density is calculated for the resulting corrected data. If these happen to become negative or at least smaller than the thresholds ODThresh, ODThresh0, the OD is set to 0.0.
<P>In order to cut off experimental noise, these thresholds may be set to arbitrary positive values by <I><a href="#setODThresh">VF_setODThresh</a>,&nbsp;&nbsp; <a href="#setODThresh">VU_setODThresh</a></I>, etc.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#OD">VF_OD</a>,&nbsp;&nbsp; <a href="#setODThresh">VF_setODThresh</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="or"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_or</b></font></td><td width="20%"><font size="+1"><b>VBI_or</b></font></td><td width="20%"><font size="+1"><b>VSI_or</b></font></td><td width="20%"><font size="+1"><b>VLI_or</b></font></td><td><font size="+1"><b>VQI_or</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_or</b></font></td><td width="20%"><font size="+1"><b>VUB_or</b></font></td><td width="20%"><font size="+1"><b>VUS_or</b></font></td><td width="20%"><font size="+1"><b>VUL_or</b></font></td><td><font size="+1"><b>VUI_or</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Bit-wise &quot;OR&quot; operation</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VImath.h&gt;
<BR>void VI_or( iVector Y, iVector X, ui size, int C);
<BR>void VUL_or( ulVector Y, ulVector X, ui size, unsigned long C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::or( const vector&lt;T&gt;& X, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VImath;
<BR>procedure VI_or( Y, X:iVector; size:UInt; C:Integer );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = (X<sub>i</sub>) | C
<BR>The bit-wise &quot;inclusive OR&quot; operation is performed on each element X<sub>i</sub> with the bit-mask given by C. A bit is 1 in Y<sub>i</sub>, if it was not simultaneously 0 in X<sub>i</sub> and in C, i.e., if it was 1 at least in one of them.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#not">VI_not</a>,&nbsp;&nbsp; <a href="#and">VI_and</a>,&nbsp;&nbsp; <a href="#xor">VI_xor</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="Parzen"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_Parzen</b></font></td><td width="33%"><font size="+1"><b>VD_Parzen</b></font></td><td><font size="+1"><b>VE_Parzen</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;Parzen&quot; window for spectral analyses</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_Parzen( fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::Parzen();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_Parzen( X:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X<sub>i</sub> = 1 - |(i - 0.5*(size - 1)) / 0.5*(size + 1)|</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#Welch">VF_Welch</a>,&nbsp;&nbsp; <a href="#Hanning">VF_Hanning</a>,&nbsp;&nbsp; <a href="#spectrum">VF_spectrum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="Pelement"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_Pelement</b></font></td><td width="33%"><font size="+1"><b>VD_Pelement</b></font></td><td><font size="+1"><b>VE_Pelement</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_Pelement</b></font></td><td width="33%"><font size="+1"><b>VCD_Pelement</b></font></td><td><font size="+1"><b>VCE_Pelement</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_Pelement</b></font></td><td width="20%"><font size="+1"><b>VBI_Pelement</b></font></td><td width="20%"><font size="+1"><b>VSI_Pelement</b></font></td><td width="20%"><font size="+1"><b>VLI_Pelement</b></font></td><td><font size="+1"><b>VQI_Pelement</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_Pelement</b></font></td><td width="20%"><font size="+1"><b>VUB_Pelement</b></font></td><td width="20%"><font size="+1"><b>VUS_Pelement</b></font></td><td width="20%"><font size="+1"><b>VUL_Pelement</b></font></td><td><font size="+1"><b>VUI_Pelement</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Pointer to a vector element</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>(float *) VF_Pelement( fVector X, ui pos );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T * vector&lt;T&gt;::Pelement( ui pos );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_Pelement( X:fVector; pos:UInt ): PSingle;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><u>C/C++:</u><BR>returns X+pos = &( X[pos] ). This function is needed only for some older versions of Borland C, to avoid a bug in the pointer arithmetics.
<BR><u>Pascal/Delphi:</u>
<BR>returns @( X[pos] ). This function is needed to access single vector elements, or to perform pointer arithmetics on dynamically allocated vectors, for which Pascal/Delphi - unlike C - does not provide a built-in mechanism.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>C/C++:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X+pos
<BR>Pascal/Delphi: @( X[pos] )</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#element">VF_element</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="PDtoPF"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_PDtoPF</b></font></td><td><font size="+1"><b>V_PDtoPE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_PEtoPF</b></font></td><td><font size="+1"><b>V_PEtoPD</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_PFtoPD</b></font></td><td><font size="+1"><b>V_PFtoPE</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Data type conversions. See <I><a href="#FtoD">V_FtoD</a></I>.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="polar"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_polar</b></font></td><td width="33%"><font size="+1"><b>VCD_polar</b></font></td><td><font size="+1"><b>VCE_polar</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_polar</b></font></td><td width="33%"><font size="+1"><b>VPD_polar</b></font></td><td><font size="+1"><b>VPE_polar</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Construct a Cartesian or polar complex vector from polar coordinates given as separate vectors.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd&gt;
<BR>void VCF_polar( cfVector X, fVector Mag, fVector Arg, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;complex&lt;T&gt;&gt;::polar( const vector&lt;T&gt;& Mag, const vector&lt;T&gt;& Arg );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VCF_polar( X:cfVector; Mag, Arg:fVector; size:UInt);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Identical to <I><a href="#PolartoC">VF_PolartoC</a></I> etc. and <I><a href="#MagArgtoP">VF_MagArgtoP</a></I>, resp. See these functions for details.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="PolartoC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_PolartoC</b></font></td><td width="33%"><font size="+1"><b>VD_PolartoC</b></font></td><td><font size="+1"><b>VE_PolartoC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Construct Cartesian complex numbers from polar coordinates, entered as separate vectors for Mag and Arg.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_PolartoC( cfVector X, fVector Mag, fVector Arg, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;complex&lt;T&gt;&gt;::PolartoC( const vector&lt;T&gt;& Mag, const vector&lt;T&gt;& Arg );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_PolartoC( X:cfVector; Mag, Arg:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The polar coordinates Mag (magnitude, absolute value) and Arg (argument, angle) of each element are used to construct the Cartesian complex vector X.
<BR>The difference between this function and <I><a href="#PtoC">VF_PtoC</a></I> is that, in the latter, the input consists of one vector of type pfVector, rather than of two real-valued vectors for Mag and Arg.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>The total loss of precision for very large values of Arg is treated tacitly (without an error message); if it occurs, the result is set to {Mag, 0}.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PtoC">VF_PtoC</a>,&nbsp;&nbsp; <a href="#CtoPolar">VF_CtoPolar</a>,&nbsp;&nbsp; <a href="#ReImtoC">VF_ReImtoC</a>,&nbsp;&nbsp; <a href="#CtoArg">VF_CtoArg</a>,&nbsp;&nbsp; <a href="#CtoNorm">VF_CtoNorm</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="poly"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_poly</b></font></td><td width="33%"><font size="+1"><b>VD_poly</b></font></td><td><font size="+1"><b>VE_poly</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_poly</b></font></td><td width="33%"><font size="+1"><b>VDx_poly</b></font></td><td><font size="+1"><b>VEx_poly</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Polynomial</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_poly( fVector Y, fVector X, ui size, fVector Coeff, unsigned deg );
<BR>int VFx_poly( fVector Y, fVector X, ui size, fVector Coeff, unsigned deg, float A, float B );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::poly( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Coeff, unsigned deg );
<BR>int vector&lt;T&gt;::x_poly( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Coeff, unsigned deg, T A, T B );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_poly( Y, X:fVector; size:UInt; Coeff:fVector; deg:UInt ): IntBool;
<BR>function VFx_poly( Y, X:fVector; size:UInt; Coeff:fVector; deg:UInt; A, B:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions:
<BR>Y<sub>i</sub> = c<sub>0</sub> + c<sub>1</sub> * X<sub>i</sub> + c<sub>2</sub> * X<sub>i</sub><sup>2</sup> + ... + c<sub>n</sub> * X<sub>i</sub><sup>n</sup>
<BR>expanded versions:
<BR>xi = (A*X<sub>i</sub> + B),
<BR>Y<sub>i</sub> = c<sub>0</sub> + c<sub>1</sub> * xi + c<sub>2</sub> * xi<sup>2</sup> + ... + c<sub>n</sub> * xi<sup>n</sup>
<P>A polynomial of degree <I>deg</I> is generated for every element of X, using the coefficients contained in the vector Coeff. The coefficients in Coeff have to be ordered in such a way that the constant term is the zero'th element, the linear coefficient the first element etc., up to the <I>deg</I>'th element which is the coefficient for the highest power used in the polynomial. (Beware a frequent source of errors: for a polynomial of <I>deg</I> = 4, there are 5 (!) coefficients; do not forget the constant term).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to &#177;HUGE_VAL as the default result. In contrast to the ANSI C function <I>poly</I> (where <I>deg</I> is declared as int), the declaration of <I>deg</I> as unsigned precludes DOMAIN errors (which would occur for negative <I>deg</I>).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ipow">VF_ipow</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; poly</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="polyinterpol"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_polyinterpol</b></font></td><td width="33%"><font size="+1"><b>VD_polyinterpol</b></font></td><td><font size="+1"><b>VE_polyinterpol</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Polynomial interpolation of X-Y-table values</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_polyinterpol( fVector Y, fVector X, ui sizex, fVector XTab, fVector YTab, ui sizetab, unsigned deg );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::polyinterpol( const vector&lt;T&gt;& X, const vector&lt;T&gt;& XTab, const vector&lt;T&gt;& YTab, unsigned deg );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_polyinterpol( Y, X:fVector; sizex:UInt; XTab, YTab:fVector; sizetab:UInt; deg:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>For each of the sizex elements of X, the corresponding element of Y is interpolated from the XTab-YTab value pairs. XTab must be ordered (either ascending or descending). All values of XTab must be distinct; otherwise a division by zero may occur and lead to a program abort. For each element of X, the routine finds itself the appropriate place in the table. The parameter deg denotes the number of points that will be taken into account for the interpolation (this is not the degree of the interpolating polynomial!). Any value between 0 and 2 will be interpreted as meaning linear interpolation. A maximum of 10-point interpolation is possible.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Trying to use too many elements for the interpolation (deg &gt; 10) leads to an error message &quot;Not possible with more than 10 elements&quot; and to a program abort. If deg exceeds sizetab, an error message &quot;Invalid parameter(s)&quot; is displayed and the program aborted.
<BR>No other errors are detected (you have to take care yourself that the XTab values are distinct and that the YTab values are not near the limit of overflowing).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ratinterpol">VF_ratinterpol</a>,&nbsp;&nbsp; <a href="#splineinterpol">VF_splineinterpol</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="pow"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_pow</b></font></td><td width="33%"><font size="+1"><b>VD_pow</b></font></td><td><font size="+1"><b>VE_pow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_pow</b></font></td><td width="33%"><font size="+1"><b>VCD_pow</b></font></td><td><font size="+1"><b>VCE_pow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_pow</b></font></td><td width="33%"><font size="+1"><b>VDx_pow</b></font></td><td><font size="+1"><b>VEx_pow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_pow</b></font></td><td width="33%"><font size="+1"><b>VCDx_pow</b></font></td><td><font size="+1"><b>VCEx_pow</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_powReExpo</b></font></td><td width="33%"><font size="+1"><b>VCD_powReExpo</b></font></td><td><font size="+1"><b>VCE_powReExpo</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_powReExpo</b></font></td><td width="33%"><font size="+1"><b>VCDx_powReExpo</b></font></td><td><font size="+1"><b>VCEx_powReExpo</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_powReExpo</b></font></td><td width="33%"><font size="+1"><b>VPD_powReExpo</b></font></td><td><font size="+1"><b>VPE_powReExpo</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Raise each element of a vector to a specified power</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_pow( fVector Y, fVector X, ui size, float Expo );
<BR>int VFx_pow( fVector Y, fVector X, ui size, float Expo, float A, float B, float C );
<BR>int VCF_pow( cfVector Y, cfVector X, ui size, fComplex Expo );
<BR>int VCFx_pow( cfVector Y, cfVector X, ui size, fComplex Expo, fComplex A, fComplex B, fComplex C );
<BR>int VCF_powReExpo( cfVector Y, cfVector X, ui size, float Expo );
<BR>int VCFx_powReExpo( cfVector Y, cfVector X, ui size, float Expo, fComplex A, fComplex B, fComplex C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::pow( const vector&lt;T&gt;& X, T Expo );
<BR>int vector&lt;T&gt;::x_pow( const vector&lt;T&gt;& X, T Expo, T A, T B, T C );
<BR>int vector&lt;complex&lt;T&gt;&gt;::pow( const vector&lt;complex&lt;T&gt;&gt;& X, complex&lt;T&gt; Expo );
<BR>int vector&lt;complex&lt;T&gt;&gt;::x_pow( const vector&lt;complex&lt;T&gt;&gt;& X, complex&lt;T&gt; Expo, complex&lt;T&gt; A, complex&lt;T&gt; B, complex&lt;T&gt; C );
<BR>int vector&lt;complex&lt;T&gt;&gt;::powReExpo( const vector&lt;complex&lt;T&gt;&gt;& X, T Expo );
<BR>int vector&lt;complex&lt;T&gt;&gt;::x_powReExpo( const vector&lt;complex&lt;T&gt;&gt;& X, T Expo, complex&lt;T&gt; A, complex&lt;T&gt; B, complex&lt;T&gt; C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_pow( Y, X:fVector; size:UInt; Expo:Single ): IntBool;
<BR>function VFx_pow( Y, X:fVector; size:UInt; Expo, A, B, C:Single ): IntBool;
<BR>function VCF_pow( Y, X:cfVector; size:UInt; Expo:fComplex ): IntBool;
<BR>function VCF_powReExpo( Y, X:cfVector; size:UInt; Expo:Single ): IntBool;
<BR>function VCFx_powReExpo( Y, X:cfVector; size:UInt; Expo:Single; A, B, C:fComplex ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = X<sub>i</sub> <sup>Expo</sup>
<BR>expanded versions: Y<sub>i</sub> = C * ((A*X<sub>i</sub>+B) <sup>Expo</sup>)
<BR>If Expo is a moderately small integer number, the functions of this family pass the job to the appropriate routine of the <I><a href="#ipow">VF_ipow</a></I> family. More efficiently, the user could do just that himself.
<BR>The complex version exists in two variants: one for complex exponents, the other for complex numbers raised to a real exponent.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>DOMAIN errors occur, if negative numbers are raised to fractional powers; the default result is NAN (&quot;not-a-number&quot;). SING errors occur, if zero is raised to a negative power; the default result is &#177;HUGE_VAL, which is true for OVERFLOW errors as well.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ipow">VF_ipow</a>,&nbsp;&nbsp; <a href="#poly">VF_poly</a>,&nbsp;&nbsp; <a href="#pow2">VF_pow2</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; pow</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="pow10"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_pow10</b></font></td><td width="33%"><font size="+1"><b>VD_pow10</b></font></td><td><font size="+1"><b>VE_pow10</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_pow10</b></font></td><td width="33%"><font size="+1"><b>VDx_pow10</b></font></td><td><font size="+1"><b>VEx_pow10</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Real powers of 10</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_pow10( fVector Y, fVector X, ui size );
<BR>int VFx_pow10( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::pow10( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_pow10( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_pow10( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_pow10( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = 10.0 <sup>X</sup><font size="-1">i</font>
<BR>expanded versions: Y<sub>i</sub> = C * 10.0<sup>A*X</sup><font size="-1">i</font><sup>+B</sup>
<BR>This is an exponential function to the basis of 10.0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ipow10">VF_ipow10</a>,&nbsp;&nbsp; <a href="#scale10">VF_scale10</a>,&nbsp;&nbsp; <a href="#log10">VF_log10</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; pow10</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="pow2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_pow2</b></font></td><td width="33%"><font size="+1"><b>VD_pow2</b></font></td><td><font size="+1"><b>VE_pow2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_pow2</b></font></td><td width="33%"><font size="+1"><b>VDx_pow2</b></font></td><td><font size="+1"><b>VEx_pow2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Real powers of 2</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_pow2( fVector Y, fVector X, ui size );
<BR>int VFx_pow2( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::pow2( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_pow2( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_pow2( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_pow2( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = 2.0 <sup>X</sup><font size="-1">i</font>
<BR>expanded versions: Y<sub>i</sub> = C * 2.0<sup>A*X</sup><font size="-1">i</font><sup>+B</sup>
<BR>This is an exponential function to the basis of 2.0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ipow2">VF_ipow2</a>,&nbsp;&nbsp; <a href="#scale2">VF_scale2</a>,&nbsp;&nbsp; <a href="#log2">VF_log2</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; pow</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="principal"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_principal</b></font></td><td width="33%"><font size="+1"><b>VPD_principal</b></font></td><td><font size="+1"><b>VPE_principal</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Reduce polar complex numbers to principal value</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VPF_principal( pfVector Y, pfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;polar&lt;T&gt;&gt;::principal( const vector&lt;polar&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VPF_principal( Y, X:pfVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The argument, i.e. the angle of each element is reduced to the range -<font face="symbol">p</font> &lt; Arg &lt;= +<font face="symbol">p</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#MagArgtoPrincipal">VF_MagArgtoPrincipal</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="print"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_print</b></font></td><td width="33%"><font size="+1"><b>VD_print</b></font></td><td><font size="+1"><b>VE_print</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_print</b></font></td><td width="33%"><font size="+1"><b>VCD_print</b></font></td><td><font size="+1"><b>VCE_print</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_print</b></font></td><td width="20%"><font size="+1"><b>VBI_print</b></font></td><td width="20%"><font size="+1"><b>VSI_print</b></font></td><td width="20%"><font size="+1"><b>VLI_print</b></font></td><td><font size="+1"><b>VQI_print</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_print</b></font></td><td width="20%"><font size="+1"><b>VUB_print</b></font></td><td width="20%"><font size="+1"><b>VUS_print</b></font></td><td width="20%"><font size="+1"><b>VUL_print</b></font></td><td><font size="+1"><b>VUI_print</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Print a vector as ASCII numbers to <I>stdout</I>, assuming a linewidth of 80 characters.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_print( fVector X, ui size, unsigned nperline );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::print( unsigned nperline );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_print( X:fVector; size, nperline:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>size elements of X are printed to stdout, nperline in each line. The available linewidth is assumed to be 80 characters. Each line begins with the index of the first element printed into that line. The index is followed by a colon and by the requested nperline elements.
<P>Cartesian complex numbers are printed in braces, with the real and imaginary parts separated by a komma: {Re, Im}. Polar complex numbers are also written in braces, with the Mag and Arg parts separated by an at-sign: {Mag @ Arg}.
<P>In contrast to <I><a href="#cprint">VF_cprint</a></I>, no paging is performed.
<BR>The number of digits per element is determined by the available space, which depends in turn on nperline.
<P>This family of functions is available under Windows only in connection with EasyWin, and should not be used within TurboVision programs.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If nperline exceeds the maximum number of entries possible within 80 characters, an error message &quot;Cannot use requested format (too many entries per line)&quot; is generated; in this case, the program chooses the maximum number nperline possible.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cprint">VF_cprint</a>,&nbsp;&nbsp; <a href="#fprint">VF_fprint</a>,&nbsp;&nbsp; <a href="#write">VF_write</a>,&nbsp;&nbsp; <a href="#store">VF_store</a>,&nbsp;&nbsp; printf</I> (C/C++ only)</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="printErrorMsg"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_printErrorMsg</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Print an error message.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>void V_printErrorMsg( char *ErrMsg );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>procedure V_printErrMsg( ErrMsg: PChar );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>As described in connection with <I><a href="#noteError">V_noteError</a></I>, this function is in charge of printing error messages. By default, output is directed to the screen. The function <I><a href="#setErrorEventFile">V_setErrorEventFile</a></I> may be used to redirect the output into an event file (exclusively or in addition to the screen message). <I>V_printErrorMsg</I> may be called from user-defined routines in which error conditions are detected. If the message is longer than one line, carriage returns (&quot;\n&quot; or &quot;\r\n&quot; for C/C++, #13 for Pascal/Delphi) have to be included at the desired place. Note, however, that this function will not be included in versions of <I>OptiVec</I> for compilers that do already offer the possibility of printing error messages simultaneously to the screen and to an event file.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#setErrorEventFile">V_setErrorEventFile</a>,&nbsp;&nbsp; <a href="#noteError">V_noteError</a>,&nbsp;&nbsp; _matherr</I> (C/C++ only)</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="prod"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_prod</b></font></td><td width="33%"><font size="+1"><b>VD_prod</b></font></td><td><font size="+1"><b>VE_prod</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_prod</b></font></td><td width="33%"><font size="+1"><b>VCD_prod</b></font></td><td><font size="+1"><b>VCE_prod</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_prod</b></font></td><td width="33%"><font size="+1"><b>VPD_prod</b></font></td><td><font size="+1"><b>VPE_prod</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Calculates the product of all the elements of a vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_prod( fVector X, ui size );
<BR>fComplex VCF_prod( cfVector X, ui size );
<BR>fPolar VPF_prod( pfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::prod();
<BR>complex&lt;T&gt; vector&lt;complex&lt;T&gt;&gt;::prod();
<BR>polar&lt;T&gt; vector&lt;polar&lt;T&gt;&gt;::prod();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_prod( X:fVector; size:UInt ): Single;
<BR>procedure VCF_prod( var Prod:fComplex; X:cfVector; size:UInt);
<BR>procedure VPF_prod( var Prod:fPolar; X:pfVector; size:UInt);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The product of all elements of a vector is calculated.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none (but be careful: this function may easily overflow!)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>the product of the vector elements (except complex versions in Pascal/Delphi)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#runprod">VF_runprod</a>,&nbsp;&nbsp; <a href="#sum">VF_sum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="PtoAbs"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_PtoAbs</b></font></td><td width="33%"><font size="+1"><b>VD_PtoAbs</b></font></td><td><font size="+1"><b>VE_PtoAbs</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Absolute value (magnitude) of polar complex numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_PtoAbs( fVector Abs, pfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::PtoAbs( const vector&lt;polar&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_PtoAbs( Abs:fVector; X:pfVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The absolute value, i.e. the magnitude of each element of the polar complex vector X is extracted. This function is identical to <I><a href="#abs">VPF_abs</a></I> and <I><a href="#PtoMag">VF_PtoMag</a></I>. For historical reasons, all three names have been preserved.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#abs">VPF_abs</a>,&nbsp;&nbsp; <a href="#PtoMagArg">VF_PtoMagArg</a>,&nbsp;&nbsp; <a href="#PtoArg">VF_PtoArg</a>,&nbsp;&nbsp; <a href="#PtoNorm">VF_PtoNorm</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="PtoArg"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_PtoArg</b></font></td><td width="33%"><font size="+1"><b>VD_PtoArg</b></font></td><td><font size="+1"><b>VE_PtoArg</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Argument (angle) of complex numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_PtoArg( fVector Arg, pfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::PtoArg( const vector&lt;polar&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_PtoArg( Arg:fVector; X:pfVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The argument, i.e. the angle of each element is extracted from the polar complex vector X. In contrast to the analogous function for cartesian complex vectors, <I><a href="#CtoArg">VF_CtoArg</a></I>, no normalization of the argument is performed. If the normalized argument is needed, <I><a href="#principal">VPF_principal</a></I> must be called first.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PtoAbs">VF_PtoAbs</a>,&nbsp;&nbsp; <a href="#PtoMagArg">VF_PtoMagArg</a>,&nbsp;&nbsp; <a href="#PtoReIm">VF_PtoReIm</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="PtoC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_PtoC</b></font></td><td width="33%"><font size="+1"><b>VD_PtoC</b></font></td><td><font size="+1"><b>VE_PtoC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Transformation of a polar complex into a cartesian complex vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_PtoC( cfVector Y, pfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;complex&lt;T&gt;&gt;::PtoC( const vector&lt;polar&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_PtoC( Y:cfVector; X:pfVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X is transformed from polar coordinates {Mag @ Arg} into cartesian coordinates {Re, Im}.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#CtoP">VF_CtoP</a>,&nbsp;&nbsp; <a href="#PtoReIm">VF_PtoReIm</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="PtoIm"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_PtoIm</b></font></td><td width="33%"><font size="+1"><b>VD_PtoIm</b></font></td><td><font size="+1"><b>VE_PtoIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Extract the imaginary part from a polar complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_PtoIm( fVector Im, pfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::PtoIm( const vector&lt;polar&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_PtoIm( Im:fVector; X:pfVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The imaginary part of the polar complex vector X is calculated and stored in Im.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PtoReIm">VF_PtoReIm</a>,&nbsp;&nbsp; <a href="#ReImtoP">VF_ReImtoP</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="PtoMag"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_PtoMag</b></font></td><td width="33%"><font size="+1"><b>VD_PtoMag</b></font></td><td><font size="+1"><b>VE_PtoMag</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Extract the magnitudes of complex numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_PtoMag( fVector Mag, pfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::PtoMag( const vector&lt;polar&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_PtoMag( Mag:fVector; X:pfVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The magnitude of each element is extracted from the polar complex vector X.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PtoArg">VF_PtoArg</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="PtoMagArg"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_PtoMagArg</b></font></td><td width="33%"><font size="+1"><b>VD_PtoMagArg</b></font></td><td><font size="+1"><b>VE_PtoMagArg</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Split a polar complex vector into separate vectors for magnitude and argument.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_PtoMagArg( fVector Mag, fVector Arg, pfVector X, ui size);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::PtoMagArg( vector&lt;T&gt; Arg, const vector&lt;polar&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_PtoMagArg( Mag, Arg:fVector; X:pfVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Magnitude and argument of the polar complex vector X are stored in the separate vectors Mag and Arg.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PtoRe">VF_PtoRe</a>,&nbsp;&nbsp; <a href="#MagArgtoP">VF_MagArgtoP</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="PtoNorm"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_PtoNorm</b></font></td><td width="33%"><font size="+1"><b>VD_PtoNorm</b></font></td><td><font size="+1"><b>VE_PtoNorm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Norm (square of the absolute value) of complex numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_PtoNorm( fVector Norm, pfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::PtoNorm( const vector&lt;polar&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_PtoNorm( Norm:fVector; X:pfVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Norm<sub>i</sub> = Mag<sup>2</sup>(X<sub>i</sub>)
<BR>This definition of the Norm of a complex number is the same as in C++, but it is not consistent with the usual definition in mathematics, where the term &quot;norm&quot; is used as a synomym for &quot;absolute value&quot; or &quot;magnitude&quot;. As defined here, the Norm is the square of the absolute value. The absolute value itself is available by the function <I><a href="#abs">VPF_abs</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PtoReIm">VF_PtoReIm</a>,&nbsp;&nbsp; <a href="#abs">VPF_abs</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="PtoRe"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_PtoRe</b></font></td><td width="33%"><font size="+1"><b>VD_PtoRe</b></font></td><td><font size="+1"><b>VE_PtoRe</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Extracts the real part from a polar complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_PtoRe( fVector Re, pfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::PtoRe( const vector&lt;polar&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_PtoRe( Re:fVector; X:pfVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The real part of the polar complex vector X is calculated and stored in Re.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PtoReIm">VF_PtoReIm</a>,&nbsp;&nbsp; <a href="#PtoIm">VF_PtoIm</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="PtoReIm"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_PtoReIm</b></font></td><td width="33%"><font size="+1"><b>VD_PtoReIm</b></font></td><td><font size="+1"><b>VE_PtoReIm</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Real and imaginary parts of a polar complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_PtoReIm( fVector Re, fVector Im, pfVector X, ui size);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::PtoReIm( vector&lt;T&gt; Im, const vector&lt;polar&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_PtoReIm( Re, Im:fVector; X:pfVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The polar complex vector X is transformed into cartesian coordinates, which are stored in separate vectors Re and Im.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PtoRe">VF_PtoRe</a>,&nbsp;&nbsp; <a href="#ReImtoP">VF_ReImtoP</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="quartic"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_quartic</b></font></td><td width="33%"><font size="+1"><b>VD_quartic</b></font></td><td><font size="+1"><b>VE_quartic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_quartic</b></font></td><td width="33%"><font size="+1"><b>VDx_quartic</b></font></td><td><font size="+1"><b>VEx_quartic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFu_quartic</b></font></td><td width="33%"><font size="+1"><b>VDu_quartic</b></font></td><td><font size="+1"><b>VEu_quartic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFux_quartic</b></font></td><td width="33%"><font size="+1"><b>VDux_quartic</b></font></td><td><font size="+1"><b>VEux_quartic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_quartic</b></font></td><td width="33%"><font size="+1"><b>VCD_quartic</b></font></td><td><font size="+1"><b>VCE_quartic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_quartic</b></font></td><td width="33%"><font size="+1"><b>VCDx_quartic</b></font></td><td><font size="+1"><b>VCEx_quartic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFu_quartic</b></font></td><td width="33%"><font size="+1"><b>VCDu_quartic</b></font></td><td><font size="+1"><b>VCEu_quartic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFux_quartic</b></font></td><td width="33%"><font size="+1"><b>VCDux_quartic</b></font></td><td><font size="+1"><b>VCEux_quartic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_quartic</b></font></td><td width="33%"><font size="+1"><b>VPD_quartic</b></font></td><td><font size="+1"><b>VPE_quartic</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPFu_quartic</b></font></td><td width="33%"><font size="+1"><b>VPDu_quartic</b></font></td><td><font size="+1"><b>VPEu_quartic</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Fourth power</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_quartic( fVector Y, fVector X, ui size );
<BR>int VFx_quartic( fVector Y, fVector X, ui size, float A, float B );
<BR>int VFu_quartic( fVector Y, fVector X, ui size );
<BR>int VFux_quartic( fVector Y, fVector X, ui size, float A, float B );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::quartic( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_quartic( const vector&lt;T&gt;& X, T A, T B );
<BR>int vector&lt;T&gt;::u_quartic( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::ux_quartic( const vector&lt;T&gt;& X, T A, T B );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_quartic( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_quartic( Y, X:fVector; size:UInt; A, B:Single ): IntBool;
<BR>function VFu_quartic( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFux_quartic( Y, X:fVector; size:UInt; A, B:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = X<sub>i</sub> <sup>4</sup>
<BR>expanded versions: Y<sub>i</sub> = (A*X<sub>i</sub>+B) <sup>4</sup>
<BR>The fourth power of the elements of X is stored in Y. 
<BR>The &quot;unprotected&quot; versions (prefix <I>VFu_,&nbsp;&nbsp; VFux_</I>, etc.) do not perform any error handling, which makes them much faster (up to 50%) than the standard versions. The extended-precision complex (<I>VCEu_</I> and <I>VCEux_</I>) versions do not take some of the security measures present in the standard version and might fail for results very near the overflow limit; results near the underflow limit might be rendered as 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#square">VF_square</a>,&nbsp;&nbsp; <a href="#cubic">VF_cubic</a>,&nbsp;&nbsp; <a href="#sqrt">VF_sqrt</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#ipow">VF_ipow</a>,&nbsp;&nbsp; <a href="#poly">VF_poly</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ramp"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ramp</b></font></td><td width="33%"><font size="+1"><b>VD_ramp</b></font></td><td><font size="+1"><b>VE_ramp</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_ramp</b></font></td><td width="33%"><font size="+1"><b>VCD_ramp</b></font></td><td><font size="+1"><b>VCE_ramp</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_ramp</b></font></td><td width="20%"><font size="+1"><b>VBI_ramp</b></font></td><td width="20%"><font size="+1"><b>VSI_ramp</b></font></td><td width="20%"><font size="+1"><b>VLI_ramp</b></font></td><td><font size="+1"><b>VQI_ramp</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_ramp</b></font></td><td width="20%"><font size="+1"><b>VUB_ramp</b></font></td><td width="20%"><font size="+1"><b>VUS_ramp</b></font></td><td width="20%"><font size="+1"><b>VUL_ramp</b></font></td><td><font size="+1"><b>VUI_ramp</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initialize a vector with an ascending or descending &quot;ramp&quot;.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_ramp( fVector X, ui size, float Start, float Rise );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_,&nbsp;&nbsp; VCF_,&nbsp;&nbsp; VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VI_</I>, etc.)
<BR><font face="courier new">void VU_ramp( uVector X, ui size, unsigned Start, int Rise );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VUB_,&nbsp;&nbsp; VUS_,&nbsp;&nbsp; VUL_</I>)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::ramp( T Start, T Rise );
<BR>void vector&lt;unsigned&gt;::ramp( unsigned Start, int Rise );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_ramp( X:fVector; size:UInt; Start, Rise:Single );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VD_,&nbsp;&nbsp; VE_,&nbsp;&nbsp; VCF_,&nbsp;&nbsp; VCD_,&nbsp;&nbsp; VCE_,&nbsp;&nbsp; VI_</I>, etc.)
<BR><font face="courier new">procedure VU_ramp( X:uVector; size:UInt; Start:UInt; Rise:Integer );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>VUB_,&nbsp;&nbsp; VUS_,&nbsp;&nbsp; VUL_</I>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X<sub>i</sub> = Start + i * Rise
<BR>For the floating-point versions, remember the limited accuracy of floating-point numbers. For example, after calling
<BR><font face="courier new">VF_ramp( F1, 101, -1.0, 0.01 );</font>
<BR>the element F1<sub>100</sub> will not be 0.0, as you might wish, but rather something like 2.2E-8. Ths is due to the fact that the number 0.01 (passed as a float to the function) is not exactly representable in the data type float. If that is a problem, consider building the ramp with moderately large integers and dividing by a scaling factor afterwards:
<BR><font face="courier new">VF_ramp( F1, 101, -100.0, 1.0 );
<BR><a href="#divC">VF_divC</a>( F1, F1, 101, 100.0 );</font>
<P>Note that Rise is defined as int instead of unsigned in the <I>VU_</I> version and as long instead of unsigned long in the <I>VUL_</I> version; this exception from the general rules - that all parameters in one function be of the same data type - allows to create descending ramps of unsigned numbers, which would not be possible otherwise.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>floating-point versions: none;
<BR>integer versions: see <a href="HANDBOOK.HTM#chap5_2">chapter&nbsp;5.2.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#Parzen">VF_Parzen</a>,&nbsp;&nbsp; <a href="#Welch">VF_Welch</a>,&nbsp;&nbsp; <a href="#equ1">VF_equ1</a>,&nbsp;&nbsp; <a href="#random">VF_random</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="random"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_random</b></font></td><td width="33%"><font size="+1"><b>VD_random</b></font></td><td><font size="+1"><b>VE_random</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_random</b></font></td><td width="20%"><font size="+1"><b>VBI_random</b></font></td><td width="20%"><font size="+1"><b>VSI_random</b></font></td><td width="20%"><font size="+1"><b>VLI_random</b></font></td><td><font size="+1"><b>VQI_random</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_random</b></font></td><td width="20%"><font size="+1"><b>VUB_random</b></font></td><td width="20%"><font size="+1"><b>VUS_random</b></font></td><td width="20%"><font size="+1"><b>VUL_random</b></font></td><td><font size="+1"><b>VUI_random</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>High-quality random numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>long VF_random( fVector X, ui siz, long seed, float MinVal, float MaxVal );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>long vector&lt;T&gt;::random( long seed, T MinVal, T MaxVal );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_random( X:fVector; size:UInt; seed:LongInt; MinVal, MaxVal:Single ): LongInt;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The X vector is filled with a sequence of random numbers. Within the ranges defined by MinVal and MaxVal, and within the restrictions of floating-point representation, all numbers are equally probable (including the extreme values themselves), i.e., so-called &quot;uniform deviates&quot; are produced. The parameter seed may be any number. Successive calls to one and the same of these functions will yield identical sequences, if seed is chosen equal; if seed is chosen differently for successive calls, the results will be uncorrelated.
<P>Internally, these functions employ a 32-bit integer random number generator by H.W.Lewis, with additional steps (so-called &quot;Bays-Durham shuffle&quot;) to break sequential correlations. This ensures very good randomness, far superior to simpler generators (like the <I>rand</I> function of C/C++ compilers or the <I>random</I> function of Pascal/Delphi).
<P>A long value is returned which may be used as new seed for subsequent calls.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>last 32-bit random number generated; this may be used as a new seed value for future calls.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#noise">VF_noise</a>,&nbsp;&nbsp; rand,&nbsp;&nbsp; srand</I> (C/C++ only),&nbsp;&nbsp;<I>random</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ratinterpol"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ratinterpol</b></font></td><td width="33%"><font size="+1"><b>VD_ratinterpol</b></font></td><td><font size="+1"><b>VE_ratinterpol</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Diagonal-rational interpolation</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_ratinterpol( fVector Y, fVector X, ui sizex, fVector XTab, fVector YTab, ui sizetab, unsigned deg );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::ratinterpol( const vector&lt;T&gt;& X, const vector&lt;T&gt;& XTab, const vector&lt;T&gt;& YTab, unsigned deg );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_ratinterpol( Y, X:fVector; sizex:UInt; XTab, YTab:fVector; sizetab:UInt; deg:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>For each of the sizex elements of X, the corresponding element of Y is interpolated from the XTab-YTab value pairs. XTab must be ordered (either ascending or descending). All values of XTab must be distinct; otherwise a division by zero may occur and lead to a program abort. The parameter deg denotes the number of points that will be taken into account for the interpolation; the diagonal rational interpolation scheme by Stoer and Bulirsch is used. The interpolating function is formed by the quotient of two polynomials, the polynomial in the denominator being of the same order (for even deg) or of an order higher by one (for odd deg) than the polynomial of the numerator.
<BR>Diagonal rational interpolation is superior to polynomial interpolation, especially in the presence of poles. It is, however, much slower.
<BR>deg must be between 3 and 20.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>A pole (infinity) in the interpolated function is recognized and leads to a SING error with the proposed result being &#177;HUGE_VAL. (Note: the x-value passed to <I>_matherr</I> is the first element of XTab). Trying to use too many elements for the interpolation (deg &gt; 20) leads to an error message &quot;Not possible with more than 20 elements&quot; and to a program abort. If deg is not between 3 and 20, or exceeds sizetab, an error message &quot;Invalid parameter(s)&quot; is displayed and the program aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#polyinterpol">VF_polyinterpol</a>,&nbsp;&nbsp; <a href="#splineinterpol">VF_splineinterpol</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="read"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_read</b></font></td><td width="33%"><font size="+1"><b>VD_read</b></font></td><td><font size="+1"><b>VE_read</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_read</b></font></td><td width="33%"><font size="+1"><b>VCD_read</b></font></td><td><font size="+1"><b>VCE_read</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_read</b></font></td><td width="33%"><font size="+1"><b>VPD_read</b></font></td><td><font size="+1"><b>VPE_read</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_read</b></font></td><td width="20%"><font size="+1"><b>VBI_read</b></font></td><td width="20%"><font size="+1"><b>VSI_read</b></font></td><td width="20%"><font size="+1"><b>VLI_read</b></font></td><td><font size="+1"><b>VQI_read</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_read</b></font></td><td width="20%"><font size="+1"><b>VUB_read</b></font></td><td width="20%"><font size="+1"><b>VUS_read</b></font></td><td width="20%"><font size="+1"><b>VUL_read</b></font></td><td><font size="+1"><b>VUI_read</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>reads a vector in ASCII format from a stream</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_read( fVector X, ui size, FILE *stream );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::read( FILE *stream );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_read( X:fVector; size:UInt; var Stream:Text );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>size elements are read in ASCII format (up to 80 characters) from stream and stored in X. Normally, this function will be used to import vectors from a program which cannot store numbers in machine format. It can also be used to retrieve vectors previously stored by <I><a href="#write">VF_write</a></I>. For storing and retrieving intermediate results, however, the function pair <I><a href="#store">VF_store</a></I> / <I><a href="#recall">VF_recall</a></I> is to be preferred over <I><a href="#write">VF_write</a></I> / <I>VF_read</I> (see <I><a href="#write">VF_write</a></I>).
<P><u>Complex versions:</u>
<BR>Real und imaginary parts (cartesian complex) or the Mag and Arg parts (polar complex) may, but need not, be enclosed in braces { } or brackets ( ). However, you must be consequent: Either all or no element may be written with braces or brackets.
<BR>A komma may (but need not) separate the two parts. The imaginary part (cartesian) or the Arg part (polar) must always be explicitly specified, even if it is zero.
<BR>Examples for legal formats are:
<BR>0.3 0.5&nbsp;&nbsp;&nbsp;&nbsp;(neither braces nor separating komma)
<BR>0.3, 0.5&nbsp;&nbsp;&nbsp;&nbsp;(no braces; separating komma)
<BR>{0.3 0.5}&nbsp;&nbsp;&nbsp;&nbsp;(braces; no separating komma)
<BR>(0.3, 0.5)&nbsp;&nbsp;&nbsp;&nbsp;(brackets and separating komma)</td></tr>
<tr valign="TOP">
<td>C/C++ specific:</td><TD>The entries to be read must be separated by whitespace (' ', '\n', or '\t'). Additionally, one (!) &quot;non-whitespace&quot; character is tolerated after each entry, if it follows directly after the last digit. After it, there must be one or more whitespace characters.
<P><u>Whole-number versions</u> except <I>VQI_read</I>:
<BR>By default, the numbers to be read are interpreted as decimal numbers. You may use <I><a href="#setRadix">V_setRadix</a></I> to define any radix between 2 and 36.</td></tr>
<tr valign="TOP">
<td>Pascal/Delphi specific:</td><TD>The entries to be read must be separated by whitespace (' ', #13, or #9).
<P>Whereas the C/C++ version of these functions follows the conventions of the C functions <I>strtod,&nbsp;&nbsp; strtol</I>, etc., the Pascal/Delphi version has to follow the rules applying to the Pascal/Delphi function <I>Read</I>. This makes the Pascal/Delphi version much less flexible than the C version:
<BR>- no separation characters allowed other than ' ' and #9,
<BR>- no automatic truncation of overflowing numbers,
<BR>- no function <I><a href="#setRadix">V_setRadix</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td><u>C/C++:</u>
<BR>Real, complex and quad versions:
<BR>Overflowing numbers are silently truncated to &#177;HUGE_VAL.
<BR>Whole-number versions except <I>VQI_read</I>:
<BR>As long as the numbers can be represented as long or unsigned long, overflowing bits are ignored in the 16-bit versions. Numbers beyond the long range yield -1 (signed types) or +HUGE_VAL (unsigned types).
<BR><u>Pascal/Delphi:</u>
<BR>Overflowing numbers or numbers otherwise not conforming to the format requirements lead to an I/O error.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#nread">VF_nread</a>,&nbsp;&nbsp; <a href="#write">VF_write</a>,&nbsp;&nbsp; <a href="#store">VF_store</a>,&nbsp;&nbsp; <a href="#recall">VF_recall</a>,&nbsp;&nbsp; strtod,&nbsp;&nbsp; strtol</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="real"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_real</b></font></td><td width="33%"><font size="+1"><b>VCD_real</b></font></td><td><font size="+1"><b>VCE_real</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_real</b></font></td><td width="33%"><font size="+1"><b>VPD_real</b></font></td><td><font size="+1"><b>VPE_real</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Real part of a complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VCF_real( fVector Re, cfVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::real( const vector&lt;complex&lt;T&gt;&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VCF_real( Re:fVector; X:cfVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Identical to <I><a href="#CtoRe">VF_CtoRe</a>,&nbsp;&nbsp; <a href="#CtoRe">VD_CtoRe</a></I>, and <I><a href="#CtoRe">VE_CtoRe</a></I>. See these functions for details.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="recall"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_recall</b></font></td><td width="33%"><font size="+1"><b>VD_recall</b></font></td><td><font size="+1"><b>VE_recall</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_recall</b></font></td><td width="33%"><font size="+1"><b>VCD_recall</b></font></td><td><font size="+1"><b>VCE_recall</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_recall</b></font></td><td width="33%"><font size="+1"><b>VPD_recall</b></font></td><td><font size="+1"><b>VPE_recall</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_recall</b></font></td><td width="20%"><font size="+1"><b>VBI_recall</b></font></td><td width="20%"><font size="+1"><b>VSI_recall</b></font></td><td width="20%"><font size="+1"><b>VLI_recall</b></font></td><td><font size="+1"><b>VQI_recall</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_recall</b></font></td><td width="20%"><font size="+1"><b>VUB_recall</b></font></td><td width="20%"><font size="+1"><b>VUS_recall</b></font></td><td width="20%"><font size="+1"><b>VUL_recall</b></font></td><td><font size="+1"><b>VUI_recall</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Read a vector in binary format from a stream</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_recall( fVector X, ui size, FILE *stream );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::recall( FILE *stream );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_recall( X:fVector; size:UInt; var Stream:FILE );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><I>size</I> elements of X are read from <I>stream</I> in binary format. Normally, these functions are used to retrieve data stored by the respective function of the <I><a href="#store">VF_store</a></I> family. The data type for reading and writing has to be the same. It is not possible to, e.g., store data by <I><a href="#store">VF_store</a></I> and recall them by <I>VD_recall</I> (in contrast to the corresponding write/read functions in ASCII format, see <I><a href="#read">VF_read</a></I>).
<P>The <I>VecObj</I> version differs from the &quot;normal&quot; C/C++ version in that it reads <U>vector objects</U>, not only the vector elements. It first reads a <B>ui</B>, giving the <I>size</I> of the vector, and then <I>size</I> elements, whereas the <I>V?_recall</I> functions assume <I>size</I> as known and take it as an argument. Therefore, the <I>VecObj</I> function <I>recall</I> can be used only to read vector objects previously stored with the <I><U>VecObj</U></I> function <I>store</I>, but not vectors stored with one of the <I>V?_store</I> functions.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#store">VF_store</a>,&nbsp;&nbsp; <a href="#write">VF_write</a>,&nbsp;&nbsp; <a href="#print">VF_print</a>,&nbsp;&nbsp; fwrite,&nbsp;&nbsp; fread</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="redC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_redC</b></font></td><td width="33%"><font size="+1"><b>VD_redC</b></font></td><td><font size="+1"><b>VE_redC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;Reduce&quot; by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_redC( fVector Y, fVector X, ui size, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::redC( const vector&lt;T&gt;& X, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_redC( Y, X:fVector; size:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = red( X<sub>i</sub>, C ) = X<sub>i</sub> * C / (X<sub>i</sub> + C)
<BR>Expressions of this type are frequently used in physics; for example, the &quot;reduced mass&quot; of a two-body system is the product of both masses divided by their sum.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#redV">VF_redV</a>,&nbsp;&nbsp; <a href="#addC">VF_addC</a>,&nbsp;&nbsp; <a href="#subC">VF_subC</a>,&nbsp;&nbsp; <a href="#divC">VF_divC</a>,&nbsp;&nbsp; <a href="#visC">VF_visC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="redV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_redV</b></font></td><td width="33%"><font size="+1"><b>VD_redV</b></font></td><td><font size="+1"><b>VE_redV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_redV</b></font></td><td width="33%"><font size="+1"><b>VDx_redV</b></font></td><td><font size="+1"><b>VEx_redV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;Reduce&quot; by corresponding vector elements</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_redV( fVector Z, fVector X, fVector Y, ui size );
<BR>void VFx_redV( fVector Z, fVector X, fVector Y, ui size, float A, float B );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::redV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y );
<BR>void vector&lt;T&gt;::x_redV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y, T A, T B );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_redV( Z, X, Y:fVector; size:UInt );
<BR>procedure VFx_redV( Z, X, Y:fVector; size:UInt; A, B:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions:
<BR>Z<sub>i</sub> = red( X<sub>i</sub>, Y<sub>i</sub> ) = X<sub>i</sub> * Y<sub>i</sub> / (X<sub>i</sub> + Y<sub>i</sub>)
<BR>expanded versions: 
<BR>xi = (A * X<sub>i</sub> + B),
<BR>Z<sub>i</sub> = red( xi, Y<sub>i</sub> )</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#redC">VF_redC</a>,&nbsp;&nbsp; <a href="#addV">VF_addV</a>,&nbsp;&nbsp; <a href="#subV">VF_subV</a>,&nbsp;&nbsp; <a href="#divV">VF_divV</a>,&nbsp;&nbsp; <a href="#visV">VF_visV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="reflect"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_reflect</b></font></td><td width="33%"><font size="+1"><b>VD_reflect</b></font></td><td><font size="+1"><b>VE_reflect</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_reflect</b></font></td><td width="33%"><font size="+1"><b>VCD_reflect</b></font></td><td><font size="+1"><b>VCE_reflect</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_reflect</b></font></td><td width="33%"><font size="+1"><b>VPD_reflect</b></font></td><td><font size="+1"><b>VPE_reflect</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_reflect</b></font></td><td width="20%"><font size="+1"><b>VBI_reflect</b></font></td><td width="20%"><font size="+1"><b>VSI_reflect</b></font></td><td width="20%"><font size="+1"><b>VLI_reflect</b></font></td><td><font size="+1"><b>VQI_reflect</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_reflect</b></font></td><td width="20%"><font size="+1"><b>VUB_reflect</b></font></td><td width="20%"><font size="+1"><b>VUS_reflect</b></font></td><td width="20%"><font size="+1"><b>VUL_reflect</b></font></td><td><font size="+1"><b>VUI_reflect</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Derive the second half of a vector from the first half by reflection at the midpoint.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_reflect( fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::reflect();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_reflect( X:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X<sub>size-i-1</sub> = X<sub>i</sub>,&nbsp;&nbsp;&nbsp;i=0,...,(size-1)/2
<BR>The elements of the lower half of a vector are copied in reverse order into the upper half, i.e., the zero'th element is copied to the last, the element number 1 to the second last, and so on. The elements of the first half are not affected by this operation. This function will be used, e.g., to construct a response function for convolutions (see <I><a href="#convolve">VF_convolve</a></I>). In this case, note that the zero'th element is to appear only once in the response function and must not be included in the reflection by <I>VF_reflect</I>. Therefore, you have to calculate the response function for size/2+1 elements and to apply reflection from element 1 on. For an example, see <I><a href="#convolve">VF_convolve</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#rotate">VF_rotate</a>,&nbsp;&nbsp; <a href="#rev">VF_rev</a>,&nbsp;&nbsp; <a href="#convolve">VF_convolve</a>,&nbsp;&nbsp; <a href="#deconvolve">VF_deconvolve</a>,&nbsp;&nbsp; <a href="#filter">VF_filter</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ReImtoC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ReImtoC</b></font></td><td width="33%"><font size="+1"><b>VD_ReImtoC</b></font></td><td><font size="+1"><b>VE_ReImtoC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Construct a cartesian complex vector from real and imaginary parts</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VF_ReImtoC( cfVector Y, fVector Re, fVector Im, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;complex&lt;T&gt;&gt;::ReImtoC( const vector&lt;T&gt;& Re, const vector&lt;T&gt;& Im );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VF_ReImtoC( X:cfVector; Re, Im:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The complex vector Y is constructed from two real vectors that become the real and imaginary parts of Y.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#CtoReIm">VF_CtoReIm</a>,&nbsp;&nbsp; <a href="#RetoC">VF_RetoC</a>,&nbsp;&nbsp; <a href="#PolartoC">VF_PolartoC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ReImtoP"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ReImtoP</b></font></td><td width="33%"><font size="+1"><b>VD_ReImtoP</b></font></td><td><font size="+1"><b>VE_ReImtoP</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Construct a polar complex vector from real and imaginary parts</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VPFstd.h&gt;
<BR>void VF_ReImtoP( pfVector Y, fVector Re, fVector Im, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;polar&lt;T&gt;&gt;::ReImtoP( const vector&lt;T&gt;& Re, const vector&lt;T&gt;& Im );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VPFstd;
<BR>procedure VF_ReImtoP( X:pfVector; Re, Im:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The polar complex vector Y is constructed from cartesian coordinates entered as the two real vectors Re and Im.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#PtoReIm">VF_PtoReIm</a>,&nbsp;&nbsp; <a href="#MagArgtoP">VF_MagArgtoP</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="RetoC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_RetoC</b></font></td><td width="33%"><font size="+1"><b>VD_RetoC</b></font></td><td><font size="+1"><b>VE_RetoC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Overwrite the real part of a cartesian complex vector with a real vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>void VF_RetoC( cfVector Y, fVector Re, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;complex&lt;T&gt;&gt;::RetoC( const vector&lt;T&gt;& Re );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VF_RetoC( X:cfVector; Re:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The real part of the complex vector Y is overwritten with the elements of the real-valued vector Re. The imaginary part of Y is not affected.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#CtoReIm">VF_CtoReIm</a>,&nbsp;&nbsp; <a href="#ReImtoC">VF_ReImtoC</a>,&nbsp;&nbsp; <a href="#ImtoC">VF_ImtoC</a>,&nbsp;&nbsp; <a href="#PolartoC">VF_PolartoC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="rev"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_rev</b></font></td><td width="33%"><font size="+1"><b>VD_rev</b></font></td><td><font size="+1"><b>VE_rev</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_rev</b></font></td><td width="33%"><font size="+1"><b>VCD_rev</b></font></td><td><font size="+1"><b>VCE_rev</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_rev</b></font></td><td width="33%"><font size="+1"><b>VPD_rev</b></font></td><td><font size="+1"><b>VPE_rev</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_rev</b></font></td><td width="20%"><font size="+1"><b>VBI_rev</b></font></td><td width="20%"><font size="+1"><b>VSI_rev</b></font></td><td width="20%"><font size="+1"><b>VLI_rev</b></font></td><td><font size="+1"><b>VQI_rev</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_rev</b></font></td><td width="20%"><font size="+1"><b>VUB_rev</b></font></td><td width="20%"><font size="+1"><b>VUS_rev</b></font></td><td width="20%"><font size="+1"><b>VUL_rev</b></font></td><td><font size="+1"><b>VUI_rev</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Reverse the ordering of the elements of a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_rev( fVector Y, fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::rev( const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_rev( Y, X:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>size-i-1</sub></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#reflect">VF_reflect</a>,&nbsp;&nbsp; <a href="#rotate">VF_rotate</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="rms"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_rms</b></font></td><td width="33%"><font size="+1"><b>VD_rms</b></font></td><td><font size="+1"><b>VE_rms</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Root of the mean square</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_rms( fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::rms();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_rms( X:fVector; size:UInt ); Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>rms = sqrt( (1/size) * sum( X<sub>i</sub><sup>2</sup> ) )</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>rms</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ssq">VF_ssq</a>,&nbsp;&nbsp; <a href="#Euclid">VF_Euclid</a>,&nbsp;&nbsp; <a href="#mean">VF_mean</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="rotate"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_rotate</b></font></td><td width="33%"><font size="+1"><b>VD_rotate</b></font></td><td><font size="+1"><b>VE_rotate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_rotate</b></font></td><td width="33%"><font size="+1"><b>VCD_rotate</b></font></td><td><font size="+1"><b>VCE_rotate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_rotate</b></font></td><td width="33%"><font size="+1"><b>VPD_rotate</b></font></td><td><font size="+1"><b>VPE_rotate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_rotate</b></font></td><td width="20%"><font size="+1"><b>VBI_rotate</b></font></td><td width="20%"><font size="+1"><b>VSI_rotate</b></font></td><td width="20%"><font size="+1"><b>VLI_rotate</b></font></td><td><font size="+1"><b>VQI_rotate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_rotate</b></font></td><td width="20%"><font size="+1"><b>VUB_rotate</b></font></td><td width="20%"><font size="+1"><b>VUS_rotate</b></font></td><td width="20%"><font size="+1"><b>VUL_rotate</b></font></td><td><font size="+1"><b>VUI_rotate</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Rotate the ordering of the elements of a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_rotate( fVector Y, fVector X, ui size, int pos );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::rotate( const vector&lt;T&gt;& X, int pos );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_rotate( Y, X:fVector; size:UInt; pos:Integer );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>size-pos+i</sub>,&nbsp;&nbsp;&nbsp;i=0,..,pos-1
<BR>Y<sub>i</sub> = X<sub>i-pos</sub>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i=pos,..,size-1
<BR>The output vector equals the rotated input vector. Clockwise rotation is achieved by a positive number pos.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#reflect">VF_reflect</a>,&nbsp;&nbsp; <a href="#rev">VF_rev</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="round"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_round</b></font></td><td width="33%"><font size="+1"><b>VD_round</b></font></td><td><font size="+1"><b>VE_round</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_roundtoI</b></font></td><td width="33%"><font size="+1"><b>VD_roundtoI</b></font></td><td><font size="+1"><b>VE_roundtoI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_roundtoBI</b></font></td><td width="33%"><font size="+1"><b>VD_roundtoBI</b></font></td><td><font size="+1"><b>VE_roundtoBI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_roundtoSI</b></font></td><td width="33%"><font size="+1"><b>VD_roundtoSI</b></font></td><td><font size="+1"><b>VE_roundtoSI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_roundtoLI</b></font></td><td width="33%"><font size="+1"><b>VD_roundtoLI</b></font></td><td><font size="+1"><b>VE_roundtoLI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_roundtoQI</b></font></td><td width="33%"><font size="+1"><b>VD_roundtoQI</b></font></td><td><font size="+1"><b>VE_roundtoQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_roundtoU</b></font></td><td width="33%"><font size="+1"><b>VD_roundtoU</b></font></td><td><font size="+1"><b>VE_roundtoU</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_roundtoUB</b></font></td><td width="33%"><font size="+1"><b>VD_roundtoUB</b></font></td><td><font size="+1"><b>VE_roundtoUB</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_roundtoUS</b></font></td><td width="33%"><font size="+1"><b>VD_roundtoUS</b></font></td><td><font size="+1"><b>VE_roundtoUS</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_roundtoUL</b></font></td><td width="33%"><font size="+1"><b>VD_roundtoUL</b></font></td><td><font size="+1"><b>VE_roundtoUL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_roundtoUI</b></font></td><td width="33%"><font size="+1"><b>VD_roundtoUI</b></font></td><td><font size="+1"><b>VE_roundtoUI</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Rounding to the nearest whole number.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_round( fVector Y, fVector X, ui size );
<BR>int VF_roundtoI( iVector Y, fVector X, ui size );
<BR>int VF_roundtoLI( liVector Y, fVector X, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::round( const vector&lt;T&gt;& X );
<BR>int vector&lt;int&gt;::roundtoI( const vector&lt;T&gt;& X );
<BR>int vector&lt;long&gt;::roundtoLI( const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_round( Y, X:fVector; size:UInt ):IntBool;
<BR>function VF_roundtoI( Y:iVector; X:fVector; size:UInt ):IntBool;
<BR>function VF_roundtoLI( Y:liVector; X:fVector; size:UInt ):IntBool;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of X is rounded to the nearest integer value. In case of a fractional part of exactly 0.5, the nearest even integer value is chosen and stored in Y. For example, 2.5 is rounded to 2, and 3.5 is rounded to 4.
<BR>The functions <I>VF_roundtoI,&nbsp;&nbsp; VF_roundtoLI,&nbsp;&nbsp; VF_roundtoU</I>, etc. convert the result into the various integer data types.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors are handled by setting the result to the extreme value possible. Negative numbers in the versions <I>VF_roundtoU,&nbsp;&nbsp; VF_roundtoUB,&nbsp;&nbsp; VF_roundtoUS,&nbsp;&nbsp; VF_roundtoUL</I>, and <I>VF_roundtoUI</I> lead to DOMAIN errors; they are handled by setting the result to 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ceil">VF_ceil</a>,&nbsp;&nbsp; <a href="#floor">VF_floor</a>,&nbsp;&nbsp; <a href="#chop">VF_chop</a>,&nbsp;&nbsp; <a href="#trunc">VF_trunc</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="runintegralC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_runintegralC</b></font></td><td width="33%"><font size="+1"><b>VD_runintegralC</b></font></td><td><font size="+1"><b>VE_runintegralC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;running integral&quot; of an array sampled at equally-spaced abscissa points.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_runintegralC( fVector Y, fVector X, ui size, float DeltaT );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::runintegralC( const vector&lt;T&gt;& X, T DeltaT );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_runintegralC( Y, X:fVector; size:UInt; DeltaT:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector X is assumed to be a function of a variable t; the t values themselves are equally spaced. Therefore, only their spacing, DeltaT, must be known to the function. Each element of Y is the integral of all elements of X up to and including the one with the same index. Thus, the last element of Y contains the value of the integral over the whole of X (the area under X). If only this value is of interest, <I><a href="#integralC">VF_integralC</a></I> should be used.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#runintegralV">VF_runintegralV</a>,&nbsp;&nbsp; <a href="#integralC">VF_integralC</a>,&nbsp;&nbsp; <a href="#derivC">VF_derivC</a>,&nbsp;&nbsp; <a href="#runsum">VF_runsum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="runintegralV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_runintegralV</b></font></td><td width="33%"><font size="+1"><b>VD_runintegralV</b></font></td><td><font size="+1"><b>VE_runintegralV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;running integral&quot;</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_runintegralV( fVector Z, fVector X, fVector Y, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::runintegralV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_runintegralV( Z, X, Y:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y is a function of the variable x which is represented by X. Each element of Z is the integral over all elements of Y up to and including the one with the same index. The first element of Z is always FALSE (0).0. The last element of Z is equal to the value of the integral, i.e. to the area under Y. If only this value of the integral is of interest, <I><a href="#integralV">VF_integralV</a></I> should be used.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#runintegralC">VF_runintegralC</a>,&nbsp;&nbsp; <a href="#integralV">VF_integralV</a>,&nbsp;&nbsp; <a href="#derivV">VF_derivV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="runmax"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_runmax</b></font></td><td width="33%"><font size="+1"><b>VD_runmax</b></font></td><td><font size="+1"><b>VE_runmax</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_runmax</b></font></td><td width="20%"><font size="+1"><b>VBI_runmax</b></font></td><td width="20%"><font size="+1"><b>VSI_runmax</b></font></td><td width="20%"><font size="+1"><b>VLI_runmax</b></font></td><td><font size="+1"><b>VQI_runmax</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_runmax</b></font></td><td width="20%"><font size="+1"><b>VUB_runmax</b></font></td><td width="20%"><font size="+1"><b>VUS_runmax</b></font></td><td width="20%"><font size="+1"><b>VUL_runmax</b></font></td><td><font size="+1"><b>VUI_runmax</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;running&quot; maximum.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_runmax( fVector Y, fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::runmax( const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_runmax( Y, X:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of Y is the maximum of the corresponding and all preceding elements of X.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#max">VF_max</a>,&nbsp;&nbsp; <a href="#runmin">VF_runmin</a>,&nbsp;&nbsp; <a href="#runsum">VF_runsum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="runmin"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_runmin</b></font></td><td width="33%"><font size="+1"><b>VD_runmin</b></font></td><td><font size="+1"><b>VE_runmin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_runmin</b></font></td><td width="20%"><font size="+1"><b>VBI_runmin</b></font></td><td width="20%"><font size="+1"><b>VSI_runmin</b></font></td><td width="20%"><font size="+1"><b>VLI_runmin</b></font></td><td><font size="+1"><b>VQI_runmin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_runmin</b></font></td><td width="20%"><font size="+1"><b>VUB_runmin</b></font></td><td width="20%"><font size="+1"><b>VUS_runmin</b></font></td><td width="20%"><font size="+1"><b>VUL_runmin</b></font></td><td><font size="+1"><b>VUI_runmin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;running&quot; minimum</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_runmin( fVector Y, fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::runmin( const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_runmin( Y, X:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of Y is the minimum of the corresponding and all preceding elements of X.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#min">VF_min</a>,&nbsp;&nbsp; <a href="#runmax">VF_runmax</a>,&nbsp;&nbsp; <a href="#runsum">VF_runsum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="runprod"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_runprod</b></font></td><td width="33%"><font size="+1"><b>VD_runprod</b></font></td><td><font size="+1"><b>VE_runprod</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_runprod</b></font></td><td width="33%"><font size="+1"><b>VCD_runprod</b></font></td><td><font size="+1"><b>VCE_runprod</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_runprod</b></font></td><td width="33%"><font size="+1"><b>VPD_runprod</b></font></td><td><font size="+1"><b>VPE_runprod</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;running&quot; product</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_runprod( fVector Y, fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::runprod( const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_runprod( Y, X:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of Y is the product of the corresponding and all preceding elements of X. This function should be used with care: overflow is easily reached, and underflow may lead to all elements from a certain position on being zero.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#prod">VF_prod</a>,&nbsp;&nbsp; <a href="#runsum">VF_runsum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="runsum"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_runsum</b></font></td><td width="33%"><font size="+1"><b>VD_runsum</b></font></td><td><font size="+1"><b>VE_runsum</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_runsum</b></font></td><td width="33%"><font size="+1"><b>VCD_runsum</b></font></td><td><font size="+1"><b>VCE_runsum</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_runsum</b></font></td><td width="20%"><font size="+1"><b>VBI_runsum</b></font></td><td width="20%"><font size="+1"><b>VSI_runsum</b></font></td><td width="20%"><font size="+1"><b>VLI_runsum</b></font></td><td><font size="+1"><b>VQI_runsum</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_runsum</b></font></td><td width="20%"><font size="+1"><b>VUB_runsum</b></font></td><td width="20%"><font size="+1"><b>VUS_runsum</b></font></td><td width="20%"><font size="+1"><b>VUL_runsum</b></font></td><td><font size="+1"><b>VUI_runsum</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;running&quot; sum</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_runsum( fVector Y, fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::runsum( const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_runsum( Y, X:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of Y is the sum of the corresponding and all preceding elements of X.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none (but be careful: this function may easily overflow!)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sum">VF_sum</a>,&nbsp;&nbsp; <a href="#runprod">VF_runprod</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sabsmax"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_sabsmax</b></font></td><td width="33%"><font size="+1"><b>VCD_sabsmax</b></font></td><td><font size="+1"><b>VCE_sabsmax</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Largest complex vector element in terms of the sum <nobr>|Re| + |Im|</nobr></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>fComplex VCF_sabsmax( cfVector X, ui size);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;complex&lt;T&gt;&gt;::sabsmax();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VCF_sabsmax( var Max:fComplex; X:cfVector; size:UInt );</font>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>By the criterion of the sum <nobr>|Re| + |Im|</nobr>, the largest element of a cartesian complex vector is found and returned. In many applications, this function may serve as a much faster replacement for <I><a href="#cabsmax">VCF_cabsmax</a></I>. The latter function uses the absolute value, <nobr><I>sqrt</I>(Re<sup>2</sup> + Im<sup>2</sup>),</nobr> as its criterion.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>largest element</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#absmax">VCF_absmax</a>,&nbsp;&nbsp; <a href="#absmaxReIm">VCF_absmaxReIm</a>,&nbsp;&nbsp; <a href="#cabsmax">VCF_cabsmax</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sabsmin"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_sabsmin</b></font></td><td width="33%"><font size="+1"><b>VCD_sabsmin</b></font></td><td><font size="+1"><b>VCE_sabsmin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Smallest complex vector element in terms of the sum <nobr>|Re| + |Im|</nobr></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VCFstd.h&gt;
<BR>fComplex VCF_sabsmin( cfVector X, ui size);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;complex&lt;T&gt;&gt;::sabsmin();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VCFstd;
<BR>procedure VCF_sabsmin( var Min:fComplex; X:cfVector; size:UInt );</font>
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>By the criterion of the sum <nobr>|Re| + |Im|</nobr>, the smallest element of a cartesian complex vector is found and returned. In many applications, this function may serve as a much faster replacement for <I><a href="#cabsmin">VCF_cabsmin</a></I>. The latter function uses the absolute value, <nobr><I>sqrt</I>(Re<sup>2</sup> + Im<sup>2</sup>),</nobr> as its criterion.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>smallest element</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#absmin">VCF_absmin</a>,&nbsp;&nbsp; <a href="#absminReIm">VCF_absminReIm</a>,&nbsp;&nbsp; <a href="#cabsmin">VCF_cabsmin</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="scale10"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_scale10</b></font></td><td width="33%"><font size="+1"><b>VD_scale10</b></font></td><td><font size="+1"><b>VE_scale10</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Scaling by an integer power of 10.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_scale10( fVector Y, fVector X, ui size, int Expo );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::scale10( const vector&lt;T&gt;& X, int Expo );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_scale10( Y, X:fVector; size:UInt; Expo:Integer ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>i</sub> * (10 <sup>Expo</sup>)
<BR>Note that higher powers of ten are not representable as exact numbers, which may lead to the introduction of round-off error by the scaling. If this is a problem, <I><a href="#scale2">VF_scale2</a></I> should be used instead.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#scale2">VF_scale2</a>,&nbsp;&nbsp; <a href="#mantexp">VF_mantexp</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="scale2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_scale2</b></font></td><td width="33%"><font size="+1"><b>VD_scale2</b></font></td><td><font size="+1"><b>VE_scale2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Scaling by an integer power of 2.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_scale2( fVector Y, fVector X, ui size, int Expo );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::scale2( const vector&lt;T&gt;& X, int Expo );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_scale2( Y, X:fVector; size:UInt; Expo:Integer ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>i</sub> * (2 <sup>Expo</sup>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#scale10">VF_scale10</a>,&nbsp;&nbsp; <a href="#mantexp">VF_mantexp</a>,&nbsp;&nbsp; ldexp</I> (C/C++)</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="scalprod"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_scalprod</b></font></td><td width="33%"><font size="+1"><b>VD_scalprod</b></font></td><td><font size="+1"><b>VE_scalprod</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Scalar product of two vectors</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_scalprod( fVector X, fVector Y, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::scalprod( const vector&lt;T&gt;& Y );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_scalprod( X, Y:fVector; size:UInt ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>scalprod = sum( X<sub>i</sub> * Y<sub>i</sub> )
<BR>The scalar (or dot) product of two vectors is defined as the sum of the products of the corresponding elements. The scalar product of a vector with itself is the square of its magnitude and may be calculated using the function <I><a href="#ssq">VF_ssq</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>product</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#prod">VF_prod</a>,&nbsp;&nbsp; <a href="#xprod">VF_xprod</a>,&nbsp;&nbsp; <a href="#sum">VF_sum</a>,&nbsp;&nbsp; <a href="#ssq">VF_ssq</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="searchC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_searchC</b></font></td><td width="33%"><font size="+1"><b>VD_searchC</b></font></td><td><font size="+1"><b>VE_searchC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Binary searches of an ordered table for the entry coming closest to a specified value</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>ui VF_searchC( fVector X, ui size, float C, int mode );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>ui vector&lt;T&gt;::searchC( T C, int mode );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_searchC( X:fVector; size:UInt; C:Single; mode:Integer ):UInt;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>In a binary search, the element of X is located that is closest to the value specified as C. X has to be an ordered table (either ascending or descending); if this condition is not fulfilled, the result will be wrong. If C is outside the range covered by X, the first or the last element of X is chosen, whichever is closer to C. If C is within the range of the table, three modes of the search are available:
<TABLE BORDER WIDTH="100%">
<TR><TD width="15%">mode = +1:</TD><TD>find the next element greater than or equal to C</TD></TR>
<TR valign="top"><TD>mode = &nbsp;&nbsp;0:</TD><TD>find the element closest to C; if two elements are within equal distance, choose the lower index</TD></TR>
<TR><TD>mode = &nbsp;-1:</TD><TD>find the next element less than or equal to C</TD></TR>
</table></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>index of the element found.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#searchV">VF_searchV</a>,&nbsp;&nbsp; <a href="#sort">VF_sort</a>,&nbsp;&nbsp; <a href="#polyinterpol">VF_polyinterpol</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="searchV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_searchV</b></font></td><td width="33%"><font size="+1"><b>VD_searchV</b></font></td><td><font size="+1"><b>VE_searchV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Binary search of an ordered table for the entries coming closest to the values specified as the elements of a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_searchV( uiVector Ind, fVector X, ui sizex, fVector Tab, ui sizetab, int mode );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;ui&gt;::searchV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Tab, int mode );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_searchV( Ind:uVector; X:fVector; sizex:UInt; Tab:fVector; sizetab:UInt; mode:Integer );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>For each element of X, the element of the table Tab is located that is closest to it. Tab has to be ordered (either ascending or descending); if this condition is not fulfilled, the results will be wrong.
<BR>If X<sub>i</sub> is outside the range of the table, the first or the last element of the table is chosen, whichever is appropriate. Otherwise, three modes of the search are available:
<TABLE BORDER WIDTH="100%">
<TR><TD width="15%">mode = +1:&nbsp;</TD><TD>find the next element greater than or equal to X<sub>i</sub></TD></TR>
<TR valign="top"><TD>mode = &nbsp;&nbsp;0:</TD><TD>find the element closest to X<sub>i</sub>; if two elements are within equal distance, choose the lower index</TD></TR>
<TR><TD>mode = &nbsp;-1:</TD><TD>find the next element less than or equal to X<sub>i</sub></TD></TR>
</TABLE>
<P><I>sizex</I> is the number of elements of X and of Ind, whereas <I>sizetab</I> denotes the number of elements of the table Tab.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#searchC">VF_searchC</a>,&nbsp;&nbsp; <a href="#indpick">VF_indpick</a>,&nbsp;&nbsp; <a href="#sortind">VF_sortind</a>,&nbsp;&nbsp; <a href="#polyinterpol">VF_polyinterpol</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sec"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sec</b></font></td><td width="33%"><font size="+1"><b>VD_sec</b></font></td><td><font size="+1"><b>VE_sec</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_sec</b></font></td><td width="33%"><font size="+1"><b>VDx_sec</b></font></td><td><font size="+1"><b>VEx_sec</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Secant function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sec( fVector Y, fVector X, ui size );
<BR>int VFx_sec( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sec( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_sec( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sec( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_sec( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = sec( X<sub>i</sub> )
&nbsp;&nbsp;&nbsp;= 1 / cos( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * sec( A*X<sub>i</sub>+B )
<BR>The secant is defined as the inverse of the cosine (not to be mistaken for the arcus function arccos). For large values of X<sub>i</sub>, round-off error becomes appreciable; if the X<sub>i</sub> values are representable as rational multiples of <font face="symbol">p</font>, it is better to use <I><a href="#secrpi">VF_secrpi</a></I> than <I>VF_sec</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>SING or OVERFLOW errors lead to the default result &#177;HUGE_VAL. TLOSS precision errors lead to a result of 1.0 (as if the input were 0.0).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sec2">VF_sec2</a>,&nbsp;&nbsp; <a href="#secrpi">VF_secrpi</a>,&nbsp;&nbsp; <a href="#cos">VF_cos</a>,&nbsp;&nbsp; <a href="#sech">VF_sech</a>,&nbsp;&nbsp; cos</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sec2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sec2</b></font></td><td width="33%"><font size="+1"><b>VD_sec2</b></font></td><td><font size="+1"><b>VE_sec2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_sec2</b></font></td><td width="33%"><font size="+1"><b>VDx_sec2</b></font></td><td><font size="+1"><b>VEx_sec2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Square of the secant function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sec2( fVector Y, fVector X, ui size );
<BR>int VFx_sec2( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sec2( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_sec2( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sec2( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_sec2( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = sec<sup>2</sup>( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * sec<sup>2</sup>( A*X<sub>i</sub>+B )
<BR>Calculating the squared trigonometric functions directly is faster and sometimes more accurate than first calculating the trigonometric function itself and squaring it afterwards.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>For SING and OVERFLOW errors, the default result is HUGE_VAL (multiplied by the sign of C in the expanded versions); TLOSS errors lead to a default result of 1.0 or C, resp. (as if the input were 0.0).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sec">VF_sec</a>,&nbsp;&nbsp; <a href="#secrpi">VF_secrpi</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sech"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sech</b></font></td><td width="33%"><font size="+1"><b>VD_sech</b></font></td><td><font size="+1"><b>VE_sech</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_sech</b></font></td><td width="33%"><font size="+1"><b>VDx_sech</b></font></td><td><font size="+1"><b>VEx_sech</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Hyperbolic secant function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sech( fVector Y, fVector X, ui size );
<BR>int VFx_sech( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sech( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_sech( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sech( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_sech( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions:
<BR>Y<sub>i</sub> = sech( X<sub>i</sub> )
<BR>&nbsp;&nbsp;&nbsp;&nbsp;= 2 / (exp( X<sub>i</sub> ) + exp( -X<sub>i</sub> ))
<BR>expanded versions:
<BR>Y<sub>i</sub> = C * sech( A*X<sub>i</sub>+B )</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>These functions should be error-proof.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sinh">VF_sinh</a>,&nbsp;&nbsp; <a href="#sech2">VF_sech2</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; sinh</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sech2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sech2</b></font></td><td width="33%"><font size="+1"><b>VD_sech2</b></font></td><td><font size="+1"><b>VE_sech2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_sech2</b></font></td><td width="33%"><font size="+1"><b>VDx_sech2</b></font></td><td><font size="+1"><b>VEx_sech2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Square of the hyperbolic secant function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sech2( fVector Y, fVector X, ui size );
<BR>int VFx_sech2( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sech2( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_sech2( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sech2( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_sech2( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = sech<sup>2</sup>( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * sech<sup>2</sup>( A*X<sub>i</sub>+B )
<BR>The sech<sup>2</sup> function is used in physics, e.g., to describe the shape of ultrashort light pulses. Compared to a Gaussian or Lorentzian pulse shape of the same autocorrelation width (see <I><a href="#autocorr">VF_autocorr</a></I>), the sech<sup>2</sup> function has the smallest FWHM (full width to half maximum).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>These functions should be error-proof.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sech">VF_sech</a>,&nbsp;&nbsp; <a href="#sinh">VF_sinh</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; <a href="#Gauss">VF_Gauss</a>,&nbsp;&nbsp; <a href="#Lorentz">VF_Lorentz</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="secrpi"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_secrpi</b></font></td><td width="33%"><font size="+1"><b>VD_secrpi</b></font></td><td><font size="+1"><b>VE_secrpi</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_secrpi2</b></font></td><td width="33%"><font size="+1"><b>VD_secrpi2</b></font></td><td><font size="+1"><b>VE_secrpi2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_secrpi3</b></font></td><td width="33%"><font size="+1"><b>VD_secrpi3</b></font></td><td><font size="+1"><b>VE_secrpi3</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Secant function of fractional multiples of <font face="symbol">p</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_secrpi( fVector Y, iVector P, ui size, int q );
<BR>int VF_secrpi2( fVector Y, iVector P, ui size, int q );
<BR>int VF_secrpi3( fVector Y, iVector P, ui size, int q );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::secrpi( const vector&lt;int&gt;& P, int q );
<BR>int vector&lt;T&gt;::secrpi2( const vector&lt;int&gt;& P, int q );
<BR>int vector&lt;T&gt;::secrpi3( const vector&lt;int&gt;& P, int q );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_secrpi( Y:fVector; P:iVector; size:UInt; q:Integer ): IntBool;
<BR>function VF_secrpi2( Y:fVector; P:iVector; size:UInt; q:Integer ): IntBool;
<BR>function VF_secrpi3( Y:fVector; P:iVector; size:UInt; q:Integer ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = sec( (P<sub>i</sub> / q) * <font face="symbol">p</font> )
<BR>The secant of fractional multiples of <font face="symbol">p</font> is calculated. There are three versions: <I>VF_secrpi</I> is for general use with any arbitrary denominator q. If q is a power of 2, <I>VF_secrpi2</I> should be used which is a highly optimized version utilizing a look-up table. If q is a multiple of 3, <I>VF_secrpi3</I> should be used. <I>VF_secrpi2</I> and <I>VF_secrpi3</I> work also with q values they are not optimized for; in this case, however, memory space is wasted for the tables.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>SING errors occur if P<sub>i</sub> / q is an odd multiple of 1/2; the default result is 0.0 (which is the mean of +HUGE_VAL and -HUGE_VAL; similarly to <I><a href="#cosecrpi">VF_cosecrpi2</a></I>, 0.0 is chosen irrespective to the fact that it is not a valid result of the secant function!);
<BR>q must be non-zero; this is, however, not tested for.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sec">VF_sec</a></I>,&nbsp;&nbsp;cos</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="selected_mean"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_selected_mean</b></font></td><td width="33%"><font size="+1"><b>VD_selected_mean</b></font></td><td><font size="+1"><b>VE_selected_mean</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Mean of the elements of a one-dimensional distribution, falling into a specified interval</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_selected_mean( ui *nsel, fVector X, ui size
 float XMin, float XMax );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::selected_mean( ui *nsel, T XMin, T XMax );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_selected_mean( var nsel:Uint; X:fVector; size:UInt; XMin, XMax:Single ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Those elements of X are selected, which fall into the interval XMin &lt;= X<sub>i</sub> &lt;= XMax.
<BR>Their mean is calculated, and the number of selected elements is stored at the address nsel. If this number is not needed, nsel may be passed to the function as NULL (C/C++) or nil (Pascal/Delphi).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>Mean of the selected vector elements</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mean">VF_mean</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setCoordSystem"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_setCoordSystem</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Restore the scalings and position of a coordinate system previously saved by <I><a href="#getCoordSystem">V_getCoordSystem</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void V_setCoordSystem( VCOORDSYSTEM *csys );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure V_setCoordSystem( csys: VCOORDSYSTEM );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>If one wants to &quot;hop&quot; between several coordinate systems, displayed in one and the same window, one has to store the specifications (position and scalings) of each coordinate system separately, using <I><a href="#getCoordSystem">V_getCoordSystem</a></I>, and to retrieve them as needed, using this function.
<BR>The address of a struct VCOORDSYSTEM is passed as the argument. VCOORDSYSTEM is defined in &lt;Vgraph.h&gt; (C/C++) or the unit Vgraph (Pascal/Delphi).
<BR>For an example, see <I><a href="#getCoordSystem">V_getCoordSystem</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#getCoordSystem">V_getCoordSystem</a>,&nbsp;&nbsp; <a href="#setPlotRegion">V_setPlotRegion</a>,&nbsp;&nbsp; <a href="#continuePlot">V_continuePlot</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setErrorEventFile"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_setErrorEventFile</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Prepare a file for printing error messages into it</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>void V_setErrorEventFile(
 char *filename, unsigned ScreenAndFile );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>procedure V_setErrorEventFile( filename:PChar; ScreenAndFile:IntBool );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function determines where to print messages notifying math errors that occur within <I>VectorLib</I> routines. filename is the desired name of the event file (often called &quot;log-file&quot;). ScreenAndFile decides if you wish to have error messages printed simultaneously into the file and onto the screen (ScreenAndFile = TRUE (non-zero)) or exclusively into the file (ScreenAndFile = FALSE (0)).
<BR>The default, i.e., printing error messages to the screen, is restored by <I><a href="#closeErrorEventFile">V_closeErrorEventFile</a></I>.
<BR>This function will not be included in versions of <I>OptiVec</I> for compilers which offer the possibility of printing error messages simultaneously to the screen and into an event file.
<P>If a user-defined <I>_matherr</I> function (C/C++) or any other custom error handler (both C/C++ and Pascal/Delphi) calls <I><a href="#noteError">V_noteError</a></I>, also errors occurring outside <I>OptiVec</I> routines w ill lead to a message printed into the event file (see <a href="HANDBOOK.HTM#chap5_5">chapter&nbsp;5.5</a>).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If the desired event file cannot be opened or created, the program is aborted with a message &quot;Cannot open error event file&quot;.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#noteError">V_noteError</a>,&nbsp;&nbsp; <a href="#closeErrorEventFile">V_closeErrorEventFile</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setFPAccuracy"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_setFPAccuracy</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Set the coprecessor to a specific precision</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>void  V_getFPAccuracy( unsigned level );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>procedure V_getFPAccuracy( level:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function changes the FPU Control-Word to switch the FPU to a specified accuracy, passed to the function as the argument <I>level</I>. For <I>level</I>=1, <B>float / Single</B> precision is obtained, <I>level</I>=2 leads to <B>double</B> precision, whereas <I>level</I>=3 switches the FPU into <B>extended</B> precision. The actual accuracy the coprocessor is switched to may be read through <I><a href="#getFPAccuracy">V_getFPAccuracy</a></I>.
<BR>Operating the floating-point processor at <B>float / Single</B> precision may significantly speed up program execution, especially for any functions involving divisions and on Pentium or higher. This is true for functions (including <I>OptiVec</I> functions) of any floating-point data type. Thereby, you may even operate <I>VD_</I> and <I>VE_</I> functions at <B>float / Single</B> accuracy  preserving <B>double</B> or <B>extended</B> range, but calculating results to single precision only. 
<BR>There are, however, several groups of functions which rely on full coprocessor accuracy for intermediate results, or which use precision-controlled iterations. Obviously, if the FPU operates in single precision only, such a function will never attain double precision and may get caught in an infinite loop. You should <U>never</U> call any of the following functions while the FPU is switched to single precision (or, for <I>VE_</I> functions, to double precision):
<BR><I><a href="#Kepler">V?_Kepler</a></I>,
<BR><I><a href="MATRIX.HTM#SVdecompose">M?_SVdecompose</a></I>,
<BR>or any of the nonlinear data fitting functions like <I><a href="MATRIX.HTM#nonlinfit">VF_nonlinfit</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#getFPAccuracy">V_getFPAccuracy</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setFPErrorHandling"></a><a name="FPErrorHandlingMode"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_setFPErrorHandling</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Define the action taken in the case of floating-point errors (Pascal/Delphi only).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>type V_fphand = 0..$1717;
<BR>procedure V_setFPErrorHandling( hand:V_fpHand );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>As Pascal/Delphi does not handle floating-point errors through a user-definable function <I>_matherr</I>, as does C/C++, the function <I>V_setFPErrorHandling</I> is offered in <I>OptiVec</I> as a means for the programmer to exert at least some control over the actions to be taken in the case of floating-point errors occurring within <I>OptiVec</I> functions. A number of pre-defined constants <I>fperrXXX</I> is available for the construction of the desired error-handling mode:<br>&nbsp;
<table border width="100%">
<tr valign="top"><td>Constant</td><td>Value</td><td>Meaning</td></tr>
<tr valign="top"><td>fperrIgnore</td><td>0</td><td>Ignore all floating-point errors: handle them silently, do not print a message, continue program execution</td></tr>
<tr valign="top"><td>fperrNoteDOMAIN</td><td>$0001</td><td>Print a message in case of a DOMAIN error</td></tr>
<tr valign="top"><td>fperrNoteSING</td><td>$0002</td><td>Print a message in case of a SING error</td></tr>
<tr valign="top"><td>fperrNoteOVERFLOW</td><td>$0003</td><td>Print a message in case of an OVERFLOW error</td></tr>
<tr valign="top"><td>fperrNoteTLOSS</td><td>$0004</td><td>Print a message in case of a TLOSS error</td></tr>
<tr valign="top"><td>fperrAbortDOMAIN</td><td>$0101</td><td>Abort program in case of a DOMAIN error</td></tr>
<tr valign="top"><td>fperrAbortSING</td><td>$0202</td><td>Abort program in case of a SING error</td></tr>
<tr valign="top"><td>fperrAbortOVERFLOW</td><td>$0303</td><td>Abort program in case of an OVERFLOW error</td></tr>
<tr valign="top"><td>fperrAbortTLOSS</td><td>$0404</td><td>Abort program in case of a TLOSS error</td></tr>
<tr valign="top"><td>fperrDefaultHandling</td><td>$0107</td><td>Same as fperrAbortDOMAIN <B>or</B> fperrNoteSING <B>or</B> fperrNoteOVERFLOW</td></tr>
</table>&nbsp;</td></tr>
<tr valign="TOP">
<td width="15%">Example</td><td><font face="courier new">V_setFPErrorHandling( fperrAbortDOMAIN + fperrAbortSING + fperrAbortOVERFLOW + fperrNoteTLOSS );</font>
<BR>In this example, program execution will be aborted (with the appropriate message) in the case of the most severe errors, DOMAIN and SING. In the case of OVERFLOW and TLOSS errors, a warning will be displayed, but program execution will be continued with default results set by the respective functions where the errors occur. The repeated occurrence
of the same type of error within one and the same function will lead to only one message being generated. Subsequent errors will be treated silently.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#setIntErrorHandling">V_setIntErrorHandling</a>,&nbsp;&nbsp; <a href="#setErrorEventFile">V_setErrorEventFile</a>,&nbsp;&nbsp; <a href="#noteError">V_noteError</a>,&nbsp;&nbsp; <a href="#printErrorMsg">V_printErrorMsg</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setIntErrorHandling"></a><a name="intErrorHandlingMode"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_setIntErrorHandling</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Define the action taken in the case of INTEGER OVERFLOW and INTEGER DOMAIN errors.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>typedef enum {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;ierrIgnore = 0,&nbsp;ierrNote,&nbsp;ierrAbort
<BR>} V_ihand;
<BR>void V_setIntErrorHandling( V_ihand ihand );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>type V_ihand = 0..2;
<BR>procedure V_setIntErrorHandling( ihand:V_iHand );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function allows to set the handling mode for OVERFLOW and DOMAIN errors occurring within integer functions of <I>OptiVec</I>. It has to be called with one of the following pre-defined constants as argument:<br><font face="courier new">
&nbsp;&nbsp;&nbsp;&nbsp;ierrIgnore = 0;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;ierrNote&nbsp;= 1;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;ierrAbort&nbsp;= 2;</font>
<BR>The default is that these errors are ignored, i.e., they are treated by discarding overflowing bits (see <a href="HANDBOOK.HTM#chap5_2">chapter&nbsp;5.2</a> for details on integer error handling). If you wish to change this behaviour, call, e.g.,
<BR><font face="courier new">V_setIntErrorHandling( ierrNote );</font>
<BR>and add the letter &quot;o&quot; to the prefixes of those integer functions for which you wish to trap errors: <I>VIo_,&nbsp;&nbsp; VUSo_</I>, etc.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#setFPErrorHandling">V_setFPErrorHandling</a>,&nbsp;&nbsp; <a href="#setErrorEventFile">V_setErrorEventFile</a>,&nbsp;&nbsp; <a href="#noteError">V_noteError</a>,&nbsp;&nbsp; <a href="#printErrorMsg">V_printErrorMsg</a></I>,&nbsp;&nbsp;<a href="HANDBOOK.HTM#chap5_2">chapter&nbsp;5.2</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setLineThickness"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_setLineThickness</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Modify the line thickness used in plotting functions</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void V_setLineThickness( unsigned linethickness );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure V_setLineThickness( linethickness:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The line thickness used in the plotting functions <I><a href="#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#autoPlot">VCF_autoPlot</a></I>, etc., is set to linethickness. To reset the default value, call <I>V_setLineThickness</I> with linethickness = 1.
<BR><u>DOS:</u>
<BR>There are only two possible values for linethickness:
<BR>&nbsp;&nbsp;&nbsp;C/C++: NORM_WIDTH = 1 and THICK_WIDTH = 3.
<BR>&nbsp;&nbsp;&nbsp;Pascal/Delphi: NormWidth = 1 and ThickWidth = 3.
<BR>Any value of linethickness below 3 is interpreted as NORM_WIDTH, any value above 3 is taken as THICK_WIDTH.
<BR><u>Windows:</u>
<BR>Any value of linethickness between 1 and 500 is allowed, useful values ranging from 1 to about 10. A minimum thickness of one pixel is always secured, even if linethickness is set to 0. Note that broken or dotted lines are plotted accurately only with a linethicknes of 1. At higher values of linethickness, all lines will look like solid lines. Thicker lines are plotted considerably slower than thinner ones.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td><u>DOS:</u> &quot;silent&quot; correction of the input value.
<BR><u>Windows:</u> A value of linethickness greater than 500 leads to a warning message &quot;Cannot use line thicker than 500 pixels.&quot; Program execution is continued with linethickness set to 500.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#setSymbolSize">V_setSymbolSize</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setNWriteSeparate"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_setNWriteSeparate</b></font></td><td width="33%"><font size="+1"><b>VD_setNWriteSeparate</b></font></td><td><font size="+1"><b>VE_setNWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_setNWriteSeparate</b></font></td><td width="33%"><font size="+1"><b>VCD_setNWriteSeparate</b></font></td><td><font size="+1"><b>VCE_setNWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_setNWriteSeparate</b></font></td><td width="33%"><font size="+1"><b>VPD_setNWriteSeparate</b></font></td><td><font size="+1"><b>VPE_setNWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VI_setNWriteSeparate</b></font></td><td width="33%"><font size="+1"><b>VBI_setNWriteSeparate</b></font></td><td><font size="+1"><b>VSI_setNWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VLI_setNWriteSeparate</b></font></td><td><font size="+1"><b>VQI_setNWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_setNWriteSeparate</b></font></td><td width="33%"><font size="+1"><b>VUB_setNWriteSeparate</b></font></td><td><font size="+1"><b>VUS_setNWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_setNWriteSeparate</b></font></td><td><font size="+1"><b>VUI_setNWriteSeparate</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Definition of the string to be used by the <I><a href="#nwrite">V.._nwrite</a></I> functions to separate table entries.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_setNWriteSeparate( char *SepString );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_setNWriteSeparate( SepString:PChar );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function defines the character string to be inserted between the columns of a table written by <I><a href="#nwrite">VF_nwrite</a></I>. <I>VF_setNWriteSeparate</I> does not influence the end of each line which is always a line-feed character (&quot;\n&quot; for C/C++ and #13 for Pascal/Delphi).
<BR>SepString may contain up to twelve characters. The default setting is a tab character (&quot;\t&quot; for C/C++ and #9 for Pascal/Delphi).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>In the case of <I>SepString</I> longer than twelve characters, the program is aborted with the error message &quot;Invalid Parameter(s)&quot;.
<BR>The contents of <I>SepString</I> is not checked.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#setWriteFormat">VF_setWriteFormat</a>,&nbsp;&nbsp; <a href="#setWriteSeparate">VF_setWriteSeparate</a>,&nbsp;&nbsp; <a href="#nwrite">VF_nwrite</a>,&nbsp;&nbsp; <a href="#nread">VF_nread</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setODThresh"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_setODThresh</b></font></td><td width="33%"><font size="+1"><b>VD_setODThresh</b></font></td><td><font size="+1"><b>VE_setODThresh</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_setODThresh</b></font></td><td width="33%"><font size="+1"><b>VUB_setODThresh</b></font></td><td><font size="+1"><b>VUS_setODThresh</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_setODThresh</b></font></td><td><font size="+1"><b>VQI_setODThresh</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Set the threshold for optical density calculation</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_setODThresh( float minX, float minX0 );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec&gt;
<BR>void vector&lt;T&gt;::setODThresh( T minX, T minX0 );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_setODThresh( minX, minX0:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>As described for <I><a href="#OD">VF_OD</a></I> and <I><a href="#ODwDark">VF_ODwDark</a></I>, the threshold below which input numbers for these functions are regarded as &quot;experimental noise&quot;, with the OD being set to 0.0, can be set to any positive number by <I>VF_setODThresh</I> etc.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#OD">VF_OD</a>,&nbsp;&nbsp; <a href="#ODwDark">VF_ODwDark</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setPlotRegion"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_setPlotRegion</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Defines a screen or printer-page region to be used by <I>VectorLib</I> plotting operations.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void V_setPlotRegion( int left, int top, int right, int bottom );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure V_setPlotRegion( left, top, right, bottom:Integer);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The rectangular region defined by the parameters, passed to <I>V_setPlotRegion</I>, will hold the coordinate system including all labels generated by future calls to <I>VectorLib</I> plotting functions such as <I><a href="#xyAutoPlot">VF_xyAutoPlot</a></I>. The parameters left, top, right, and bottom are in pixels, counting from the upper left corner of the screen or of the printer page.
<BR><I>V_setPlotRegion</I> has to be called after (!) <I><a href="#initPlot">V_initPlot</a></I> or <I><a href="#initPrint">V_initPrint</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#initPlot">V_initPlot</a>,&nbsp;&nbsp; <a href="#initPrint">V_initPrint</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setRadix"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_setRadix</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Define the radix for the whole-number read functions: C/C++ only!</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VIstd.h&gt;</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(or &lt;VSIstd.h&gt;, &lt;VLIstd.h&gt;, &lt;VUstd.h&gt;, ... *)
<BR><font face="courier new"> void V_setRadix( int radix );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>By default, the V..<I><a href="#read">_read</a></I> functions for the whole-number data types interpret all numbers as decimal numbers. <I>V_setRadix</I> allows to change this default behaviour.
<BR>The radix set by <I>V_setRadix</I> will be used in <I><a href="#read">VI_read</a>,&nbsp;&nbsp; <a href="#nread">VI_nread</a></I> and their <I>VBI_,&nbsp;&nbsp; VSI_,&nbsp;&nbsp; VLI_,&nbsp;&nbsp; VUB_,&nbsp;&nbsp; VUS_,&nbsp;&nbsp; VU_,&nbsp;&nbsp; VUL_</I>, and <I>VUL_</I> analogues. It does, however, not affect <I><a href="#read">VQI_read</a></I> or <I><a href="#nread">VQI_nread</a></I> (where the radix is always 10).
<P><I>radix</I> may take on values between 2 and 36 or 0.
<BR>In the case of <I>radix</I>=0, the basis of each number is determined at run-time:
<BR>All numbers beginning with the ciphers 1-9 are recognized as decimal numbers. All numbers beginning with &quot;0x&quot; are interpreted as hexadecimal and all numbers beginning with &quot;0&quot; without &quot;x&quot; are read as octal numbers.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>radix &lt; 0, radix=1, or radix &gt; 36 lead to a program abort with the error message &quot;Invalid Parameter(s)&quot;.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#read">VI_read</a>,&nbsp;&nbsp; <a href="#nread">VI_nread</a>,&nbsp;&nbsp; strtol,&nbsp;&nbsp; strtoul</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setRspEdit"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_setRspEdit</b></font></td><td width="33%"><font size="+1"><b>VD_setRspEdit</b></font></td><td><font size="+1"><b>VE_setRspEdit</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Modify the treatment of round-off errors in <I><a href="#convolve">VF_convolve</a></I> and <I><a href="#deconvolve">VF_deconvolve</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_setRspEdit( fComplex Trunc );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::setRspEdit( const complex&lt;T&gt;& Trunc );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_setRspEdit( Trunc:fComplex );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>In the functions <I><a href="#convolve">VF_convolve</a></I> and <I><a href="#deconvolve">VF_deconvolve</a></I>, a frequency filter is calculated by Fourier-transforming a given response function. The filter is then applied to a vector. Due to accumulated round-off, filter elements that should be zero may be not so, but contain small non-zero numbers.
<P>The maximum round-off error in the construction of Flt accumulates roughly to (size * big * prec), where big is the largest element of Flt and prec the relative floating-point precision. Any element smaller than that should be regarded as zero. In order to determine the exact threshold for the real and imaginary parts separately, the function uses the real and imaginary parts of Trunc, substituting them for prec in the above expression. Normally, you would choose
<BR>Trunc.Re = Trunc.Im, although a stricter (i.e. larger) value for Trunc.Im is also reasonable.
<P>By default, Trunc.Re = 16*EPSILON and Trunc.Im = 32*EPSILON, where EPSILON is the relative floating-point accuracy of the respective data type. (For C/C++, EPSILON is FLT_EPSILON, &nbsp;DBL_EPSILON, or LDBL_EPSILON, as defined in &lt;float.h&gt;).
<P>In order to switch the editing of the filter completely off, choose Trunc.Re = Trunc.Im = 0.
<P>During convolutions, the editing of the filter leads to slightly smoother results. During deconvolutions, the editing has also another meaning: for all &quot;lost&quot; frequencies (i.e., those for which the Fourier transform of the response function contains only numbers near zero), the filter is set to 0 instead of the inverse of these small numbers. Thereby, possible OVERFLOW and SING errors are avoided.
<P>To read the currently set threshold, call <I><a href="#getRspEdit">VF_getRspEdit</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#convolve">VF_convolve</a>,&nbsp;&nbsp; <a href="#deconvolve">VF_deconvolve</a>,&nbsp;&nbsp; <a href="#getRspEdit">VF_getRspEdit</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setSymbolSize"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>V_setSymbolSize</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Modify the size of the symbols used in plotting functions</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void V_setSymbolSize( float symsiz );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure V_setSymbolSize( symsize:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The size of the symbols used in the plotting functions <I><a href="#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#autoPlot">VCF_autoPlot</a></I>, etc., is modified by scaling with symsiz. To reset the symbol size to the default value, call <I>V_setSymbolSize</I> with symsiz=1.0. Note that it is not possible to make the symbols completely vanish (e.g., by setting symsiz = 0.0), since a minimum radius of one pixel is always secured. Useful values of symsiz range from about 0.5 to 5.0. Values above 50.0 are prohibited.
<P>When magnifying the symbols, you should also consider modifying the thickness of the connecting lines, if you are using any. See <I><a href="#setLineThickness">V_setLineThickness</a></I>.
<P>Note: An automatic scaling is always performed in order to maintain a constant relation between the symbol size and the overall size of the coordinate grid (which is especially important for Windows applications). The factor symsiz of this function scales the symbol size with respect to the automatically-found value. The automatic scaling cannot be switched off.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>DOS: &quot;silent&quot; correction of the input value.
<BR>Windows: A value of symsiz greater than 50.0 leads to a warning message &quot;Cannot scale symbols by more than a factor of 50.0&quot;. Program execution is continued with symsiz set to 50.0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#setLineThickness">V_setLineThickness</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setWriteFormat"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_setWriteFormat</b></font></td><td width="33%"><font size="+1"><b>VD_setWriteFormat</b></font></td><td><font size="+1"><b>VE_setWriteFormat</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_setWriteFormat</b></font></td><td width="33%"><font size="+1"><b>VCD_setWriteFormat</b></font></td><td><font size="+1"><b>VCE_setWriteFormat</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_setWriteFormat</b></font></td><td width="33%"><font size="+1"><b>VPD_setWriteFormat</b></font></td><td><font size="+1"><b>VPE_setWriteFormat</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VI_setWriteFormat</b></font></td><td width="33%"><font size="+1"><b>VBI_setWriteFormant</b></font></td><td><font size="+1"><b>VSI_setWriteFormat</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VLI_setWriteFormat</b></font></td><td><font size="+1"><b>VQI_setWriteFormat</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_setWriteFormat</b></font></td><td width="33%"><font size="+1"><b>VUB_setWriteFormat</b></font></td><td><font size="+1"><b>VUS_setWriteFormat</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_setWriteFormat</b></font></td><td><font size="+1"><b>VUI_setWriteFormat</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Definition of the format to be used by <I><a href="#write">V.._write</a></I> and <I><a href="#nwrite">V.._nwrite</a></I>: C/C++ only!</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_setWriteFormat( char *FormatString );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::setWriteFormat( char *FormatString );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The functions of the <I><a href="#write">VF_write</a></I> and <I><a href="#nwrite">VF_nwrite</a></I> families employ internally the ANSI C function <I>fprintf</I> in order to print numbers into a stream.
<BR>According to the rules described in the documentation of your C compiler's <I>printf</I> function, the format may be specified as fits your needs. When defining a write format, one should always be aware of the restrictions imposed by the read functions (not all formats you can write will be read correcly, see <I><a href="#read">VF_read</a></I>).
<P><I>VF_setWriteFormat</I> should not be used for the definition of whitespace before or after the numbers. This is the task of <I><a href="#setWriteSeparate">VF_setWriteSeparate</a></I>.
<P>For details about the formats used for each of the various data types, please refer to the following table. The last column of this table gives the maximum length of the format string.
<P><table border width="100%">
<tr valign="top"><td>Version</td><td>Standard Format</td><td>Alternative Example</td><td>max. length</td></tr>
<tr valign="top"><td><I>VF_</I></td><td>&quot;% 11.8e&quot;</td><td>&quot;% 8.4f&quot;</td><td>16</td></tr>
<tr valign="top"><td><I>VD_</I></td><td>&quot;% 19.16le&quot;</td><td>&quot;% 16.8lf&quot;</td><td>16</td></tr>
<tr valign="top"><td><I>VE_</I></td><td>&quot;% 22.19Le&quot;</td><td>&quot;% 22.19LG&quot;</td><td>16</td></tr>
<tr valign="top"><td><I>VCF_</I></td><td>&quot;% 11.8e, % 11.8e&quot;</td><td>&quot;{% 8.4f, % 8.4f}&quot;</td><td>32</td></tr>
<tr valign="top"><td><I>VCD_</I></td><td>&quot;% 19.16le, % 19.16le&quot;</td><td>&quot;{% 19.16lE % 19.16lE}&quot;</td><td>32</td></tr>
<tr valign="top"><td><I>VCE_</I></td><td>&quot;% 22.19Le, % 22.19Le&quot;</td><td>&quot;{% 22.19Lg % 22.19Lg}&quot;</td><td>32</td></tr>
<tr valign="top"><td><I>VPF_</I></td><td>&quot;% 11.8e @% 11.8e&quot;</td><td>&quot;{% 8.4f @% 8.4f}&quot;</td><td>32</td></tr>
<tr valign="top"><td><I>VPD_</I></td><td>&quot;% 19.16le @% 19.16le&quot;</td><td>&quot;{% 19.16lE @% 19.16lE}&quot;</td><td>32</td></tr>
<tr valign="top"><td><I>VPE_</I></td><td>&quot;% 22.19Le @% 22.19Le&quot;</td><td>&quot;{% 22.19Lg @% 22.19Lg}&quot;</td><td>32</td></tr>
<tr valign="top"><td><I>VI_</I></td><td>32-bit: &quot;% 10d&quot;
<BR>16-bit: &quot;% 5d&quot;</td><td>&quot;0x% 8x&quot;
<BR>&quot;0x% 4x&quot;</td><td>12<BR>12</td></tr>
<tr valign="top"><td><I>VBI_</I></td><td>&quot;% 3hd&quot;</td><td>&quot;0x% 2hX&quot;</td><td>12</td></tr>
<tr valign="top"><td><I>VSI_</I></td><td>&quot;% 5hd&quot;</td><td>&quot;0x% 4hX&quot;</td><td>12</td></tr>
<tr valign="top"><td><I>VLI_</I></td><td>&quot;% 10ld&quot;</td><td>&quot;%08lXh&quot;</td><td>12</td></tr>
<tr valign="top"><td><I>VQI_</I></td><td>&quot;% 20.0Lf&quot;</td><td></TD><td>16</td></tr>
<tr valign="top"><td><I>VU_</I></td><td>32-bit: &quot;% 10u&quot;<BR>16-bit &quot;% 5u&quot;</td><td>&quot;%04xh&quot;
<BR>&quot;%04xh&quot;</td><td>12<BR>12</td></tr>
<tr valign="top"><td><I>VUB_</I></td><td>&quot;% 3hu&quot;</td><td>&quot;0%02ho&quot;</td><td>12</td></tr>
<tr valign="top"><td><I>VUS_</I></td><td>&quot;% 5hu&quot;</td><td>&quot;0%04ho&quot;</td><td>12</td></tr>
<tr valign="top"><td><I>VUL_</I></td><td>&quot;% 10lu&quot;</td><td>&quot;0%08lO&quot;</td><td>12</td></tr></table>
<P>The data type quad is converted into extended before being passed to <I>fprintf</I> (which, at present, does not support quads). This explains why the format string in the <I>VQI_</I> version tells <I>fprintf</I> to expect a long double. Similarly, byte-sized integers are extended to 16-bit, so that the format specifier has to be for 16-bit numbers.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Format strings longer than the maximum length specified in the above table lead to a program abort with the error message &quot;Invalid Parameter(s)&quot;.
<BR>The contents of the format string is not checked. So you have to be very careful to specify a format which is valid for the respective data type.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#setWriteSeparate">VF_setWriteSeparate</a>,&nbsp;&nbsp; <a href="#write">VF_write</a>,&nbsp;&nbsp; <a href="#nwrite">VF_nwrite</a>,&nbsp;&nbsp; <a href="#read">VF_read</a>,&nbsp;&nbsp; <a href="#nread">VF_nread</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setWriteSeparate"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_setWriteSeparate</b></font></td><td width="33%"><font size="+1"><b>VD_setWriteSeparate</b></font></td><td><font size="+1"><b>VE_setWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_setWriteSeparate</b></font></td><td width="33%"><font size="+1"><b>VCD_setWriteSeparate</b></font></td><td><font size="+1"><b>VCE_setWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_setWriteSeparate</b></font></td><td width="33%"><font size="+1"><b>VPD_setWriteSeparate</b></font></td><td><font size="+1"><b>VPE_setWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VI_setWriteSeparate</b></font></td><td width="33%"><font size="+1"><b>VBI_setWriteSeparate</b></font></td><td><font size="+1"><b>VSI_setWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VLI_setWriteSeparate</b></font></td><td><font size="+1"><b>VQI_setWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_setWriteSeparate</b></font></td><td width="33%"><font size="+1"><b>VUB_setWriteSeparate</b></font></td><td><font size="+1"><b>VUS_setWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_setWriteSeparate</b></font></td><td><font size="+1"><b>VUI_setWriteSeparate</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Definition of the separation string used by V..<I><a href="#write">_write</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_setWriteSeparate( char *SepString );</font></td></tr>
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::setWriteSeparate( char *SepString );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_setWriteSeparate( SepString:PChar );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>By default, <I><a href="#write">VF_write</a></I> puts a line feed character after each vector element written into a stream. This means that each element gets its own line. You may use <I>VF_setWriteSeparate</I> to define another separation string. This may be, for example, a tab character (&quot;\t&quot; for C/C++ or #9 for Pascal/Delphi) or a series of spaces (e.g., &quot;&nbsp;&nbsp;&nbsp;&nbsp;&quot; for C/C++ or '&nbsp;&nbsp;&nbsp;&nbsp;' for Pascal/Delphi).
<P><I><a href="#write">VF_write</a></I> will insert the separation string only in between the vector elements. At the end, after the last element, there is always a line feed (&quot;\n&quot;) instead of the separation string.
<P>SepString may contain up to twelve characters.
<BR><u>C/C++ only:</u>
<BR>If you use <I><a href="#write">VF_write</a></I> with the output sent directly to the printer (stream = <I>stdprn</I>), you probably have to explicitly use a carriage return character in addition to the line feed. To do this, call
<BR><I>VF_setWriteSeparate</I>( &quot;\n\r&quot; );</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>In the case of SepString longer than twelve characters, the program is aborted with the error message &quot;Invalid Parameter(s)&quot;.
<BR>The contents of SepString is not checked.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#setWriteFormat">VF_setWriteFormat</a>,&nbsp;&nbsp; <a href="#setNWriteSeparate">VF_setNWriteSeparate</a>,&nbsp;&nbsp; <a href="#write">VF_write</a>,&nbsp;&nbsp; <a href="#read">VF_read</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sgn"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sgn</b></font></td><td width="33%"><font size="+1"><b>VD_sgn</b></font></td><td><font size="+1"><b>VE_sgn</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Signum function, compares each element of a vector with 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_sgn( fVector Y, fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::sgn( const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_sgn( Y, X:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of X is compared with 0 and the result of the comparison stored in Y:
<BR>Y<sub>i</sub> = +1.0, if X<sub>i</sub> &gt; 0
<BR>Y<sub>i</sub> = &nbsp;&nbsp;0.0, if X<sub>i</sub> = 0
<BR>Y<sub>i</sub> = &nbsp;-1.0, if X<sub>i</sub> &lt; 0.
<BR>This function is identical to <I><a href="#cmp0">VF_cmp0</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cmp_">VF_cmp_...</a>,&nbsp;&nbsp; <a href="#cmpC">VF_cmpC</a>,&nbsp;&nbsp; <a href="#cmpV">VF_cmpV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="shl"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_shl</b></font></td><td width="20%"><font size="+1"><b>VBI_shl</b></font></td><td width="20%"><font size="+1"><b>VSI_shl</b></font></td><td width="20%"><font size="+1"><b>VLI_shl</b></font></td><td><font size="+1"><b>VQI_shl</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_shl</b></font></td><td width="20%"><font size="+1"><b>VUB_shl</b></font></td><td width="20%"><font size="+1"><b>VUS_shl</b></font></td><td width="20%"><font size="+1"><b>VUL_shl</b></font></td><td><font size="+1"><b>VUI_shl</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;Shift to the left&quot;, i.e. multiply by integer powers of 2.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VImath.h&gt;
<BR>void VI_shl( iVector Y, iVector X, ui size, unsigned C );
<BR>void VUL_shl( ulVector Y, ulVector X, ui size, unsigned C );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::shl( const vector&lt;T&gt;& X, unsigned C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VImath;
<BR>procedure VI_shl( Y, X:iVector; size:UInt; C:UInt );
<BR>procedure VUL_shl( Y, X:ulVector; size:UInt; C:UInt );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>i</sub> &lt;&lt; C
<BR>All bits of X<sub>i</sub> are shifted to the left by as many positions as indicated in the parameter C. This corresponds to a multiplication by 2<sup>C</sup>, neglecting possible overflow (in all versions) and loss of the sign bit (for signed numbers, i.e. in the <I>VI_,&nbsp;&nbsp; VBI_,&nbsp;&nbsp; VSI_,&nbsp;&nbsp; VLI_</I>, and <I>VQI_</I> versions).
<BR>Note that by shifting 8-bit numbers (<I>VBI_,&nbsp;&nbsp; VUB_</I> versions) by more than 7 positions, any non-zero bit present in the original number is lost and the result is 0. The same is true for 16-bit numbers (<I>VSI_,&nbsp;&nbsp; VUS_</I> versions) shifted by more than 15 positions, and for 32-bit numbers (<I>VLI_</I>, VUL_) shifted by more than 31 positions.
<BR>C is always of the data type unsigned. Shifting by negative numbers C is, therefore, not possible. To perform a right-shift, the appropriate function of the <I><a href="#shr">VI_shr</a></I> family has to be used.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mulC">VI_mulC</a>,&nbsp;&nbsp; <a href="#shr">VI_shr</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="shr"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_shr</b></font></td><td width="20%"><font size="+1"><b>VBI_shr</b></font></td><td width="20%"><font size="+1"><b>VSI_shr</b></font></td><td width="20%"><font size="+1"><b>VLI_shr</b></font></td><td><font size="+1"><b>VQI_shr</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_shr</b></font></td><td width="20%"><font size="+1"><b>VUB_shr</b></font></td><td width="20%"><font size="+1"><b>VUS_shr</b></font></td><td width="20%"><font size="+1"><b>VUL_shr</b></font></td><td><font size="+1"><b>VUI_shr</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;Shift to the right&quot;, i.e., divide by integer powers of 2.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VImath.h&gt;
<BR>void VI_shr( iVector Y, iVector X, ui size,unsigned C );
<BR>void VUL_shr( ulVector Y, ulVector X, ui size, unsigned C );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::shr( const vector&lt;T&gt;& X, unsigned C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VImath;
<BR>procedure VI_shr( Y, X:iVector; size:UInt; C:UInt );
<BR>procedure VUL_shr( Y, X:ulVector; size:UInt; C:UInt );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>i</sub> &gt;&gt; C
<BR>All bits of X<sub>i</sub> are shifted to the right by as many positions as indicated in the parameter C. This corresponds to an integer division by 2<sup>C</sup>. The sign of Y<sub>i</sub> is always the same as of X<sub>i</sub>. In contrast to explicit integer divisions, the result is always rounded toward minus infinity: -15 / 2 = -7, but -15 &gt;&gt; 1 = -8.
<BR>Note that by shifting 8-bit numbers by more than 7 positions, any unsigned or positive number yields 0, whereas any negative number yields -1 in this case.
<BR>The same is true for 16-bit numbers upon shifting by more than 15 positions, and for 32-bit numbers being shifted by more than 31 positions.
<P>C is always of the data type unsigned. Shifting by negative numbers C is, therefore, not possible. To perform a left-shift, the appropriate function of the <I><a href="#shl">VI_shl</a></I> family has to be used.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#divC">VI_divC</a>,&nbsp;&nbsp; <a href="#shl">VI_shl</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sin"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sin</b></font></td><td width="33%"><font size="+1"><b>VD_sin</b></font></td><td><font size="+1"><b>VE_sin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_sin</b></font></td><td width="33%"><font size="+1"><b>VDx_sin</b></font></td><td><font size="+1"><b>VEx_sin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFr_sin</b></font></td><td width="33%"><font size="+1"><b>VDr_sin</b></font></td><td><font size="+1"><b>VEr_sin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFrx_sin</b></font></td><td width="33%"><font size="+1"><b>VDrx_sin</b></font></td><td><font size="+1"><b>VErx_sin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_sin</b></font></td><td width="33%"><font size="+1"><b>VCD_sin</b></font></td><td><font size="+1"><b>VCE_sin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_sin</b></font></td><td width="33%"><font size="+1"><b>VCDx_sin</b></font></td><td><font size="+1"><b>VCEx_sin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sine function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sin( fVector Y, fVector X, ui size );
<BR>int VFx_sin( fVector Y, fVector X, ui size, float A, float B, float C );
<BR>int VFr_sin( fVector Y, fVector X, ui size );
<BR>int VFrx_sin( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sin( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_sin( const vector&lt;T&gt;& X, T A, T B, T C );
<BR>int vector&lt;T&gt;::r_sin( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::rx_sin( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sin( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_sin( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;
<BR>function VFr_sin( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFrx_sin( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = sin( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * sin( A*X<sub>i</sub>+B )
<BR>For large values of X<sub>i</sub>, round-off error becomes appreciable; if the X<sub>i</sub> values are representable as fractional multiples of <font face="symbol">p</font>, it is better to use <I><a href="#sinrpi">VF_sinrpi</a></I> than <I>VF_sin</I>.
<BR>If, on the other hand, one can be sure that all X<sub>i</sub> are within the range -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT>, one can employ the faster reduced-range versions with the prefixes <I>VFr_</I> and <I>VFrx_</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Precision errors lead to a default result of 0.0 and a non-zero return value, but are ignored otherwise; <I>_matherr</I> is not called.
<BR>OVERFLOW errors can only occur in the complex versions and lead to a result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sin2">VF_sin2</a>,&nbsp;&nbsp; <a href="#sinrpi">VF_sinrpi</a>,&nbsp;&nbsp; <a href="#cos">VF_cos</a>,&nbsp;&nbsp; <a href="#sinh">VF_sinh</a>,&nbsp;&nbsp; <a href="#asin">VF_asin</a>,&nbsp;&nbsp; sin</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sin2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sin2</b></font></td><td width="33%"><font size="+1"><b>VD_sin2</b></font></td><td><font size="+1"><b>VE_sin2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_sin2</b></font></td><td width="33%"><font size="+1"><b>VDx_sin2</b></font></td><td><font size="+1"><b>VEx_sin2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFr_sin2</b></font></td><td width="33%"><font size="+1"><b>VDr_sin2</b></font></td><td><font size="+1"><b>VEr_sin2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFrx_sin2</b></font></td><td width="33%"><font size="+1"><b>VDrx_sin2</b></font></td><td><font size="+1"><b>VErx_sin2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Square of the sine function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sin2( fVector Y, fVector X, ui size );
<BR>int VFx_sin2( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sin2( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_sin2( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sin2( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_sin2( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = sin<sup>2</sup>( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * sin<sup>2</sup>( A*X<sub>i</sub>+B )
<BR>Calculating the squared trigonometric functions directly is faster and sometimes more accurate than first calculating the trigonometric function itself and squaring it afterwards. The reduced-range versions with the prefixes <I>VFr_</I> and <I>VFrx_</I> are for situations in which one can be sure that all input values lie in the range -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Precision errors lead to a default result of 0.0 and a non-zero return value, but are otherwise ignored; <I>_matherr</I> is not called.
<BR>OVERFLOW errors can only occur in the complex versions and lead to a result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sin">VF_sin</a>,&nbsp;&nbsp; <a href="#sinrpi">VF_sinrpi</a></I>,&nbsp;&nbsp;sin</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sinc"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sinc</b></font></td><td width="33%"><font size="+1"><b>VD_sinc</b></font></td><td><font size="+1"><b>VE_sinc</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_sinc</b></font></td><td width="33%"><font size="+1"><b>VDx_sinc</b></font></td><td><font size="+1"><b>VEx_sinc</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sinc function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sinc( fVector Y, fVector X, ui size );
<BR>int VFx_sinc( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sinc( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_sinc( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sinc( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_sinc( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = sinc( X<sub>i</sub> ) = sin( X<sub>i</sub> ) / X<sub>i</sub>
<BR>expanded versions: Y<sub>i</sub> = C * sinc( A*X<sub>i</sub>+B )
<BR>The sinc function for an argument of 0.0 is defined as 1.0. The sinc function is the Fourier transform of a square pulse and is used, for example, to describe the diffraction pattern of a slit.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>These functions should be error-proof.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sin">VF_sin</a>,&nbsp;&nbsp; <a href="#sinrpi">VF_sinrpi</a>,&nbsp;&nbsp; sin</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sincos"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sincos</b></font></td><td width="33%"><font size="+1"><b>VD_sincos</b></font></td><td><font size="+1"><b>VE_sincos</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_sincos</b></font></td><td width="33%"><font size="+1"><b>VDx_sincos</b></font></td><td><font size="+1"><b>VEx_sincos</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFr_sincos</b></font></td><td width="33%"><font size="+1"><b>VDr_sincos</b></font></td><td><font size="+1"><b>VEr_sincos</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFrx_sincos</b></font></td><td width="33%"><font size="+1"><b>VDrx_sincos</b></font></td><td><font size="+1"><b>VErx_sincos</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sine and Cosine simultaneously</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sincos( fVector YSin, fVector YCos, fVector X, ui size );
<BR>int VFx_sincos( fVector YSin, fVector YCos, fVector X, ui size, float A, float B, float C );
<BR>int VFr_sincos( fVector YSin, fVector YCos, fVector X, ui size );
<BR>int VFrx_sincos( fVector YSin, fVector YCos, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sincos( const vector&lt;T&gt; YCos, const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_sincos( vector&lt;T&gt; YCos, const vector&lt;T&gt;& X, T A, T B, T C );
<BR>int vector&lt;T&gt;::r_sincos( vector&lt;T&gt; YCos, const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::rx_sincos( vector&lt;T&gt; YCos, const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sincos( Sin, Cos, X:fVector; size:UInt ): IntBool;
<BR>function VFx_sincos( Sin, Cos, X:fVector; size:UInt; A, B, C:Single ): IntBool;
<BR>function VFr_sincos( Sin, Cos, X:fVector; size:UInt ): IntBool;
<BR>function VFrx_sincos( Sin, Cos, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: 
<BR>YSin<sub>i</sub> = sin( X<sub>i</sub> )
<BR>YCos<sub>i</sub> = cos( X<sub>i</sub> )
<BR>expanded versions: 
<BR>YSin<sub>i</sub> = C * sin( A*X<sub>i</sub>+B )
<BR>YCos<sub>i</sub> = C * cos( A*X<sub>i</sub>+B )
<BR>The sine and the cosine are calculated simultaneously, which is far more efficient than calculating them separately if both of them are needed. For large values of X<sub>i</sub>, round-off error becomes appreciable; if the X<sub>i</sub> values are representable as fractional multiples of <font face="symbol">p</font>, it is better to use <I><a href="#sincosrpi">VF_sincosrpi</a></I> than <I>VF_sincos</I>.
<BR>If, on the other hand, one can be sure that all X<sub>i</sub> are within the range -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT>, one can employ the faster reduced-range versions with the prefixes <I>VFr_</I> and <I>VFrx_</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Precision errors lead to a result of 0.0 for the sine and 1.0 for the cosine (as if the input were 0.0) along with a non-zero return value, but are otherwise ignored; <I>_matherr</I> is not called. Other errors should not occur.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sincos2">VF_sincos2</a>,&nbsp;&nbsp; <a href="#sincosrpi">VF_sincosrpi</a>,&nbsp;&nbsp; sin,&nbsp;&nbsp; cos</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sincos2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sincos2</b></font></td><td width="33%"><font size="+1"><b>VD_sincos2</b></font></td><td><font size="+1"><b>VE_sincos2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_sincos2</b></font></td><td width="33%"><font size="+1"><b>VDx_sincos2</b></font></td><td><font size="+1"><b>VEx_sinco2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFr_sincos2</b></font></td><td width="33%"><font size="+1"><b>VDr_sincos2</b></font></td><td><font size="+1"><b>VEr_sincos2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFrx_sincos2</b></font></td><td width="33%"><font size="+1"><b>VDrx_sincos2</b></font></td><td><font size="+1"><b>VErx_sinco2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Square of the sine and of the cosine simultaneously</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sincos2( fVector YSin2, fVector YCos2, fVector X, ui size );
<BR>int VFx_sincos2( fVector YSin2, fVector YCos2, fVector X, ui size, float A, float B, float C );
<BR>int VFr_sincos2( fVector YSin, fVector YCos, fVector X, ui size );
<BR>int VFrx_sincos2(fVector YSin, fVector YCos, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sincos2( vector&lt;T&gt; YCos2, const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_sincos2( vector&lt;T&gt; YCos2, const vector&lt;T&gt;& X, T A, T B, T C );
<BR>int vector&lt;T&gt;::r_sincos2( vector&lt;T&gt; YCos, const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::rx_sincos2( vector&lt;T&gt; YCos, const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sincos2( Sin, Cos, X:fVector; size:UInt ): IntBool;
<BR>function VFx_sincos2( Sin, Cos, X:fVector; size:UInt; A, B, C:Single ): IntBool;
<BR>function VFr_sincos2( Sin, Cos, X:fVector; size:UInt ): IntBool;
<BR>function VFrx_sincos2(Sin, Cos, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: 
<BR>YSin2<sub>i</sub> = sin<sup>2</sup>( X<sub>i</sub> )
<BR>YCos2<sub>i</sub> = cos<sup>2</sup>( X<sub>i</sub> )
<BR>expanded versions: 
<BR>YSin2<sub>i</sub> = C * sin<sup>2</sup>( A*X<sub>i</sub>+B )
<BR>YCos2<sub>i</sub> = C * cos<sup>2</sup>( A*X<sub>i</sub>+B )
<BR>The squared sine and the squared cosine are calculated simultaneously, which is far more efficient than calculating them separately, if both of them are needed.
<BR>The reduced-range versions with the prefixes <I>VFr_</I> and <I>VFrx_</I> are for situations in which one can be sure that all input values lie in the range -2<FONT FACE="Symbol">p</FONT> &lt;= X<sub>i</sub> &lt;= +2<FONT FACE="Symbol">p</FONT>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Precision errors lead to a result of 0.0 for the sin<sup>2</sup> and of 1.0 for the cos<sup>2</sup> (as if the input were 0.0) along with a non-zero return value, but are otherwise ignored; <I>_matherr</I> is not called. Other errors should not occur.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sincos">VF_sincos</a>,&nbsp;&nbsp; sin,&nbsp;&nbsp; cos</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sincosrpi"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sincosrpi</b></font></td><td width="33%"><font size="+1"><b>VD_sincosrpi</b></font></td><td><font size="+1"><b>VE_sincosrpi</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sincosrpi2</b></font></td><td width="33%"><font size="+1"><b>VD_sincosrpi2</b></font></td><td><font size="+1"><b>VE_sincosrpi2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sincosrpi3</b></font></td><td width="33%"><font size="+1"><b>VD_sincosrpi3</b></font></td><td><font size="+1"><b>VE_sincosrpi3</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sine and cosine of fractional multiples of <font face="symbol">p</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sincosrpi( fVector YSin, fVector YCos, iVector P, ui size, int q );
<BR>int VF_sincosrpi2( fVector YSin, fVector YCos, iVector P, ui size, int q );
<BR>int VF_sincosrpi3( fVector YSin, fVector YCos, iVector P, ui size, int q );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sincosrpi( vector&lt;T&gt; YCos, const vector&lt;int&gt;& P, int q );
<BR>int vector&lt;T&gt;::sincosrpi2( vector&lt;T&gt; YCos, const vector&lt;int&gt;& P, int q );
<BR>int vector&lt;T&gt;::sincosrpi3( vector&lt;T&gt; YCos, const vector&lt;int&gt;& P, int q );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sincosrpi( Sin, Cos:fVector; P:iVector; size:UInt; q:Integer ): IntBool;
<BR>function VF_sincosrpi2( Sin, Cos:fVector; P:iVector; size:UInt; q:Integer ): IntBool;
<BR>function VF_sincosrpi3( Sin, Cos:fVector; P:iVector; size:UInt; q:Integer ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>YSin<sub>i</sub> = sin( (P<sub>i</sub> / q) * <font face="symbol">p</font> )
<BR>YCos<sub>i</sub> = cos( (P<sub>i</sub> / q) * <font face="symbol">p</font> )
<BR>The sine and the cosine of fractional multiples of <font face="symbol">p</font> are calculated. There are three versions: <I>VF_sincosrpi</I> is for general use with any arbitrary denominator q. If q is a power of 2, <I>VF_sincosrpi2</I> should be used which is a highly optimized version reading the results from a table named <I><a href="#sintab2">VF_sintab2</a></I>, if possible. If q is a multiple of 3, <I>VF_sincosrpi3</I> should be used which utilizes a table named <I><a href="#sintab2">VF_sintab3</a></I>. The use of <I>VF_sincosrpi3</I> is a convenient way to use degrees instead of radians; if, for example, q is 180, then the unit of the elements of P is &quot;degree&quot;. <I>VF_sincosrpi2</I> and <I>VF_sincosrpi3</I> work also with q values they are not optimized for; in this case, however, memory space is wasted for the (then useless) tables.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>These functions should be error-proof, as long as q!=0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sincos">VF_sincos</a>,&nbsp;&nbsp; sin,&nbsp;&nbsp; cos</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sinh"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sinh</b></font></td><td width="33%"><font size="+1"><b>VD_sinh</b></font></td><td><font size="+1"><b>VE_sinh</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_sinh</b></font></td><td width="33%"><font size="+1"><b>VCD_sinh</b></font></td><td><font size="+1"><b>VCE_sinh</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_sinh</b></font></td><td width="33%"><font size="+1"><b>VDx_sinh</b></font></td><td><font size="+1"><b>VEx_sinh</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_sinh</b></font></td><td width="33%"><font size="+1"><b>VCDx_sinh</b></font></td><td><font size="+1"><b>VCEx_sinh</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Hyperbolic sine function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sinh( fVector Y, fVector X, ui size );
<BR>int VFx_sinh( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sinh( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_sinh( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sinh( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_sinh( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = sinh( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * sinh ( A*X<sub>i</sub>+B )</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of &#177;HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cosh">VF_cosh</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; sinh</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sinrpi"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sinrpi</b></font></td><td width="33%"><font size="+1"><b>VD_sinrpi</b></font></td><td><font size="+1"><b>VE_sinrpi</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sinrpi2</b></font></td><td width="33%"><font size="+1"><b>VD_sinrpi2</b></font></td><td><font size="+1"><b>VE_sinrpi2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sinrpi3</b></font></td><td width="33%"><font size="+1"><b>VD_sinrpi3</b></font></td><td><font size="+1"><b>VE_sinrpi3</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sine function of fractional multiples of <font face="symbol">p</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sinrpi( fVector Y, iVector P, ui size, int q );
<BR>int VF_sinrpi2( fVector Y, iVector P, ui size, int q );
<BR>int VF_sinrpi3( fVector Y, iVector P, ui size, int q );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sinrpi( const vector&lt;int&gt;& P, int q );
<BR>int vector&lt;T&gt;::sinrpi2( const vector&lt;int&gt;& P, int q );
<BR>int vector&lt;T&gt;::sinrpi3( const vector&lt;int&gt;& P, int q );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sinrpi( Y:fVector; P:iVector; size:UInt; q:Integer ): IntBool;
<BR>function VF_sinrpi2( Y:fVector; P:iVector; size:UInt; q:Integer ): IntBool;
<BR>function VF_sinrpi3( Y:fVector; P:iVector; size:UInt; q:Integer ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = sin( (P<sub>i</sub> / q) * <font face="symbol">p</font> )
<BR>The sine of fractional multiples of <font face="symbol">p</font> is calculated. There are three versions: <I>VF_sinrpi</I> is for general use with any arbitrary denominator q. If q is a power of 2, <I>VF_sinrpi2</I> should be used which is a highly optimized version reading the results from a look-up table, if possible. If q is a multiple of 3, <I>VF_sinrpi3</I> should be used. <I>VF_sinrpi3</I> offers a convenient way to use degrees instead of radians; if, for example, q is 180, then the unit of the elements of P is &quot;degree&quot;. <I>VF_sinrpi2</I> and <I>VF_sinrpi3</I> work also with q values they are not optimized for; in this case, however, memory space is wasted for the tables.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>These functions should be error-proof, as long as q!=0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sin">VF_sin</a>,&nbsp;&nbsp; sin</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sintab2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sintab2</b></font></td><td width="33%"><font size="+1"><b>VD_sintab2</b></font></td><td><font size="+1"><b>VE_sintab2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sintab3</b></font></td><td width="33%"><font size="+1"><b>VD_sintab3</b></font></td><td><font size="+1"><b>VE_sintab3</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">&nbsp;</TD><td>Table of sine values for arguments between 0 and <font face="symbol">p</font>/2</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;xmath.h&gt;
<BR>extern float&nbsp;&nbsp;&nbsp;&nbsp;VF_sintab2[ VF_tabsz2+1 ];
<BR>extern double&nbsp;&nbsp;&nbsp;VD_sintab2[ VD_tabsz2+1 ];
<BR>extern extended&nbsp;VE_sintab2[ VE_tabsz2+1 ];
<BR>extern float&nbsp;&nbsp;&nbsp;&nbsp;VF_sintab3[ VF_tabsz3+1 ];
<BR>extern double&nbsp;&nbsp;&nbsp;VD_sintab3[ VD_tabsz3+1 ];
<BR>extern extended&nbsp;VE_sintab3[ VE_tabsz3+1 ];</font>
<BR></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses FSINTAB2, DSINTAB2, ESINTAB2,
FSINTAB3, DSINTAB3, ESINTAB3;
<BR>VF_sintab2: array[0..VF_tabsz2] of Single;
<BR>VD_sintab2: array[0..VD_tabsz2] of Double;
<BR>VE_sintab2: array[0..VE_tabsz2] of Extended;
<BR>VF_sintab3: array[0..VF_tabsz3] of Single;
<BR>VD_sintab3: array[0..VD_tabsz3] of Double;
<BR>VE_sintab3: array[0..VE_tabsz3] of Extended;</font><BR></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>VF_sintab2[ i ] = sin( i/(2*VF_tabsz2) * <font face="symbol">p</font> ), &nbsp;&nbsp;&nbsp;&nbsp;i=0,...,VF_tabsz2
<BR>VF_sintab3[ i ] = sin( i/(2*VF_tabsz3) * <font face="symbol">p</font> ), &nbsp;&nbsp;&nbsp;&nbsp;i=0,...,VF_tabsz3
<BR>These look-up tables of sine values for arguments between 0 and <font face="symbol">p</font>/2 are used by <I><a href="#sinrpi">VF_sinrpi2</a></I> and the other functions of that family and are also available for other purposes.
<BR>C/C++: The symbols VF_tabsz2 etc., denoting the size of the tables, are defined in &lt;xmath.h&gt;.
<BR>Pascal/Delphi: The symbols VF_tabsz2 etc. are defined in the same units as the tables themselves.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sinrpi">VF_sinrpi2</a>,&nbsp;&nbsp; <a href="#tantab2">VF_tantab2</a>,&nbsp;&nbsp; <a href="#cosectab2">VF_cosectab2</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="smooth"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_smooth</b></font></td><td width="33%"><font size="+1"><b>VD_smooth</b></font></td><td><font size="+1"><b>VE_smooth</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Data smoothing</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_smooth( fVector Y, fVector X, ui size, unsigned deg);</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::smooth( const vector&lt;T&gt;& X, unsigned deg );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_smooth( Y,X:fVector; size, deg: UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A primitive, but very fast low-frequency filtering of the vector X is performed. For each point, a weighted average of the point itself and its one or few nearest neighbours is calculated. The argument deg decides how many points are taken into accout. E.g., deg=3 means 3-point smoothing by the formula:
<BR>Y<sub>i</sub> = 0.25 * (2*X<sub>i</sub> + X<sub>i-1</sub> + X<sub>i+1</sub>)
<BR>Higher degrees (5, 7, 9...) of smoothing are achieved internally by repeated 3-point smoothing. deg = 0 or 1 means no smoothing at all; deg = 2 or 3 is interpreted as 3-point smoothing, deg = 4 or 5 as 5-point smoothing, and so on.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#filter">VF_filter</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sort"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sort</b></font></td><td width="33%"><font size="+1"><b>VD_sort</b></font></td><td><font size="+1"><b>VE_sort</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_sort</b></font></td><td width="20%"><font size="+1"><b>VBI_sort</b></font></td><td width="20%"><font size="+1"><b>VSI_sort</b></font></td><td width="20%"><font size="+1"><b>VLI_sort</b></font></td><td><font size="+1"><b>VQI_sort</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_sort</b></font></td><td width="20%"><font size="+1"><b>VUB_sort</b></font></td><td width="20%"><font size="+1"><b>VUS_sort</b></font></td><td width="20%"><font size="+1"><b>VUL_sort</b></font></td><td><font size="+1"><b>VUI_sort</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sorting into ascending or descending order</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_sort( fVector Y, fVector X, ui size, int dir );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::sort( const vector&lt;T&gt;& X, int dir=1 );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_sort( Y, X:fVector; size:UInt; dir:Integer );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector is sorted in ascending order, if dir is positive; negative dir yields descending order. The present implementation uses the &quot;Heapsort&quot; algorithm.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sortind">VF_sortind</a>,&nbsp;&nbsp; <a href="#rotate">VF_rotate</a>,&nbsp;&nbsp; <a href="#rev">VF_rev</a>,&nbsp;&nbsp; qsort</I> (C/C++ only)</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sortind"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sortind</b></font></td><td width="33%"><font size="+1"><b>VD_sortind</b></font></td><td><font size="+1"><b>VE_sortind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_sortind</b></font></td><td width="20%"><font size="+1"><b>VBI_sortind</b></font></td><td width="20%"><font size="+1"><b>VSI_sortind</b></font></td><td width="20%"><font size="+1"><b>VLI_sortind</b></font></td><td><font size="+1"><b>VQI_sortind</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_sortind</b></font></td><td width="20%"><font size="+1"><b>VUB_sortind</b></font></td><td width="20%"><font size="+1"><b>VUS_sortind</b></font></td><td width="20%"><font size="+1"><b>VUL_sortind</b></font></td><td><font size="+1"><b>VUI_sortind</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sort the index-array of a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_sortind( uiVector Ind, fVector X, ui size, int dir );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;ui&gt;::sortind( const vector&lt;T&gt;& X, int dir=1 );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_sortind( Ind:uVector; X:fVector; size:UInt; dir:Integer );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The routine is similar to <I><a href="#sort">VF_sort</a></I>, but this time it is the index-array of X rather than the vector X itself that is ordered. Ascending order is obtained by setting dir to any positive number. Here, ascending order means that Ind<sub>0</sub> will contain the index of the smallest element of X, Ind<sub>1</sub> the index of the second-smallest, and so on, up to Ind<sub>size-1</sub>, the index of the largest element in X. Descending order is obtained by setting dir negative. This routine is used if other vectors are correlated with X and the correlation of the individual elements has to be maintained. After sorting the index-array, use <I><a href="#indpick">VF_indpick</a></I> (<I>VD_indpick,&nbsp;&nbsp; VI_indpick</I>, etc.) to actually perform the sorting of X and the other vectors correlated with X.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sort">VF_sort</a>,&nbsp;&nbsp; <a href="#indpick">VF_indpick</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="spectrum"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_spectrum</b></font></td><td width="33%"><font size="+1"><b>VD_spectrum</b></font></td><td><font size="+1"><b>VE_spectrum</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Power-density spectrum</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_spectrum( fVector Spc, ui specsiz, fVector X, ui xsiz, fVector Win );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::spectrum( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Win );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_spectrum( Spc:fVector; specsiz:UInt; X:fVector; xsiz:UInt; Win:fVector ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The data set X is analyzed for its power spectral density (PSD), i.e. the mean square amplitude. The result is stored in Spc. xsiz must be at least 2*specsiz, and specsiz has to be an integer power of 2. Internally, X is divided into xsiz*specsiz/2 segments and the average over the spectra of the individual segments is calculated. Each segment of length 2*specsiz yields the PSD for specsiz+1 frequencies (see <I><a href="#FFT">VF_FFT</a></I>). In order to keep specsiz an integer power of 2, there are only specsiz points stored in Spc and the last one, the PSD at the Nyquist frequency <I>f<sub>Nyquist</sub></I> = 0.5 / <I>sampling_interval</I>, is given as the return value of the function. It may either be neglected (by calling the function like a void function) or stored as the last element in Spc by calling the function as
<BR><font face="courier new">Spc[specsiz] = VF_spectrum( Spc, specsiz, X, xsiz, Win );</font>
<BR>in this case, Spc must have a length of specsiz+1.
<P>Win is a window that is applied to the data segments. The size of the Win vector must be 2*specsiz. Within the <I>VectorLib</I> library, three functions are available that give suitable Windows: <I><a href="#Welch">VF_Welch</a>,&nbsp;&nbsp; <a href="#Parzen">VF_Parzen</a></I>, and <I><a href="#Hanning">VF_Hanning</a></I>. A square window (i.e. no windowing at all) is achieved by setting all elements of Win to 1.0 using <I><a href="#equ1">VF_equ1</a></I>. Use of the square window is not recommended here, though.
<P>You may wish to test the quality of the calculated spectrum by applying Parseval's theorem (provided you called <I>VF_spectrum</I> as in the above example and stored the PSD for the Nyquist frequency):
<BR>1.0/xsize * <I><a href="#ssq">VF_ssq</a></I>( X, xsize ) must be about equal to <I><a href="#sum">VF_sum</a></I>( Spc, specsiz+1 ).
<BR>If the deviation between both results is large, the sampling interval in X probably is too large.
<P>About special versions with the prefixes <I>VFs_</I> and <I>VFl_</I>, consult <a href="HANDBOOK.HTM#chap4_8">chapter&nbsp;4.8.</a></td></tr>
<tr valign="TOP">
<td>Example C/C++ (for DOS):</td><td><font face="courier new" size="-1">#include &lt;VFstd.h&gt;
<BR>#include &lt;VFmath.h&gt;
<BR>#include &lt;Vgraph.h&gt;
<BR>#include &lt;math.h&gt;
<BR>#include &lt;conio.h&gt;
<BR>void main( void )
<BR>{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;fVector X, Spc, Win, Time, Freq;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;float deltat, fOscill, fNyquist;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;ui xsize=4096, specsiz=256;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;X = <a href="#vector">VF_vector</a>( xsize );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Spc = VF_vector( specsiz+1 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Win = VF_vector( 2*specsiz );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Time = VF_vector( xsize );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Freq = VF_vector( specsiz+1);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;deltat = 0.001;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* sampling interval 1 millisecond */
<BR>&nbsp;&nbsp;&nbsp;&nbsp;fNyquist = 0.5 / deltat;  &nbsp; /* Nyquist frequency = 500 Hz */
<BR>&nbsp;&nbsp;&nbsp;&nbsp;fOscill = 100;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* say we are sampling a 100 Hz oscillation */
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ramp">VF_ramp</a>( Time, xsize, 0, deltat );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;VF_ramp( Freq, specsiz+1, 0, fNyquist / specsiz );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sin">VFx_sin</a>( X, Time, xsize, 2*M_PI*fOscill, 0, 1 ); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* sine wave (omega*t) */
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cmpC">VF_cmpC</a>( X, X, xsize, 0.7 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* convert into asymmetric square wave */
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Welch">VF_Welch</a>( Win, 2*specsiz ); /* or another window */
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Spc[specsiz] = VF_spectrum( Spc, specsiz, X, xsize, Win );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#initGraph">V_initGraph</a>( &quot;\\BorlandC\\BGI\\&quot; );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* give the correct BGI path! */
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#xyAutoPlot">VF_xyAutoPlot</a>( Freq, Spc, specsiz+1,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PS_SOLID | SY_CROSS, GREEN );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;getch(); /* hit any key when you have seen enough */
<BR>&nbsp;&nbsp;&nbsp;&nbsp;closegraph();
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#nfree">V_nfree</a>( 5, Freq, Time, Win, Spc, X );
<BR>}</font></td></tr>
<tr valign="TOP">
<td>Example Pascal/Delphi:</td><td><font face="courier new" size="-1">
uses VFstd, VFmath, Vgraph,...;
<BR>const
<BR>&nbsp;&nbsp;&nbsp;&nbsp;xsize=4096; specsiz=256;
<BR>var
<BR>&nbsp;&nbsp;&nbsp;&nbsp;X, Spc, Win, Time, Freq: fVector;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;deltat, fOscill, fNyquist: Single;
<BR>begin
<BR>&nbsp;&nbsp;&nbsp;&nbsp;X := <a href="#vector">VF_vector</a>( xsize );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Spc := VF_vector( specsiz+1 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Win := VF_vector( 2*specsiz );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Time := VF_vector( xsize );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Freq := VF_vector( specsiz+1);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;deltat := 0.001;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(* sampling interval 1 millisecond *)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;fNyquist := 0.5 / deltat;   &nbsp;(* Nyquist frequency = 500 Hz *)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;fOscill := 100;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(* say we are sampling a 100 Hz oscillation *)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ramp">VF_ramp</a>( Time, xsize, 0, deltat );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;VF_ramp( Freq, specsiz+1, 0, fNyquist / specsiz );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sin">VFx_sin</a>( X, Time, xsize, 2*PI*fOscill, 0, 1 ); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* sine wave (omega*t) *)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cmpC">VF_cmpC</a>( X, X, xsize, 0.7 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(* convert into an asymmetric square wave *)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Welch">VF_Welch</a>( Win, 2*specsiz ); (* or another window *)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Pelement">VF_Pelement</a>( Spc,specsiz )^ :=
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VF_spectrum( Spc, specsiz, X, xsize, Win );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#xyAutoPlot">VF_xyAutoPlot</a>( Freq, Spc, specsiz+1,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PS_SOLID + SY_CROSS, GREEN );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#free">V_free</a>( Freq ); V_free( Time ); V_free( Win );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;V_free( Spc ); V_free( X );
<BR>end;</font>
<P>(* It is assumed that the graphics routines have already been initialized (DOS), or that the above example stands within a <I>Paint</I> (Pascal for Windows) or a <I>ShowView</I> (Delphi) routine. *)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If size is not a power of 2, <I><a href="#FFT">VF_FFT</a></I> (on which <I>VF_spectrum</I> is based) complains &quot;Size must be an integer power of 2&quot; and the program is aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>PSD at the Nyquist frequency</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#FFT">VF_FFT</a>,&nbsp;&nbsp; <a href="#convolve">VF_convolve</a>,&nbsp;&nbsp; <a href="#autocorr">VF_autocorr</a>,&nbsp;&nbsp; <a href="#xcorr">VF_xcorr</a>,&nbsp;&nbsp; <a href="#filter">VF_filter</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="splinederiv2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_splinederiv2</b></font></td><td width="33%"><font size="+1"><b>VD_splinederiv2</b></font></td><td><font size="+1"><b>VE_splinederiv2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Generate a second-derivative table from an X-Y-table to be used for cubic-spline interpolation.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_splinederiv2(
 fVector Y2, fVector XTab, fVector YTab, ui size, int specify, float Yp0, float Ypn );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::splinederiv2( const vector&lt;T&gt;& XTab, const vector&lt;T&gt;& YTab, int specify, T Yp0, T Ypn );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_splinederiv2( Y2, XTab, YTab:fVector; size:UInt; specify:IntBool; Yp0, Ypn:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A table of second derivatives of YTab is generated to be used for cubic-spline interpolation with <I><a href="#splineinterpol">VF_splineinterpol</a></I>. In order to get a unique solution, two additional conditions have to be specified. Setting specify to FALSE (0) yields the &quot;natural cubic spline&quot; with Y2 being set to zero at both end-points; in this case, Yp0 and Ypn have no influence. Setting specify to TRUE (1) yields Y2 calculated in such a way that the first(!) derivative at the zero'th and at the last position equals Yp0 and Ypn, resp.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#splineinterpol">VF_splineinterpol</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="splineinterpol"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_splineinterpol</b></font></td><td width="33%"><font size="+1"><b>VD_splineinterpol</b></font></td><td><font size="+1"><b>VE_splineinterpol</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Cubic-spline interpolation of X-Y-table values</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_splineinterpol(
 fVector Y, fVector X, ui sizex, fVector XTab, fVector YTab, fVector Y2Tab, ui sizetab );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::splineinterpol( const vector&lt;T&gt;& X, const vector&lt;T&gt;& XTab, const vector&lt;T&gt;& YTab, const vector&lt;T&gt;& Y2Tab );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_splineinterpol( Y, X:fVector; sizex:UInt; XTab, YTab, Y2Tab:fVector; sizetab:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>For each of the sizex elements of X, the corresponding element of Y is interpolated from the XTab-YTab value pairs. A table of second derivatives of YTab is needed that has to be generated by a call to <I><a href="#splinederiv2">VF_splinederiv2</a></I> prior to calling <I>VF_splineinterpol</I>. XTab must be ordered (either ascending or descending). All values of XTab must be distinct; otherwise a division by zero may occur and lead to a program abort. sizetab must be greater than or equal to 3.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none (you have to take care yourself that the XTab values are distinct and that the YTab values are not near the limit of overflowing).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#splinederiv2">VF_splinederiv2</a>,&nbsp;&nbsp; <a href="#ratinterpol">VF_ratinterpol</a>,&nbsp;&nbsp; <a href="#polyinterpol">VF_polyinterpol</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="square"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_square</b></font></td><td width="33%"><font size="+1"><b>VD_square</b></font></td><td><font size="+1"><b>VE_square</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_square</b></font></td><td width="33%"><font size="+1"><b>VDx_square</b></font></td><td><font size="+1"><b>VEx_square</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFu_square</b></font></td><td width="33%"><font size="+1"><b>VDu_square</b></font></td><td><font size="+1"><b>VEu_square</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFux_square</b></font></td><td width="33%"><font size="+1"><b>VDux_square</b></font></td><td><font size="+1"><b>VEux_square</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_square</b></font></td><td width="33%"><font size="+1"><b>VCD_square</b></font></td><td><font size="+1"><b>VCE_square</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_square</b></font></td><td width="33%"><font size="+1"><b>VCDx_square</b></font></td><td><font size="+1"><b>VCEx_square</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFu_square</b></font></td><td width="33%"><font size="+1"><b>VCDu_square</b></font></td><td><font size="+1"><b>VCEu_square</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFux_square</b></font></td><td width="33%"><font size="+1"><b>VCDux_square</b></font></td><td><font size="+1"><b>VCEux_square</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_square</b></font></td><td width="33%"><font size="+1"><b>VPD_square</b></font></td><td><font size="+1"><b>VPE_square</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPFu_square</b></font></td><td width="33%"><font size="+1"><b>VPDu_square</b></font></td><td><font size="+1"><b>VPEu_square</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Square</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_square( fVector Y, fVector X, ui size );
<BR>int VFx_square( fVector Y, fVector X, ui size, float A, float B );
<BR>int VFu_square( fVector Y, fVector X, ui size );
<BR>int VFux_square( fVector Y, fVector X, ui size, float A, float B );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::square( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_square( const vector&lt;T&gt;& X, T A, T B );
<BR>int vector&lt;T&gt;::u_square( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::ux_square( const vector&lt;T&gt;& X, T A, T B );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_square( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_square( Y, X:fVector; size:UInt; A, B:Single ): IntBool;
<BR>function VFu_square( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFux_square( Y, X:fVector; size:UInt; A, B:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = X<sub>i</sub><sup>2</sup>
<BR>expanded versions: Y<sub>i</sub> = (A*X<sub>i</sub>+B)<sup>2</sup>
<P>The &quot;unprotected&quot; versions (prefix <I>VFu_,&nbsp;&nbsp; VFux_</I>, etc.) do not perform any error handling, which makes them much faster (up to 50%), but riskier than the standard versions. The extended-precision complex (<I>VCEu_</I> and <I>VCEux_</I>) versions do not take some of the security measures present in the standard version and might fail for results very near the overflow limit; results near the underflow limit might be rendered as 0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors lead to a default result of HUGE_VAL.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#cubic">VF_cubic</a>,&nbsp;&nbsp; <a href="#sqrt">VF_sqrt</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#ipow">VF_ipow</a>,&nbsp;&nbsp; <a href="#poly">VF_poly</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sqrt"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sqrt</b></font></td><td width="33%"><font size="+1"><b>VD_sqrt</b></font></td><td><font size="+1"><b>VE_sqrt</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFu_sqrt</b></font></td><td width="33%"><font size="+1"><b>VDu_sqrt</b></font></td><td><font size="+1"><b>VEu_sqrt</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_sqrt</b></font></td><td width="33%"><font size="+1"><b>VCD_sqrt</b></font></td><td><font size="+1"><b>VCE_sqrt</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_sqrt</b></font></td><td width="33%"><font size="+1"><b>VDx_sqrt</b></font></td><td><font size="+1"><b>VEx_sqrt</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFux_sqrt</b></font></td><td width="33%"><font size="+1"><b>VDux_sqrt</b></font></td><td><font size="+1"><b>VEux_sqrt</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_sqrt</b></font></td><td width="33%"><font size="+1"><b>VCDx_sqrt</b></font></td><td><font size="+1"><b>VCEx_sqrt</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_sqrt</b></font></td><td width="33%"><font size="+1"><b>VPD_sqrt</b></font></td><td><font size="+1"><b>VPE_sqrt</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Square root</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_sqrt( fVector Y, fVector X, ui size );
<BR>int VFx_sqrt( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::sqrt( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_sqrt( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_sqrt( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_sqrt( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = sqrt( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * sqrt( A*X<sub>i</sub>+B )
<P>The &quot;unprotected&quot; versions (prefix <I>VFu_,&nbsp;&nbsp; VFux_</I>, etc.) do not perform any error handling, which makes them much faster (up to 350% for <I>VFux_sqrt</I> on Pentium III or IV) than the standard versions. On the other hand, any negative input number may lead to an uncontrolled programme crash. Input numbers near the underflow limit may lead to a result of 0. Apart from allowing no negative input numbers, the &quot;unprotected&quot; expanded version (prefix <I>VFux_</I>) also requires that neither the product A*X<sub>i</sub> nor the sum A*X<sub>i</sub>+B may overflow.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>DOMAIN errors occur if, in the real-number versions, the square root of a negative numbers is requested; NAN (&quot;not-a-number&quot;) is the default result in this case.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#square">VF_square</a>,&nbsp;&nbsp; <a href="#pow">VF_pow</a>,&nbsp;&nbsp; <a href="#ipow">VF_ipow</a>,&nbsp;&nbsp; <a href="#poly">VF_poly</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ssq"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ssq</b></font></td><td width="33%"><font size="+1"><b>VD_ssq</b></font></td><td><font size="+1"><b>VE_ssq</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sum-of-squares</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_ssq( fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::ssq();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_ssq( X:fVector; size:UInt ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>ssq = sum( X<sub>i</sub><sup>2</sup> )</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none (but be careful: this function may lead to an overflow!)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>sum of the squares of the vector elements.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sum">VF_sum</a>,&nbsp;&nbsp; <a href="#rms">VF_rms</a>,&nbsp;&nbsp; <a href="#ssqdevC">VF_ssqdevC</a>,&nbsp;&nbsp; <a href="#scalprod">VF_scalprod</a>,&nbsp;&nbsp; <a href="#Euclid">VF_Euclid</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ssqdevC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ssqdevC</b></font></td><td width="33%"><font size="+1"><b>VD_ssqdevC</b></font></td><td><font size="+1"><b>VE_ssqdevC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sum of the squares of the deviations from a preset value.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_ssqdevC( fVector X, ui size, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::ssqdevC( T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_ssqdevC( X:fVector; size:UInt; C:Single ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>ssqdevC = sum( (X<sub>i</sub> - C)<sup>2</sup> )</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>sum of the squares of the deviations.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ssq">VF_ssq</a>,&nbsp;&nbsp; <a href="#ssqdevV">VF_ssqdevV</a>,&nbsp;&nbsp; <a href="#avdevC">VF_avdevC</a>,&nbsp;&nbsp; <a href="#sumdevC">VF_sumdevC</a>,&nbsp;&nbsp; <a href="#chi2">VF_chi2</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="ssqdevV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_ssqdevV</b></font></td><td width="33%"><font size="+1"><b>VD_ssqdevV</b></font></td><td><font size="+1"><b>VE_ssqdevV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sum of the squares of the deviations of the elements of one vector from the corresponding elements of another</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_ssqdevV( fVector X, fVector Y, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::ssqdevV( const vector&lt;T&gt;& Y );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_ssqdevV( X, Y:fVector; size:UInt ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>ssqdevV = sum( (X<sub>i</sub> - Y<sub>i</sub>)<sup>2</sup> )
<BR>The deviation of each element of X from the corresponding element of Y is calculated and the squares of the deviations summed up and returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>sum of the squares of the deviations.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ssq">VF_ssq</a>,&nbsp;&nbsp; <a href="#ssqdevC">VF_ssqdevC</a>,&nbsp;&nbsp; <a href="#avdevV">VF_avdevV</a>,&nbsp;&nbsp; <a href="#sumdevV">VF_sumdevV</a>,&nbsp;&nbsp; <a href="#chi2">VF_chi2</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="store"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_store</b></font></td><td width="33%"><font size="+1"><b>VD_store</b></font></td><td><font size="+1"><b>VE_store</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_store</b></font></td><td width="33%"><font size="+1"><b>VCD_store</b></font></td><td><font size="+1"><b>VCE_store</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_store</b></font></td><td width="33%"><font size="+1"><b>VPD_store</b></font></td><td><font size="+1"><b>VPE_store</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_store</b></font></td><td width="20%"><font size="+1"><b>VBI_store</b></font></td><td width="20%"><font size="+1"><b>VSI_store</b></font></td><td width="20%"><font size="+1"><b>VLI_store</b></font></td><td><font size="+1"><b>VQI_store</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_store</b></font></td><td width="20%"><font size="+1"><b>VUB_store</b></font></td><td width="20%"><font size="+1"><b>VUS_store</b></font></td><td width="20%"><font size="+1"><b>VUL_store</b></font></td><td><font size="+1"><b>VUI_store</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Store a vector in binary format into a stream</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>VF_store( FILE *stream, fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::store( FILE *stream );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_store( var Stream:FILE; X:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><I>size</I> elements of X are written to stream in binary format. The stream must be already open for binary write operations.
<BR>The <I>VecObj</I> version stores not only the vector elements, but the whole <U>vector object</U> by first storing <I>size</I>. Please note that <I><a href="#recall">VF_recall</a></I> etc. can only read vectors stored with <I>VF_store</I> etc., whereas the <I>VecObj</I> function <I>recall</I> is used to retrieve vector objects stored with the <I>VecObj</I> function <I>store</I>. You can, however, employ the calling sequence
<BR><font face="courier new">VUI_store( stream, &size, 1 );
<BR>VF_store( stream, X, size );  &nbsp;&nbsp;/* C/C++ */ </font>
<BR>or
<BR><font face="courier new">VU_store( stream, @size, 1 );
<BR>VF_store( stream, X, size ); &nbsp;&nbsp;(* Pascal/Delphi *)</font>
<BR>to make the stored vector X readable as a vector object later.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#recall">VF_recall</a>,&nbsp;&nbsp; <a href="#write">VF_write</a>,&nbsp;&nbsp; <a href="#cprint">VF_cprint</a>,&nbsp;&nbsp; <a href="#print">VF_print</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="subC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subC</b></font></td><td width="33%"><font size="+1"><b>VD_subC</b></font></td><td><font size="+1"><b>VE_subC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_subC</b></font></td><td width="33%"><font size="+1"><b>VCD_subC</b></font></td><td><font size="+1"><b>VCE_subC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_subReC</b></font></td><td width="33%"><font size="+1"><b>VCD_subReC</b></font></td><td><font size="+1"><b>VCE_subReC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_subC</b></font></td><td width="20%"><font size="+1"><b>VBI_subC</b></font></td><td width="20%"><font size="+1"><b>VSI_subC</b></font></td><td width="20%"><font size="+1"><b>VLI_subC</b></font></td><td><font size="+1"><b>VQI_subC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_subC</b></font></td><td width="20%"><font size="+1"><b>VUB_subC</b></font></td><td width="20%"><font size="+1"><b>VUS_subC</b></font></td><td width="20%"><font size="+1"><b>VUL_subC</b></font></td><td><font size="+1"><b>VUI_subC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Subtract a constant from each vector element</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_subC( fVector Y, fVector X, ui size, float C );
<BR>void VCF_subC( cfVector Y, cfVector X, ui size, fComplex C );
<BR>void VCF_subReC( cfVector Y, cfVector X, ui size, float CRe );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::subC( const vector&lt;T&gt;& X, T C );
<BR>void vector&lt;complex&lt;T&gt;&gt;::subC( const vector&lt;complex&lt;T&gt;&gt;& X, complex&lt;T&gt; C );
<BR>void vector&lt;complex&lt;T&gt;&gt;::subReC( const vector&lt;complex&lt;T&gt;&gt;& X, T CRe );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_subC( Y, X:fVector; size:UInt; C:Single );
<BR>procedure VCF_subC( Y, X:cfVector; size:UInt; C:fComplex );
<BR>procedure VCF_subReC( Y, X:cfVector; size:UInt; CRe:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>i</sub> - C
<BR>The complex floating-point versions exist in two variants, one for complex constants C, the other for real-valued constants CRe subtracted from the complex vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>floating-point versions: none;
<BR>integer versions: see <a href="HANDBOOK.HTM#chap5_2">chapter&nbsp;5.2</a>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#subV">VF_subV</a>,&nbsp;&nbsp; <a href="#subrC">VF_subrC</a>,&nbsp;&nbsp; <a href="#addC">VF_addC</a>,&nbsp;&nbsp; <a href="#mulC">VF_mulC</a>,&nbsp;&nbsp; <a href="#divC">VF_divC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="subrC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subrC</b></font></td><td width="33%"><font size="+1"><b>VD_subrC</b></font></td><td><font size="+1"><b>VE_subrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_subrC</b></font></td><td width="33%"><font size="+1"><b>VCD_subrC</b></font></td><td><font size="+1"><b>VCE_subrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_subrReC</b></font></td><td width="33%"><font size="+1"><b>VCD_subrReC</b></font></td><td><font size="+1"><b>VCE_subrReC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_subrC</b></font></td><td width="20%"><font size="+1"><b>VBI_subrC</b></font></td><td width="20%"><font size="+1"><b>VSI_subrC</b></font></td><td width="20%"><font size="+1"><b>VLI_subrC</b></font></td><td><font size="+1"><b>VQI_subrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_subrC</b></font></td><td width="20%"><font size="+1"><b>VUB_subrC</b></font></td><td width="20%"><font size="+1"><b>VUS_subrC</b></font></td><td width="20%"><font size="+1"><b>VUL_subrC</b></font></td><td><font size="+1"><b>VUI_subrC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Reverse subtraction: subtract a vector from a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_subrC( fVector Y, fVector X, ui size, float C );
<BR>void VCF_subrC( cfVector Y, cfVector X, ui size, fComplex C );
<BR>void VCF_subrReC( cfVector Y, cfVector X, ui size, float CRe );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::subrC( const vector&lt;T&gt;& X, T C );
<BR>void vector&lt;complex&lt;T&gt;&gt;::subrC( const vector&lt;complex&lt;T&gt;&gt;& X, complex&lt;T&gt; C );
<BR>void vector&lt;complex&lt;T&gt;&gt;::subrReC( const vector&lt;complex&lt;T&gt;&gt;& X, T CRe );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_subrC( Y, X:fVector; size:UInt; C:Single );
<BR>procedure VCF_subrC( Y, X:cfVector; size:UInt; C:fComplex );
<BR>procedure VCF_subrReC( Y, X:cfVector; size:UInt; CRe:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = C - X<sub>i</sub>
<BR>The complex floating-point versions exist in two variants, one for complex constants C, the other for real-valued constants CRe from which the complex vector is subtracted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>floating-point versions: none;
<BR>integer versions: see <a href="HANDBOOK.HTM#chap5_2">chapter&nbsp;5.2.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#addV">VF_addV</a>,&nbsp;&nbsp; <a href="#subC">VF_subC</a>,&nbsp;&nbsp; <a href="#mulC">VF_mulC</a>,&nbsp;&nbsp; <a href="#divC">VF_divC</a>,&nbsp;&nbsp; <a href="#visC">VF_visC</a>,&nbsp;&nbsp; <a href="#redC">VF_redC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="subrV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subrV</b></font></td><td width="33%"><font size="+1"><b>VD_subrV</b></font></td><td><font size="+1"><b>VE_subrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_subrV</b></font></td><td width="33%"><font size="+1"><b>VCD_subrV</b></font></td><td><font size="+1"><b>VCE_subrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_subrReV</b></font></td><td width="33%"><font size="+1"><b>VCD_subrReV</b></font></td><td><font size="+1"><b>VCE_subrReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_subrV</b></font></td><td width="33%"><font size="+1"><b>VDx_subrV</b></font></td><td><font size="+1"><b>VEx_subrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_subrV</b></font></td><td width="33%"><font size="+1"><b>VCDx_subrV</b></font></td><td><font size="+1"><b>VCEx_subrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_subrReV</b></font></td><td width="33%"><font size="+1"><b>VCDx_subrReV</b></font></td><td><font size="+1"><b>VCEx_subrReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_subrV</b></font></td><td width="20%"><font size="+1"><b>VBI_subrV</b></font></td><td width="20%"><font size="+1"><b>VSI_subrV</b></font></td><td width="20%"><font size="+1"><b>VLI_subrV</b></font></td><td><font size="+1"><b>VQI_subrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_subrV</b></font></td><td width="20%"><font size="+1"><b>VUB_subrV</b></font></td><td width="20%"><font size="+1"><b>VUS_subrV</b></font></td><td width="20%"><font size="+1"><b>VUL_subrV</b></font></td><td><font size="+1"><b>VUI_subrV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Subtraction in reverse order</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_subrV( fVector Z, fVector X, fVector Y, ui size );
<BR>void VFx_subrV( fVector Z, fVector X, fVector Y, ui size, float A, float B );
<BR>void VCF_subrV( cfVector Z, cfVector X, cfVector Y, ui size );
<BR>void VCF_subrReV( cfVector Z, cfVector X, fVector Y, ui size );
<BR>void VCFx_subrV( cfVector Z, cfVector X, cfVector Y, ui size, fComplex A, fComplex B );
<BR>void VCFx_subrReV( cfVector Z, cfVector X, fVector Y, ui size, fComplex A, fComplex B );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::subrV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y );
<BR>void vector&lt;T&gt;::x_subrV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y, T A, T B );
<BR>void vector&lt;complex&lt;T&gt;&gt;::subrV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;complex&lt;T&gt;&gt;& Y );
<BR>void vector&lt;complex&lt;T&gt;&gt;::subrReV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;T&gt;& Y );
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_subrV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;complex&lt;T&gt;&gt;& Y, complex&lt;T&gt; A, complex&lt;T&gt; B );
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_subrReV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;T&gt;& Y, complex&lt;T&gt; A, complex&lt;T&gt; B );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_subrV( Z, X, Y:fVector; size:UInt );
<BR>procedure VFx_subrV( Z, X, Y:fVector; size:UInt; A, B:Single);
<BR>procedure VCF_subrV( Z, X, Y:cfVector; size:UInt );
<BR>procedure VCF_subrReV( Z, X:cfVector; Y:fVector; size:UInt );
<BR>procedure VCFx_subrV( Z, X, Y:cfVector; size:UInt; A, B:fComplex );
<BR>procedure VCFx_subrReV( Z, X:cfVector; Y:fVector; size:UInt; A, B:fComplex );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Z<sub>i</sub> = Y<sub>i</sub> - X<sub>i</sub>
<BR>expanded versions: Z<sub>i</sub> = Y<sub>i</sub> - (A*X<sub>i</sub>+B)
<BR>The complex floating-point versions exist in two variants: in the first variant (e.g., <I>VCF_subrV,&nbsp;&nbsp; VCFx_subrV</I>), X, Y, and Z are all complex; in the second variant, Y is real-valued (e.g., <I>VCF_subrReV</I> - &quot;reverse subtraction of a real vector&quot;, i.e., subtraction of a complex vector from a real vector).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>floating-point versions: none;
<BR>integer versions: see <a href="HANDBOOK.HTM#chap5_2">chapter&nbsp;5.2.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#subrC">VF_subrC</a>,&nbsp;&nbsp; <a href="#addV">VF_addV</a>,&nbsp;&nbsp; <a href="#mulV">VF_mulV</a>,&nbsp;&nbsp; <a href="#divV">VF_divV</a>,&nbsp;&nbsp; <a href="#visV">VF_visV</a>,&nbsp;&nbsp; <a href="#redV">VF_redV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="subV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subV</b></font></td><td width="33%"><font size="+1"><b>VD_subV</b></font></td><td><font size="+1"><b>VE_subV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_subV</b></font></td><td width="33%"><font size="+1"><b>VCD_subV</b></font></td><td><font size="+1"><b>VCE_subV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_subReV</b></font></td><td width="33%"><font size="+1"><b>VCD_subReV</b></font></td><td><font size="+1"><b>VCE_subReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFs_subV</b></font></td><td width="33%"><font size="+1"><b>VDs_subV</b></font></td><td><font size="+1"><b>VEs_subV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_subV</b></font></td><td width="33%"><font size="+1"><b>VDx_subV</b></font></td><td><font size="+1"><b>VEx_subV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_subV</b></font></td><td width="33%"><font size="+1"><b>VCDx_subV</b></font></td><td><font size="+1"><b>VCEx_subV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_subReV</b></font></td><td width="33%"><font size="+1"><b>VCDx_subReV</b></font></td><td><font size="+1"><b>VCEx_subReV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_subV</b></font></td><td width="20%"><font size="+1"><b>VBI_subV</b></font></td><td width="20%"><font size="+1"><b>VSI_subV</b></font></td><td width="20%"><font size="+1"><b>VLI_subV</b></font></td><td><font size="+1"><b>VQI_subV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_subV</b></font></td><td width="20%"><font size="+1"><b>VUB_subV</b></font></td><td width="20%"><font size="+1"><b>VUS_subV</b></font></td><td width="20%"><font size="+1"><b>VUL_subV</b></font></td><td><font size="+1"><b>VUI_subV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Subtract two vectors</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_subV( fVector Z, fVector X, fVector Y, ui size );
<BR>void VFs_subV( fVector Z, fVector X, fVector Y, ui size, float C );
<BR>void VFx_subV( fVector Z, fVector X, fVector Y, ui size, float A, float B );
<BR>void VCF_subV( cfVector Z, cfVector X, cfVector Y, ui size );
<BR>void VCF_subReV( cfVector Z, cfVector X, fVector Y, ui size );
<BR>void VCFx_subV( cfVector Z, cfVector X, cfVector Y, ui size, fComplex A, fComplex B );
<BR>void VCFx_subReV( cfVector Z, cfVector X, fVector Y, ui size, fComplex A, fComplex B );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::subV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y );
<BR>void vector&lt;T&gt;::s_subV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y, T C );
<BR>void vector&lt;T&gt;::x_subV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y, T A, T B );
<BR>void vector&lt;complex&lt;T&gt;&gt;::subV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;complex&lt;T&gt;&gt;& Y );
<BR>void vector&lt;complex&lt;T&gt;&gt;::subReV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;T&gt;& Y );
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_subV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;complex&lt;T&gt;&gt;& Y, complex&lt;T&gt; A, complex&lt;T&gt; B );
<BR>void vector&lt;complex&lt;T&gt;&gt;::x_subReV( const vector&lt;complex&lt;T&gt;&gt;& X, const vector&lt;T&gt;& Y, complex&lt;T&gt; A, complex&lt;T&gt; B );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_subV( Z, X, Y:fVector; size:UInt );
<BR>procedure VFx_subV( Z, X, Y:fVector; size:UInt; A, B:Single);
<BR>procedure VCF_subV( Z, X, Y:cfVector; size:UInt );
<BR>procedure VCF_subReV( Z, X:cfVector; Y:fVector; size:UInt );
<BR>procedure VCFx_subV( Z, X, Y:cfVector; size:UInt; A, B:fComplex );
<BR>procedure VCFx_subrReV( Z, X:cfVector; Y:fVector; size:UInt; A, B:fComplex );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Z<sub>i</sub> = X<sub>i</sub> - Y<sub>i</sub>
<BR>scaled versions: Z<sub>i</sub> = C * (X<sub>i</sub> - Y<sub>i</sub>)
<BR>expanded versions: Z<sub>i</sub> = (A*X<sub>i</sub>+B) - Y<sub>i</sub>
<BR>The complex floating-point versions exist in two variants: in the first variant (e.g., <I>VCF_subV,&nbsp;&nbsp; VCFx_subV</I>), X, Y, and Z are all complex; in the second variant, Y is real-valued (e.g., <I>VCF_subReV</I> - &quot;subtract a real vector&quot;).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>floating-point versions: none;
<BR>integer versions: see <a href="HANDBOOK.HTM#chap5_2">chapter&nbsp;5.2.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#subC">VF_subC</a>,&nbsp;&nbsp; <a href="#addV">VF_addV</a>,&nbsp;&nbsp; <a href="#mulV">VF_mulV</a>,&nbsp;&nbsp; <a href="#divV">VF_divV</a>,&nbsp;&nbsp; <a href="#visV">VF_visV</a>,&nbsp;&nbsp; <a href="#redV">VF_redV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="subvector"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subvector</b></font></td><td width="33%"><font size="+1"><b>VD_subvector</b></font></td><td><font size="+1"><b>VE_subvector</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_subvector</b></font></td><td width="33%"><font size="+1"><b>VCD_subvector</b></font></td><td><font size="+1"><b>VCE_subvector</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_subvector</b></font></td><td width="33%"><font size="+1"><b>VPD_subvector</b></font></td><td><font size="+1"><b>VPE_subvector</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VI_subvector</b></font></td><td width="33%"><font size="+1"><b>VBI_subvector</b></font></td><td><font size="+1"><b>VSI_subvector</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VLI_subvector</b></font></td><td><font size="+1"><b>VQI_subvector</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_subvector</b></font></td><td width="33%"><font size="+1"><b>VUB_subvector</b></font></td><td><font size="+1"><b>VUS_subvector</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_subvector</b></font></td><td><font size="+1"><b>VUI_subvector</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Extract a sub-vector from the input vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_subvector( fVector Y, ui subsize, fVector X, int samp );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::subvector( const vector&lt;T&gt;& X, int samp, ui start=0 );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_subvector( Y:fVector; sizey:UInt; X:fVector; samp:Integer );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = X<sub>i*samp</sub>
<BR>A sub-vector Y is extracted from X with a sampling interval samp. This means that every samp'th element is taken, up to a total of subsize elements, starting with the zero'th element of X. Since X may be an expression like XX+1000 (C/C++) or VF_Pelement( XX, 1000 ) (Pascal/Delphi), samp does not always need to be positive, but may also take on negative values (or the trivial value of 0). X and Y have to be distinct. Instead of using a samp of 0, 1, or -1, one should use <I><a href="#equC">VF_equC</a>,&nbsp;&nbsp; <a href="#equV">VF_equV</a></I>, or <I><a href="#rev">VF_rev</a></I>, respectively.
<BR>The <I>VecObj</I> version is called with an additional argument <I>start</I>, denoting the element of X to start with. This is necessary to avoid input expressions like <font face="courier new">XX+1000</font>, which are possible only with pointers, but would be mis-interpreted as the <font face="courier new">operator +</font> in the class-based object-oriented interface.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#indpick">VF_indpick</a>,&nbsp;&nbsp; <a href="#CtoRe">VF_CtoRe</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="subvector_"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subvector_...</b></font></td><td width="33%"><font size="+1"><b>VD_subvector_...</b></font></td><td><font size="+1"><b>VE_subvector_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_subvector_...</b></font></td><td width="33%"><font size="+1"><b>VCD_subvector_...</b></font></td><td><font size="+1"><b>VCE_subvector_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_subvector_...</b></font></td><td width="33%"><font size="+1"><b>VPD_subvector_...</b></font></td><td><font size="+1"><b>VPE_subvector_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="22%">&nbsp;</td><td width="33%"><font size="+1"><b>..._addC</b></font></td><td><font size="+1"><b>..._addV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="22%">&nbsp;</td><td width="33%"><font size="+1"><b>..._divC</b></font></td><td><font size="+1"><b>..._divV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="22%">&nbsp;</td><td width="33%"><font size="+1"><b>..._divrC</b></font></td><td><font size="+1"><b>..._divrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="22%">&nbsp;</td><td width="33%"><font size="+1"><b>..._mulC</b></font></td><td><font size="+1"><b>..._mulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="22%">&nbsp;</td><td width="33%"><font size="+1"><b>..._subC</b></font></td><td><font size="+1"><b>..._subV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="22%">&nbsp;</td><td width="33%"><font size="+1"><b>..._subrC</b></font></td><td><font size="+1"><b>..._subrV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Arithmetic functions working on a sub-set of elements within a vector of one of the floating-point data types.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_subvector_addC( fVector Y, ui subsize, unsigned samp, float C );
<BR>void VF_subvector_addV( fVector Y, ui subsize, unsigned samp, fVector X );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::subvector_addC( unsigned samp, T C );
<BR>void vector&lt;T&gt;::subvector_addV( unsigned samp, const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_subvector_addC( Y:fVector; subsiz:UInt; samp:UInt; C:Single );
<BR>procedure VF_subvector_addV( Y:fVector; subsiz:UInt; samp:UInt; X:fVector );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><table><tr valign="top"><td>..._addC:</td><td>Y<sub>i*samp</sub> += C,</td><td>i=0,...subsize-1</td></tr>
<tr valign="top"><td>..._addV:</td><td>Y<sub>i*samp</sub> += X<sub>i</sub>,</td><td>i=0,...subsize-1</td></tr>
<tr valign="top"><td>..._subC:</td><td>Y<sub>i*samp</sub> -= C,</td><td>i=0,...subsize-1</td></tr>
<tr valign="top"><td>..._subV:</td><td>Y<sub>i*samp</sub> -= X<sub>i</sub>,</td><td>i=0,...subsize-1</td></tr>
<tr valign="top"><td>..._subrC:</td><td>Y<sub>i*samp</sub> = C - Y<sub>i*samp</sub>,</td><td>i=0,...subsize-1</td></tr>
<tr valign="top"><td>..._subrV:&nbsp;&nbsp;</td><td>Y<sub>i*samp</sub> = X<sub>i</sub>- Y<sub>i*samp</sub>,&nbsp;&nbsp;</td><td>i=0,...subsize-1</td></tr>
<tr valign="top"><td>..._mulC:</td><td>Y<sub>i*samp</sub> *= C,</td><td>i=0,...subsize-1</td></tr>
<tr valign="top"><td>..._mulV:</td><td>Y<sub>i*samp</sub> *= X<sub>i</sub>,</td><td>i=0,...subsize-1</td></tr>
<tr valign="top"><td>..._divC:</td><td>Y<sub>i*samp</sub> /= C,</td><td>i=0,...subsize-1</td></tr>
<tr valign="top"><td>..._divV:</td><td>Y<sub>i*samp</sub> /= X<sub>i</sub>,</td><td>i=0,...subsize-1</td></tr>
<tr valign="top"><td>..._divrC:</td><td>Y<sub>i*samp</sub> = C / Y<sub>i*samp</sub>,</td><td>i=0,...subsize-1</td></tr>
<tr valign="top"><td>..._divrV:</td><td>Y<sub>i*samp</sub> = X<sub>i</sub> / Y<sub>i*samp</sub>,</td><td>i=0,...subsize-1</td></tr>
</table>&nbsp;
<BR>Polar complex versions:
<BR>only multiplication and division are present: <I>...mulC, &nbsp;...mulV, &nbsp;...divC, &nbsp;...divV, &nbsp;...divrC</I>, and <I>...divrV</I>.
<P>The operation indicated in the suffix of the function name is perfomed on a sub-set of the elements of a vector. The sampling interval is denoted by samp: every samp'th element is taken, up to a total of subsize, starting with the zero'th one (that means, subsize is not the total size of the vector, but rather the size of the sub-set, i.e. the number of elements for which the function is performed). Note that all operations are performed in place, i.e., the input vector itself is changed.
<BR>For similar functions not included in the above list, the necessary sequence of calls is similar to the following example (which shows how to calculate the sinc function of the zero'th and then every tenth element of X, assuming that size is an integer multiple of 10):
<BR><font face="courier new"><a href="#subvector">VF_subvector</a>( Y, size/10, 10, X );
<BR><a href="#sinc">VF_sinc</a>( Y, Y, size/10 );
<BR><a href="#subvector_equC">VF_subvector_equV</a>( X, size/10, 10, Y );</font>
<BR>(However, in such cases, you would sometimes prefer the classic style of a loop with the loop-increment set to 10. Only if the desired function is not available in the math library of your compiler, the effort of copying back and forth into the dummy vector Y will pay off.)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#subvector">VF_subvector</a>,&nbsp;&nbsp; <a href="#subvector_equC">VF_subvector_equC</a>,&nbsp;&nbsp; <a href="#subvector_equC">VF_subvector_equV</a>,&nbsp;&nbsp; <a href="#addC">VF_addC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="subvector_equC"></a><a name="subvector_equV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_subvector_...</b></font></td><td width="33%"><font size="+1"><b>VD_subvector_...</b></font></td><td><font size="+1"><b>VE_subvector_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_subvector_...</b></font></td><td width="33%"><font size="+1"><b>VCD_subvector_...</b></font></td><td><font size="+1"><b>VCE_subvector_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_subvector_...</b></font></td><td width="33%"><font size="+1"><b>VPD_subvector_...</b></font></td><td><font size="+1"><b>VPE_subvector_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VI_subvector_...</b></font></td><td width="33%"><font size="+1"><b>VBI_subvector_...</b></font></td><td><font size="+1"><b>VSI_subvector_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VLI_subvector_...</b></font></td><td><font size="+1"><b>VQI_subvector_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_subvector_...</b></font></td><td width="33%"><font size="+1"><b>VUB_subvector_...</b></font></td><td><font size="+1"><b>VUS_subvector_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_subvector_...</b></font></td><td><font size="+1"><b>VUI_subvector_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="22%">&nbsp;</td><td width="33%"><font size="+1"><b>..._equC</b></font></td><td><font size="+1"><b>..._equV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initialize a sub-set of elements within a vector either with a constant value or with values stored as the elements of another vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_subvector_equC( fVector Y, ui subsize, unsigned samp, float C );
<BR>void VF_subvector_equV( fVector Y, ui subsize, unsigned samp, fVector X );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::subvector_equC( unsigned samp, T C );
<BR>void vector&lt;T&gt;::subvector_equV( unsigned samp, const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_subvector_equC( Y:fVector; subsz:UInt; samp:UInt; C:Single );
<BR>procedure VF_subvector_equV( Y:fVector; subsz:UInt; samp:UInt; X:fVector );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><table><tr valign="top"><td>..._equC:&nbsp;&nbsp;</td><td>Y<sub>i*samp</sub> = C,</td><td>i=0,...subsize-1</td></tr>
<tr valign="top"><td>..._equV:</td><td>Y<sub>i*samp</sub> = X<sub>i</sub>,&nbsp;&nbsp;</td><td>i=0,...subsize-1</td></tr>
</table>&nbsp;
<BR>A sub-set of the elements of a vector is overwritten according to the sampling interval <I>samp</I>: every <I>samp</I>'th element is initialized either with the constant C, or with the value specified as an element of the vector X. A total of <I>subsize</I> elements is initialized, starting with the zeroth one (that means, <I>subsize</I> is not the total size of the vector, but rather the size of the sub-set). <I>VF_subvector_equV</I> is the exact reverse of <I><a href="#subvector">VF_subvector</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#subvector">VF_subvector</a>,&nbsp;&nbsp; <a href="#equC">VF_equC</a>,&nbsp;&nbsp; <a href="#equV">VF_equV</a>,&nbsp;&nbsp; <a href="#subvector_">VF_subvector_addC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sum"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sum</b></font></td><td width="33%"><font size="+1"><b>VD_sum</b></font></td><td><font size="+1"><b>VE_sum</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_sum</b></font></td><td width="33%"><font size="+1"><b>VCD_sum</b></font></td><td><font size="+1"><b>VCE_sum</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_sum</b></font></td><td width="20%"><font size="+1"><b>VBI_sum</b></font></td><td width="20%"><font size="+1"><b>VSI_sum</b></font></td><td width="20%"><font size="+1"><b>VLI_sum</b></font></td><td><font size="+1"><b>VQI_sum</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_sum</b></font></td><td width="20%"><font size="+1"><b>VUB_sum</b></font></td><td width="20%"><font size="+1"><b>VUS_sum</b></font></td><td width="20%"><font size="+1"><b>VUL_sum</b></font></td><td><font size="+1"><b>VUI_sum</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sum up all the elements of a vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_sum( fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::sum();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_sum( X:fVector; size:UInt ): Single;
<BR>procedure VCF_sum( var Sum:fComplex; X:cfVector; size:UInt);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>sum = sum( X<sub>i</sub> )
<BR>The sum over all elements of a vector is calculated.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none (but be careful: this function may easily overflow!)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>sum of the vector elements (except complex versions in Pascal/Delphi).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#runsum">VF_runsum</a>,&nbsp;&nbsp; <a href="#fsum">VI_fsum</a>, &nbsp;&nbsp;<a href="#prod">VF_prod</a>,&nbsp;&nbsp; <a href="#ssq">VF_ssq</a>,&nbsp;&nbsp; <a href="#ssqdevC">VF_ssqdevC</a>,&nbsp;&nbsp; <a href="#mean">VF_mean</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sumabs"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sumabs</b></font></td><td width="33%"><font size="+1"><b>VD_sumabs</b></font></td><td><font size="+1"><b>VE_sumabs</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sum up the absolute values of all the elements of a vector.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_sumabs( fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::sumabs();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_sumabs( X:fVector; size:UInt ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>sumabs = sum(| X<sub>i</sub> |)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none (but be careful: this function may easily overflow!)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>sum of the absolute values of all vector elements.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sum">VF_sum</a>,&nbsp;&nbsp; <a href="#meanabs">VF_meanabs</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sumdevC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sumdevC</b></font></td><td width="33%"><font size="+1"><b>VD_sumdevC</b></font></td><td><font size="+1"><b>VE_sumdevC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sum of the absolute deviations from a preset value.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_sumdevC( fVector X, ui size, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::sumdevC( T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_sumdevC( X:fVector; size:UInt; C:Single ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>sumdevC = sum( |X<sub>i</sub> - C| )</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>sum of the absolute deviations.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#ssqdevC">VF_ssqdevC</a>,&nbsp;&nbsp; <a href="#sumdevV">VF_sumdevV</a>,&nbsp;&nbsp; <a href="#avdevC">VF_avdevC</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="sumdevV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_sumdevV</b></font></td><td width="33%"><font size="+1"><b>VD_sumdevV</b></font></td><td><font size="+1"><b>VE_sumdevV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Sum of the absolute deviations of the elements of one vector from the corresponding elements of another</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_sumdevV( fVector X, fVector Y, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::sumdevV( const vector&lt;T&gt;& Y );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_sumdevV( X, Y:fVector; size:UInt ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>sumdevV = sum( |X<sub>i</sub> - Y<sub>i</sub>| )</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>sum of the absolute deviations.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sum">VF_sum</a>,&nbsp;&nbsp; <a href="#sumdevC">VF_sumdevC</a>,&nbsp;&nbsp; <a href="#avdevV">VF_avdevV</a>,&nbsp;&nbsp; <a href="#ssqdevV">VF_ssqdevV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="tan"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_tan</b></font></td><td width="33%"><font size="+1"><b>VD_tan</b></font></td><td><font size="+1"><b>VE_tan</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_tan</b></font></td><td width="33%"><font size="+1"><b>VCD_tan</b></font></td><td><font size="+1"><b>VCE_tan</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_tan</b></font></td><td width="33%"><font size="+1"><b>VDx_tan</b></font></td><td><font size="+1"><b>VEx_tan</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_tan</b></font></td><td width="33%"><font size="+1"><b>VCDx_tan</b></font></td><td><font size="+1"><b>VCEx_tan</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Tangent function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_tan( fVector Y, fVector X, ui size );
<BR>int VFx_tan( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::tan( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_tan( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_tan( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_tan( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = tan ( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * tan( A*X<sub>i</sub>+B )
<BR>For large values of X<sub>i</sub>, round-off error becomes appreciable; if the X<sub>i</sub> values are representable as rational multiples of <font face="symbol">p</font>, it is better to use <I><a href="#tanrpi">VF_tanrpi</a></I> than <I>VF_tan</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>SING and OVERFLOW errors (for arguments very close to <font face="symbol">p</font>/2) lead to a default result of &#177;HUGE_VAL. Precision errors lead to a default result of 0.0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#tan2">VF_tan2</a>,&nbsp;&nbsp; <a href="#tanrpi">VF_tanrpi</a>,&nbsp;&nbsp; <a href="#sin">VF_sin</a>,&nbsp;&nbsp; <a href="#tanh">VF_tanh</a>,&nbsp;&nbsp; <a href="#atan">VF_atan</a>,&nbsp;&nbsp; <a href="#atan2">VF_atan2</a>,&nbsp;&nbsp; tan</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="tan2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_tan2</b></font></td><td width="33%"><font size="+1"><b>VD_tan2</b></font></td><td><font size="+1"><b>VE_tan2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_tan2</b></font></td><td width="33%"><font size="+1"><b>VDx_tan2</b></font></td><td><font size="+1"><b>VEx_tan2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Square of the tangent function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_tan2( fVector Y, fVector X, ui size );
<BR>int VFx_tan2( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::tan2( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_tan2( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_tan2( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_tan2( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: Y<sub>i</sub> = tan<sup>2</sup>( X<sub>i</sub> )
<BR>expanded versions: Y<sub>i</sub> = C * tan<sup>2</sup>( A*X<sub>i</sub>+B )
<BR>Calculating the squared trigonometric functions directly is faster and sometimes more accurate than first calculating the trigonometric function itself and squaring it afterwards.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>SING and OVERFLOW errors (for arguments close to <font face="symbol">p</font>/2) lead to a default result of &#177;HUGE_VAL. Precision errors lead to a default result of 0.0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#tan">VF_tan</a>,&nbsp;&nbsp; <a href="#tanrpi">VF_tanrpi</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="tanh"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_tanh</b></font></td><td width="33%"><font size="+1"><b>VD_tanh</b></font></td><td><font size="+1"><b>VE_tanh</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_tanh</b></font></td><td width="33%"><font size="+1"><b>VCD_tanh</b></font></td><td><font size="+1"><b>VCE_tanh</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_tanh</b></font></td><td width="33%"><font size="+1"><b>VDx_tanh</b></font></td><td><font size="+1"><b>VEx_tanh</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCFx_tanh</b></font></td><td width="33%"><font size="+1"><b>VCDx_tanh</b></font></td><td><font size="+1"><b>VCEx_tanh</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Hyperbolic tangent function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_tanh( fVector Y, fVector X, ui size );
<BR>int VFx_tanh( fVector Y, fVector X, ui size, float A, float B, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::tanh( const vector&lt;T&gt;& X );
<BR>int vector&lt;T&gt;::x_tanh( const vector&lt;T&gt;& X, T A, T B, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_tanh( Y, X:fVector; size:UInt ): IntBool;
<BR>function VFx_tanh( Y, X:fVector; size:UInt; A, B, C:Single ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions:
<table><tr><td>Y<sub>i</sub> =&nbsp;&nbsp;</td><td>tanh( X<sub>i</sub> )</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;</td><td><U>exp( X<sub>i</sub> ) - exp( -X<sub>i</sub> )</U>
<BR>exp( X<sub>i</sub> ) + exp( -X<sub>i</sub> )</td></tr></table>&nbsp;
<BR>expanded versions:
<BR>Y<sub>i</sub> = C * tanh( A*X<sub>i</sub>+B )</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>These functions should be error-proof.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>always FALSE (0).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#sinh">VF_sinh</a>,&nbsp;&nbsp; <a href="#exp">VF_exp</a>,&nbsp;&nbsp; tanh</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="tanrpi"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_tanrpi</b></font></td><td width="33%"><font size="+1"><b>VD_tanrpi</b></font></td><td><font size="+1"><b>VE_tanrpi</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_tanrpi2</b></font></td><td width="33%"><font size="+1"><b>VD_tanrpi2</b></font></td><td><font size="+1"><b>VE_tanrpi2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_tanrpi3</b></font></td><td width="33%"><font size="+1"><b>VD_tanrpi3</b></font></td><td><font size="+1"><b>VE_tanrpi3</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Tangent function of fractional multiples of <font face="symbol">p</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_tanrpi( fVector Y, iVector P, ui size, int q );
<BR>int VF_tanrpi2( fVector Y, iVector P, ui size, int q );
<BR>int VF_tanrpi3( fVector Y, iVector P, ui size, int q );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::tanrpi( const vector&lt;int&gt;& P, int q );
<BR>int vector&lt;T&gt;::tanrpi2( const vector&lt;int&gt;& P, int q );
<BR>int vector&lt;T&gt;::tanrpi3( const vector&lt;int&gt;& P, int q );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_tanrpi( Y:fVector; P:iVector; size:UInt; q:Integer ): IntBool;
<BR>function VF_tanrpi2( Y:fVector; P:iVector; size:UInt; q:Integer ): IntBool;
<BR>function VF_tanrpi3( Y:fVector; P:iVector; size:UInt; q:Integer ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = tan( (P<sub>i</sub> / q) * <font face="symbol">p</font> )
<BR>The tangent of fractional multiples of <font face="symbol">p</font> is calculated. There are three versions: <I>VF_tanrpi</I> is for general use with any arbitrary denominator q. If q is a power of 2, <I>VF_tanrpi2</I> should be used which is a highly optimized version using a look-up table. If q is a multiple of 3, <I>VF_tanrpi3</I> should be used. <I>VF_tanrpi2</I> and <I>VF_tanrpi3</I> work also with q values they are not optimized for; in this case, however, memory space is wasted for the then useless tables.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>SING errors occur if P<sub>i</sub> / q is an odd multiple of 1/2; the default result is 0.0 (which is the mean of +HUGE_VAL and -HUGE_VAL).
<BR>q must be non-zero; this is, however, not tested for.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#tan">VF_tan</a>,&nbsp;&nbsp; tan</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="tantab2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_tantab2</b></font></td><td width="33%"><font size="+1"><b>VD_tantab2</b></font></td><td><font size="+1"><b>VE_tantab2</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_tantab3</b></font></td><td width="33%"><font size="+1"><b>VD_tantab3</b></font></td><td><font size="+1"><b>VE_tantab3</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">&nbsp;</TD><td>Table of tangent values for arguments between 0 and <font face="symbol">p</font>/2.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;xmath.h&gt;
<BR>extern float&nbsp;&nbsp;&nbsp;&nbsp;VF_tantab2[ VF_tabsz2+1 ];
<BR>extern double&nbsp;&nbsp;&nbsp;VD_tantab2[ VD_tabsz2+1 ];
<BR>extern extended&nbsp;VE_tantab2[ VE_tabsz2+1 ];
<BR>extern float&nbsp;&nbsp;&nbsp;&nbsp;VF_tantab3[ VF_tabsz3+1 ];
<BR>extern double&nbsp;&nbsp;&nbsp;VD_tantab3[ VD_tabsz3+1 ];
<BR>extern extended&nbsp;VE_tantab3[ VE_tabsz3+1 ];</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses FTANTAB2, DTANTAB2, ETANTAB2,
FTANTAB3, DTANTAB3, ETANTAB3;
<BR>VF_tantab2: array[0..VF_tabsz2] of Single;
<BR>VD_tantab2: array[0..VD_tabsz2] of Double;
<BR>VE_tantab2: array[0..VE_tabsz2] of Extended;
<BR>VF_tantab3: array[0..VF_tabsz3] of Single;
<BR>VD_tantab3: array[0..VD_tabsz3] of Double;
<BR>VE_tantab3: array[0..VE_tabsz3] of Extended;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>VF_tantab2[ i ] = tan( i/(2*VF_tabsz2) * <font face="symbol">p</font> ), &nbsp;&nbsp;&nbsp;i=0,...,VF_tabsz2-1
<BR>VF_tantab3[ i ] = tan( i/(2*VF_tabsz3) * <font face="symbol">p</font> ), &nbsp;&nbsp;&nbsp;i=0,...,VF_tabsz3-1
<BR>VF_tantab2[ VF_tabsz2 ] = VF_tantab3[ VF_tabsz3 ] = 0;
<P>These look-up tables of tangent values for arguments between 0 and <font face="symbol">p</font>/2 are used by <I><a href="#tanrpi">VF_tanrpi2</a></I> and the other functions of that family and are also available for other purposes. Since the tangent of <font face="symbol">p</font>/2 is not defined, zero is stored at its place. 
<BR>C/C++: The symbols VF_tabsz2 etc., denoting the size of the tables, are defined in &lt;xmath.h&gt;.
<BR>Pascal/Delphi: The symbols VF_tabsz2 etc. are defined in the same units as the tables themselves.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#tanrpi">VF_tanrpi2</a>,&nbsp;&nbsp; <a href="#sintab2">VF_sintab2</a>,&nbsp;&nbsp; <a href="#cosectab2">VF_cosectab2</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="trunc"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_trunc</b></font></td><td width="33%"><font size="+1"><b>VD_trunc</b></font></td><td><font size="+1"><b>VE_trunc</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_trunctoI</b></font></td><td width="33%"><font size="+1"><b>VD_trunctoI</b></font></td><td><font size="+1"><b>VE_trunctoI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_trunctoBI</b></font></td><td width="33%"><font size="+1"><b>VD_trunctoBI</b></font></td><td><font size="+1"><b>VE_trunctoBI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_trunctoSI</b></font></td><td width="33%"><font size="+1"><b>VD_trunctoSI</b></font></td><td><font size="+1"><b>VE_trunctoSI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_trunctoLI</b></font></td><td width="33%"><font size="+1"><b>VD_trunctoLI</b></font></td><td><font size="+1"><b>VE_trunctoLI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_trunctoQI</b></font></td><td width="33%"><font size="+1"><b>VD_trunctoQI</b></font></td><td><font size="+1"><b>VE_trunctoQI</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_trunctoU</b></font></td><td width="33%"><font size="+1"><b>VD_trunctoU</b></font></td><td><font size="+1"><b>VE_trunctoU</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_trunctoUB</b></font></td><td width="33%"><font size="+1"><b>VD_trunctoUB</b></font></td><td><font size="+1"><b>VE_trunctoUB</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_trunctoUS</b></font></td><td width="33%"><font size="+1"><b>VD_trunctoUS</b></font></td><td><font size="+1"><b>VE_trunctoUS</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_trunctoUL</b></font></td><td width="33%"><font size="+1"><b>VD_trunctoUL</b></font></td><td><font size="+1"><b>VE_trunctoUL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_trunctoUI</b></font></td><td width="33%"><font size="+1"><b>VD_trunctoUI</b></font></td><td><font size="+1"><b>VE_trunctoUI</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Rounding by &quot;truncating&quot; toward zero.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>int VF_trunc( fVector Y, fVector X, ui size );
<BR>int VF_trunctoI( iVector Y, fVector X, ui size );
<BR>int VF_trunctoU( uVector Y, fVector X, ui size );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>int vector&lt;T&gt;::trunc( const vector&lt;T&gt;& X );
<BR>int vector&lt;int&gt;::trunctoI( const vector&lt;T&gt;& X );
<BR>int vector&lt;unsigned&gt;::trunctoU( const vector&lt;T&gt;& X );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>function VF_trunc( Y, X:fVector; size:UInt ):IntBool;
<BR>function VF_trunctoI( Y:iVector; X:fVector; size:UInt ):IntBool;
<BR>function VF_trunctoLI( Y:liVector; X:fVector; size:UInt ):IntBool;
</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>These functions are identical to those of the <I><a href="#chop">VF_chop</a></I> family. They have been defined in order to maintain consistency with the Pascal/Delphi function <I>trunc</I>. For details, see <I><a href="#chop">VF_chop</a></I>.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="UtoF"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_UtoF</b></font></td><td width="33%"><font size="+1"><b>V_UtoD</b></font></td><td><font size="+1"><b>V_UtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_UBtoF</b></font></td><td width="33%"><font size="+1"><b>V_UBtoD</b></font></td><td><font size="+1"><b>V_UBtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_UStoF</b></font></td><td width="33%"><font size="+1"><b>V_UStoD</b></font></td><td><font size="+1"><b>V_UStoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_ULtoF</b></font></td><td width="33%"><font size="+1"><b>V_ULtoD</b></font></td><td><font size="+1"><b>V_ULtoE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>V_UItoF</b></font></td><td width="33%"><font size="+1"><b>V_UItoD</b></font></td><td><font size="+1"><b>V_UItoE</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Data type interconversions. See <I><a href="#ItoF">V_ItoF</a></I>!</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="varianceC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_varianceC</b></font></td><td width="33%"><font size="+1"><b>VD_varianceC</b></font></td><td><font size="+1"><b>VE_varianceC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Variance of a one-dimensional distribution with respect to a pre-set value</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_varianceC( fVector X, ui size, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::varianceC( T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_varianceC( X:fVector; size:UInt; C:Single ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>var = (1 / size) * sum( (X<sub>i</sub> - C)<sup>2</sup> )</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The variance is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mean">VF_mean</a>,&nbsp;&nbsp; <a href="#varianceV">VF_varianceV</a>,&nbsp;&nbsp; <a href="#ssq">VF_ssq</a>,&nbsp;&nbsp; <a href="#ssqdevC">VF_ssqdevC</a>,&nbsp;&nbsp; <a href="#linregress">VF_linregress</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="varianceCwW"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_varianceCwW</b></font></td><td width="33%"><font size="+1"><b>VD_varianceCwW</b></font></td><td><font size="+1"><b>VE_varianceCwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;Variance with weights&quot; of a one-dimensional distribution with respect to a pre-set value.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_varianceCwW( fVector X, fVector Wt, ui size, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::varianceCwW( const vector&lt;T&gt;& Wt, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_varianceCwW( X, Wt:fVector; size:UInt; C:Single ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>var = (1 / sum( Wt<sub>i</sub> )) * sum( Wt<sub>i</sub> * (X<sub>i</sub> - C)<sup>2</sup> )
<BR>The weights need not be normalized.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>variance of the distribution.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#meanwW">VF_meanwW</a>,&nbsp;&nbsp; <a href="#varianceC">VF_varianceC</a>,&nbsp;&nbsp; <a href="#varianceVwW">VF_varianceVwW</a>,&nbsp;&nbsp; <a href="#linregress">VF_linregress</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="varianceV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_varianceV</b></font></td><td width="33%"><font size="+1"><b>VD_varianceV</b></font></td><td><font size="+1"><b>VE_varianceV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Variance between two one-dimensional distributions.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_varianceV( fVector X, fVector Y, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::varianceV( const vector&lt;T&gt;& Y );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_varianceV( X, Y:fVector; size:UInt ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>var = (1 / size) * sum( (X<sub>i</sub> - Y<sub>i</sub>)<sup>2</sup> )</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The variance is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#mean">VF_mean</a>,&nbsp;&nbsp; <a href="#varianceC">VF_varianceC</a>,&nbsp;&nbsp; <a href="#ssq">VF_ssq</a>,&nbsp;&nbsp; <a href="#ssqdevV">VF_ssqdevV</a>,&nbsp;&nbsp; <a href="#linregress">VF_linregress</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="varianceVwW"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_varianceVwW</b></font></td><td width="33%"><font size="+1"><b>VD_varianceVwW</b></font></td><td><font size="+1"><b>VE_varianceVwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;Variance with weights&quot; between two one-dimensional distributions.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>float VF_varianceVwW( fVector X, fVector Y, fVector Wt, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>T vector&lt;T&gt;::varianceVwW( const vector&lt;T&gt;& Y, const vector&lt;T&gt;& Wt );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>function VF_varianceVwW( X, Y, Wt:fVector; size:UInt ):</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>var = (1 / sum(Wt<sub>i</sub>)) * sum( Wt<sub>i</sub> * (X<sub>i</sub> - Y<sub>i</sub>)<sup>2</sup> )
<BR>The weights need not be normalized.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>weighted variance</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#meanwW">VF_meanwW</a>,&nbsp;&nbsp; <a href="#chi2">VF_chi2</a>,&nbsp;&nbsp; <a href="#varianceV">VF_varianceV</a>,&nbsp;&nbsp; <a href="#varianceCwW">VF_varianceCwW</a>,&nbsp;&nbsp; <a href="#linregress">VF_linregress</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="vector"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_vector</b></font></td><td width="33%"><font size="+1"><b>VD_vector</b></font></td><td><font size="+1"><b>VE_vector</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_vector</b></font></td><td width="33%"><font size="+1"><b>VCD_vector</b></font></td><td><font size="+1"><b>VCE_vector</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_vector</b></font></td><td width="33%"><font size="+1"><b>VPD_vector</b></font></td><td><font size="+1"><b>VPE_vector</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_vector</b></font></td><td width="20%"><font size="+1"><b>VBI_vector</b></font></td><td width="20%"><font size="+1"><b>VSI_vector</b></font></td><td width="20%"><font size="+1"><b>VLI_vector</b></font></td><td><font size="+1"><b>VQI_vector</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_vector</b></font></td><td width="20%"><font size="+1"><b>VUB_vector</b></font></td><td width="20%"><font size="+1"><b>VUS_vector</b></font></td><td width="20%"><font size="+1"><b>VUL_vector</b></font></td><td><font size="+1"><b>VUI_vector</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Memory allocation for a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>fVector VF_vector( ui size );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>function VF_vector( size:UInt ): fVector;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Based on memory model and environment, the most appropriate allocation procedure is chosen by these functions. Failure to allocate memory always leads to an error message and a subsequent program abort (similar to the error handling of the &quot;new&quot; operator). To release the memory thus allocated, <I><a href="#free">V_free</a>,&nbsp;&nbsp; <a href="#freeAll">V_freeAll</a></I>, or <I><a href="#nfree">V_nfree</a></I> should be used (the latter only in C/C++).
<BR>Note: the declaration of a vector (e.g., as fVector) reserves only a name, but no memory!
<BR>See <a href="HANDBOOK.HTM#chap4_1">chapter&nbsp;4.1</a> if you are interested in details of the implementation.
<BR>Do not use this function in connection with the object-oriented interface <I>VecObj</I>. It has its own automated memory allocation procedure incorporated into the constructors, see <a href="HANDBOOK.HTM#chap3">chapter&nbsp;3</a>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If there is not enough memory available, or if size is zero, an error message &quot;Not enough memory&quot; is displayed and the program aborted.
<BR>16-bit models (except HUGE):
<BR>If more than 64 kB of memory are requested, an error message &quot;Vector &gt; 64 kB not possible&quot; is displayed and the program aborted.
<BR>32-bit:
<BR>If more than 4 GB of memory are requested, an error message &quot;Vector &gt; 4 GB not possible&quot; is displayed and the program aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>Pointer to the allocated memory</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I>malloc,&nbsp;&nbsp; calloc</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="vector0"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_vector0</b></font></td><td width="33%"><font size="+1"><b>VD_vector0</b></font></td><td><font size="+1"><b>VE_vector0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_vector0</b></font></td><td width="33%"><font size="+1"><b>VCD_vector0</b></font></td><td><font size="+1"><b>VCE_vector0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_vector0</b></font></td><td width="33%"><font size="+1"><b>VPD_vector0</b></font></td><td><font size="+1"><b>VPE_vector0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_vector0</b></font></td><td width="20%"><font size="+1"><b>VBI_vector0</b></font></td><td width="20%"><font size="+1"><b>VSI_vector0</b></font></td><td width="20%"><font size="+1"><b>VLI_vector0</b></font></td><td><font size="+1"><b>VQI_vector0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_vector0</b></font></td><td width="20%"><font size="+1"><b>VUB_vector0</b></font></td><td width="20%"><font size="+1"><b>VUS_vector0</b></font></td><td width="20%"><font size="+1"><b>VUL_vector0</b></font></td><td><font size="+1"><b>VUI_vector0</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Memory allocation for a vector and initialization of all elements with 0</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>fVector VF_vector0( ui size );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>function VF_vector0( size:UInt ): fVector;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The functions of this family are almost identical to those of the <I><a href="#vector">VF_vector</a></I> family; in addition to allocating memory, they initialize all elements with 0. (Calls to <I><a href="#vector">VF_vector</a></I> and <I>VF_vector0</I> may be mixed; they use the same tables to keep track of the handles and pointers). For further information, see <I><a href="#vector">VF_vector</a></I>.
<BR>Do not use this function in connection with the object-oriented interface. It has its own automated memory allocation procedure incorporated into the constructors, see <a href="HANDBOOK.HTM#chap3">chapter&nbsp;3</a>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If there is not enough memory available, or if size is zero, an error message &quot;Not enough memory&quot; is displayed and the program aborted.
<BR>16-bit models (except HUGE):
<BR>If more than 64 kB of memory are requested, an error message &quot;Vector &gt; 64 kB not possible&quot; is displayed and the program aborted.
<BR>32-bit:
<BR>If more than 4 GB of memory are requested, an error message &quot;Vector &gt; 4 GB not possible&quot; is displayed and the program aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>A pointer to the allocated memory is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I>malloc,&nbsp;&nbsp; calloc</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="visC"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_visC</b></font></td><td width="33%"><font size="+1"><b>VD_visC</b></font></td><td><font size="+1"><b>VE_visC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Visibility (or contrast) function of a vector with respect to a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_visC( fVector Y, fVector X, ui size, float C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::visC( const vector&lt;T&gt;& X, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_visC( Y, X:fVector; size:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = vis( X<sub>i</sub>, C ) = (X<sub>i</sub> - C) / (X<sub>i</sub> + C)
<BR>These functions are generalizations of the &quot;visibility&quot; or &quot;contrast&quot; function used in optics, where the contrast between two intensities is defined as their difference divided by their sum.
<BR>For X<sub>i</sub>=C, the visibility is defined as 0, even in the case of X<sub>i</sub>=C=0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#redV">VF_redV</a>,&nbsp;&nbsp; <a href="#addC">VF_addC</a>,&nbsp;&nbsp; <a href="#subC">VF_subC</a>,&nbsp;&nbsp; <a href="#divC">VF_divC</a>,&nbsp;&nbsp; <a href="#visV">VF_visV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="visV"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_visV</b></font></td><td width="33%"><font size="+1"><b>VD_visV</b></font></td><td><font size="+1"><b>VE_visV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VFx_visV</b></font></td><td width="33%"><font size="+1"><b>VDx_visV</b></font></td><td><font size="+1"><b>VEx_visV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Visibility function of one vector with respect to another</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFmath.h&gt;
<BR>void VF_visV( fVector Z, fVector X, fVector Y, ui size );
<BR>void VFx_visV( fVector Z, fVector X, fVector Y, ui size, float A, float B );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::visV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y );
<BR>void vector&lt;T&gt;::x_visV( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y, T A, T B );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFmath;
<BR>procedure VF_visV( Z, X, Y:fVector; size:UInt );
<BR>procedure VFx_visV( Z, X, Y:fVector; size:UInt; A, B:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal versions: 
<BR>Z<sub>i</sub> = vis( X<sub>i</sub>, Y<sub>i</sub> )
<BR>&nbsp;&nbsp;&nbsp;&nbsp;= (X<sub>i</sub> - Y<sub>i</sub>) / (X<sub>i</sub> + Y<sub>i</sub>)
<BR>expanded versions: 
<BR>Z<sub>i</sub> = vis( A*X<sub>i</sub>+B, Y<sub>i</sub> )
<BR>For X<sub>i</sub>=Y<sub>i</sub>, the visibility is defined as 0, even in the case of X<sub>i</sub>=Y<sub>i</sub>=0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#visC">VF_visC</a>,&nbsp;&nbsp; <a href="#addV">VF_addV</a>,&nbsp;&nbsp; <a href="#subV">VF_subV</a>,&nbsp;&nbsp; <a href="#divV">VF_divV</a>,&nbsp;&nbsp; <a href="#redV">VF_redV</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="Welch"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_Welch</b></font></td><td width="33%"><font size="+1"><b>VD_Welch</b></font></td><td><font size="+1"><b>VE_Welch</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>&quot;Welch&quot; window for use in spectral analysis</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_Welch( fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::Welch();</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_Welch( X:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X<sub>i</sub> = 1 - ( (i - 0.5*(size - 1)) / (0.5*(size + 1)) )<sup>2</sup></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#Parzen">VF_Parzen</a>,&nbsp;&nbsp; <a href="#Hanning">VF_Hanning</a>,&nbsp;&nbsp; <a href="#spectrum">VF_spectrum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="write"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_write</b></font></td><td width="33%"><font size="+1"><b>VD_write</b></font></td><td><font size="+1"><b>VE_write</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VCF_write</b></font></td><td width="33%"><font size="+1"><b>VCD_write</b></font></td><td><font size="+1"><b>VCE_write</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VPF_write</b></font></td><td width="33%"><font size="+1"><b>VPD_write</b></font></td><td><font size="+1"><b>VPE_write</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_write</b></font></td><td width="20%"><font size="+1"><b>VBI_write</b></font></td><td width="20%"><font size="+1"><b>VSI_write</b></font></td><td width="20%"><font size="+1"><b>VLI_write</b></font></td><td><font size="+1"><b>VQI_write</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_write</b></font></td><td width="20%"><font size="+1"><b>VUB_write</b></font></td><td width="20%"><font size="+1"><b>VUS_write</b></font></td><td width="20%"><font size="+1"><b>VUL_write</b></font></td><td><font size="+1"><b>VUI_write</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Write a vector in ASCII format to a stream.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_write( FILE *stream, fVector X, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::write( FILE *stream );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_write( var Stream:Text; X:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>size elements of X are written to stream in ASCII format. By default, one element is written per line. To use these functions, stream must already be open for write operations in text format.
<P>The number format and the separation of consecutive elements may be specified using <I><a href="#setWriteFormat">VF_setWriteFormat</a></I> (C/C++ only) and <I><a href="#setWriteSeparate">VF_setWriteSeparate</a></I>, respectively. See these functions for details.
<P>Storing data in ASCII format is useful if the data have to be readable by human eyes, or if they are to be exported into other programs which are not able to read machine-format numbers. If avoidable, these functions should not be used for the storage of intermediate results that later have again to be read in. Instead, the function pairs of the <I><a href="#store">VF_store</a></I> / <I><a href="#recall">VF_recall</a></I> family are recommended for the following reasons: conversion into ASCII format is slow, may lead to round-off errors, and requires much more disk memory than storage in machine format.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#setWriteFormat">VF_setWriteFormat</a>,&nbsp;&nbsp; <a href="#setWriteSeparate">VF_setWriteSeparate</a>,&nbsp;&nbsp; <a href="#nwrite">VF_nwrite</a>,&nbsp;&nbsp; <a href="#read">VF_read</a>,&nbsp;&nbsp; <a href="#store">VF_store</a>,&nbsp;&nbsp; <a href="#cprint">VF_cprint</a>,&nbsp;&nbsp; <a href="#print">VF_print</a>,&nbsp;&nbsp; fprintf</I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="xcorr"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_xcorr</b></font></td><td width="33%"><font size="+1"><b>VD_xcorr</b></font></td><td><font size="+1"><b>VE_xcorr</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Cross-correlation function of two vectors.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_xcorr( fVector Z, fVector X, fVector Y, ui size );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::xcorr( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_xcorr( Z, X, Y:fVector; size:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The cross-correlation function (CCF) of X and Y is calculated and stored in Z in wrap-around order: Z<sub>0</sub> to Z<sub>size/2-1</sub> contain the CCF for zero and positive lags. Beginning with the most negative lag in Z<sub>size/2+1</sub>, the elements up to Z<sub>size-1</sub> contain the CCF for negative lags. Since this function assumes X to be periodic, the CCF for the most positive lag is identical to the CCF for the most negative lag. This element is stored as Z<sub>size/2</sub>.
<BR>To get the CCF into normal order, you may call
<BR><font face="courier new"> <a href="#rotate">VF_rotate</a>( Z, Z, size, size/2 );</font>
<BR>After that, the zero point is at the position size/2.
<P>In case X is non-periodic, end effects should be avoided by the methods described in connection with <I><a href="#convolve">VF_convolve</a></I>.
<P>About special versions with the prefixes <I>VFs_</I> and <I>VFl_</I>, consult <a href="HANDBOOK.HTM#chap4_8">chapter&nbsp;4.8.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If size is not a power of 2, <I><a href="#FFT">VF_FFT</a></I> (on which <I>VF_xcorr</I> is based) complains &quot;Size must be an integer power of 2&quot; and the program is aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#FFT">VF_FFT</a>,&nbsp;&nbsp; <a href="#convolve">VF_convolve</a>,&nbsp;&nbsp; <a href="#autocorr">VF_autocorr</a>,&nbsp;&nbsp; <a href="#spectrum">VF_spectrum</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="xor"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VI_xor</b></font></td><td width="20%"><font size="+1"><b>VBI_xor</b></font></td><td width="20%"><font size="+1"><b>VSI_xor</b></font></td><td width="20%"><font size="+1"><b>VLI_xor</b></font></td><td><font size="+1"><b>VQI_xor</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="20%"><font size="+1"><b>VU_xor</b></font></td><td width="20%"><font size="+1"><b>VUB_xor</b></font></td><td width="20%"><font size="+1"><b>VUS_xor</b></font></td><td width="20%"><font size="+1"><b>VUL_xor</b></font></td><td><font size="+1"><b>VUI_xor</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Bit-wise &quot;XOR&quot; operation.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VImath.h&gt;
<BR>void VI_xor( iVector Y, iVector X, ui size, int C );
<BR>void VUL_xor( ulVector Y, ulVector X, ui size, unsigned long C );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::xor( const vector&lt;T&gt;& X, T C );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VImath;
<BR>procedure VI_xor( Y, X:iVector; size:UInt; C:Integer );
<BR>procedure VUL_xor( Y, X:ulVector; size:UInt; C:ULong );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = (X<sub>i</sub>) ^ C
<BR>The bit-wise &quot;exclusive OR&quot; operation is performed on each element X<sub>i</sub> with the bit-mask given by C (i.e., a bit is 0 in Y<sub>i</sub>, if it was either 0 or 1 both in X<sub>i</sub> and C simultaneously. It is 1 if X<sub>i</sub> and C differed in this bit position).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#not">VI_not</a>,&nbsp;&nbsp; <a href="#and">VI_and</a>,&nbsp;&nbsp; <a href="#or">VI_or</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="xprod"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_xprod</b></font></td><td width="33%"><font size="+1"><b>VD_xprod</b></font></td><td><font size="+1"><b>VE_xprod</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Cross-product of two vectors.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VFstd.h&gt;
<BR>void VF_xprod( fVector Z, fVector X, fVector Y );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::xprod( const vector&lt;T&gt;& X, const vector&lt;T&gt;& Y );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VFstd;
<BR>procedure VF_xprod( Z, X, Y:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Z = X x Y
<BR>The cross-product of X and Y is calculated. Since this operation is defined specifically for vectors representing three dimensions in the geometrical sense, there is no parameter &quot;size&quot; for this function. The number of elements is 3 for each of the participating vectors, implicitly.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#scalprod">VF_scalprod</a>,&nbsp;&nbsp; <a href="#Euclid">VF_Euclid</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="xyAutoPlot"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_xyAutoPlot</b></font></td><td width="33%"><font size="+1"><b>VD_xyAutoPlot</b></font></td><td><font size="+1"><b>VE_xyAutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VI_xyAutoPlot</b></font></td><td width="33%"><font size="+1"><b>VBI_xyAutoPlot</b></font></td><td><font size="+1"><b>VSI_xyAutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VLI_xyAutoPlot</b></font></td><td><font size="+1"><b>VQI_xyAutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_xyAutoPlot</b></font></td><td width="33%"><font size="+1"><b>VUB_xyAutoPlot</b></font></td><td><font size="+1"><b>VUS_xyAutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_xyAutoPlot</b></font></td><td><font size="+1"><b>VUI_xyAutoPlot</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Draws a Cartesian coordinate system and plots a Y-vector against an X-vector into it.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void VF_xyAutoPlot( fVector X, fVector Y, ui size, unsigned form, COLORREF color );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::xyAutoPlot( const vector&lt;T&gt;& X, unsigned form, COLORREF color );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure VF_xyAutoPlot( X, Y:fVector; size:UInt; form:UInt; color:COLORREF );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A Cartesian coordinate system is drawn with automatic scaling of the axes and the vector Y is plotted against the vector X. Prior to calling <I>VF_xyAutoPlot</I>, the plotting routines have to be initialized by <I><a href="#initGraph">V_initGraph</a></I> (for DOS programs) or <I><a href="#initPlot">V_initPlot</a></I> (DOS or Windows programs).
<BR>The VecObj version of this function has to be called as a member function of Y (rather than of X).
<P>The font of the axis tick labels is the actual text font. In DOS programs (Borland C++ or Pascal), it may be changed by calling <I>settextstyle</I> before calling <I>VF_xyAutoPlot</I>. In Windows programs (both 16-bit and 32-bit), the font of the current device context is used.
<P>The style of the plot is determined by the parameter "form" which should be constructed using the symbolic constants defined in &lt;Vgraph.h&gt; (C/C++) or in the unit Vgraph (Pascal/Delphi).
<BR>For the line styles, either Borland's BGI notation or the Windows notation may be used both in DOS and Windows programs; the necessary macros for the translation are included in &lt;Vgraph.h&gt; and in the unit Vgraph.
<P><u> 1. Style of lines connecting adjacent data points:</u>
<BR>&nbsp;
<table border width="100%">
<tr valign="top"><td><U>Windows style</U></td><td><U>BGI C/C++</U></td><td><U>BGI Pascal</U></td><td><U>appearance</U></td></tr>
<tr valign="top"><td>PS_SOLID</td><td>SOLID_LINE</td><td>SolidLn</td><td>&#150;&#150;&#150;&#150; (default)</td></tr>
<tr valign="top"><td>PS_DOT</td><td>DOTTED_LINE</td><td>DottedLn</td><td>&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;&#183;</td></tr>
<tr valign="top"><td>PS_DASH</td><td>DASHED_LINE</td><td>DashedLn</td><td>- - - -</td></tr>
<tr valign="top"><td>PS_DASHDOT</td><td>CENTER_LINE</td><td>CenterLn</td><td>- &#183; - &#183; -</td></tr>
<tr valign="top"><td>PS_DASHDOTDOT</td><td>&nbsp;</TD><td>&nbsp;</TD><td>- &#183; &#183; - &#183; &#183;</td></tr>
<tr valign="top"><td>PS_NULL</td><td>NULL_LINE</td><td>NullLn</td><td>(no line at all)</td></tr></table>
<P><u> 2. Symbols used to mark data points:</u>
<BR>&nbsp;
<table border width="100%">
<tr valign="top"><td>SY_NULL</td><td>(no symbol at all)&nbsp;&nbsp;&nbsp;(default)</td></tr>
<tr valign="top"><td>SY_CROSS</td><td><font face="courier new"> x</font></td></tr>
<tr valign="top"><td>SY_PLUS</td><TD>+</td></tr>
<tr valign="top"><td>SY_STAR</td><TD>*</td></tr>
<tr valign="top"><td>SY_CIRCLE</td><TD>o</td></tr>
<tr valign="top"><td>SY_BOX</td><TD></td></tr>
<tr valign="top"><td>SY_DIAMOND</td><td><font face="symbol"> &agrave; </font></td></tr>
<tr valign="top"><td>SY_TRIANGLEUP</td><td><font face="symbol"> D </font></td></tr>
<tr valign="top"><td>SY_TRIANGLEDOWN</td><td><font face="symbol"> &Ntilde; </font></td></tr></table>
<P><u>3. Fill-style of the symbols:</u>
<BR>&nbsp;
<table border width="100%">
<tr valign="top"><td>SY_HOLLOW</td><td>no filling&nbsp;&nbsp;(default)</td></tr>
<tr valign="top"><td>SY_FILLED</td><td>filled</td></tr>
<tr valign="top"><td>SY_DOTTED</td><td>hollow, with a dot at the exact position of the data point</td></tr></table>
<P>The parameter form has to be constructed by adding the appropriate line style, the symbol and its fill-style, e.g. (SOLID_LINE + SY_TRIANGLEUP). Alternatively, the bit-wise &quot;OR&quot; operation may be used, e.g. (PS_SOLID | SY_CIRCLE | SY_DOTTED ).
<BR>In Pascal terms, these examples read:
<BR>(SolidLn + SY_TRIANGLEUP), and (PS_SOLID <b>or</b> SY_CIRCLE <b>or</b> SY_DOTTED).
<P>If any of the line styles except NULL_LINE (or PS_NULL) is chosen, each data point will be represented by at least one pixel in DOS programs. Therefore, dotted or broken lines should be specified only if there are not too many data points. Otherwise, all line styles will eventually look like SOLID_LINE. In Windows programs, these line styles will always be plotted correctly and points will be left out if necessary.
<P>Note that NULL_LINE or PS_NULL has to be explicitly specified, if the data points are not to be connected by lines. Just writing, e.g. (SY_BOX | SY_HOLLOW) would be interpreted as using the default line style, which is SOLID_LINE.
<P>SY_NULL and SY_HOLLOW need not be specified, since these are the default symbol and fill-style, resp. For SY_NULL, SY_CROSS, SY_PLUS, and SY_STAR, the choice of fill-style has no effect.
<P>The parameter &quot;color&quot; denotes the color that is to be used for the plot (the data type COLORREF is unsigned for DOS programs and unsigned long for Windows programs). See the Borland C++ or TurboPascal function <I>setcolor</I> for a description of the colors available in the various graphics modes under DOS. For Windows, the colors BLACK, BLUE, GREEN, CYAN, RED, MAGENTA, BROWN, LIGHTGRAY, DARKGRAY, LIGHTBLUE, LIGHTGREEN, LIGHTCYAN, LIGHTRED, LIGHTMAGENTA, YELLOW, and WHITE are defined in &lt;Vgraph.h&gt; (or the unit Vgraph) by analogy with the COLORS defined in &lt;graphics.h&gt; (or the unit Graph) for the BGI routines, i.e. for DOS programs. Thereby, portability between DOS and Windows programs is improved. For programs designed to run exclusively under Windows, it is nevertheless recommended to use fine-tuned colors defined by the RGB macro, instead of the predefined colors.
<P>The size of the symbols may be modified with the function <I><a href="#setSymbolSize">V_setSymbolSize</a></I>. The thickness of the lines may be modified using <I><a href="#setLineThickness">V_setLineThickness</a></I>.</td></tr>
<tr valign="TOP">
<td>Example of a C/C++ DOS program</td><td><font face="courier new">
#include &lt;VFstd.h&gt;
<BR>#include &lt;VFmath.h&gt;
<BR>#include &lt;Vgraph.h&gt;
<BR>#include &lt;conio.h&gt;
<BR>void main( void )
<BR>{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ui size=101;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fVector X, Y1, Y2;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#initGraph">V_initGraph</a>( &quot;C:\\BorlandC\\BGI\\&quot; );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Be sure the path is correct! */
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X = <a href="#vector">VF_vector</a>( size );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y1 = VF_vector( size );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y2 = VF_vector( size );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ramp">VF_ramp</a>( X, size, -1.0, 2.0/100 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sincos">VFx_sincos</a>( Y1, Y2, X, size, 3.1415927, 0.0, 1.0 );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VF_xyAutoPlot( X, Y1, size,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PS_SOLID | SY_CROSS,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LIGHTGREEN );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#xyDataPlot">VF_xyDataPlot</a>( X, Y2, size,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PS_SOLID | SY_CIRCLE | SY_DOTTED,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LIGHTRED );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getch(); /* interrupt execution while watching;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then press any key */
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closegraph();
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#nfree">V_nfree</a>( 3, Y2, Y1, X );
<BR>}</font>
<P>For a Pascal demo program, see VDEMO.PAS.
<BR>Under Windows, call <I><a href="#initPlot">V_initPlot</a></I> instead of <I><a href="#initGraph">V_initGraph</a></I>, before performing plotting operations.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#xyDataPlot">VF_xyDataPlot</a>,&nbsp;&nbsp; <a href="#yAutoPlot">VF_yAutoPlot</a>,&nbsp;&nbsp; <a href="#autoPlot">VCF_autoPlot</a>,&nbsp;&nbsp; <a href="#drawAxes">V_drawAxes</a>,&nbsp;&nbsp; <a href="#findAxes">V_findAxes</a>,&nbsp;&nbsp; <a href="#setSymbolSize">V_setSymbolSize</a></I>,&nbsp;&nbsp;<a href="HANDBOOK.HTM#chap4_12">chapter&nbsp;4.12</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="xy2AutoPlot"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_xy2AutoPlot</b></font></td><td width="33%"><font size="+1"><b>VD_xy2AutoPlot</b></font></td><td><font size="+1"><b>VE_xy2AutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VI_xy2AutoPlot</b></font></td><td width="33%"><font size="+1"><b>VBI_xy2AutoPlot</b></font></td><td><font size="+1"><b>VSI_xy2AutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VLI_xy2AutoPlot</b></font></td><td><font size="+1"><b>VQI_xy2AutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_xy2AutoPlot</b></font></td><td width="33%"><font size="+1"><b>VUB_xy2AutoPlot</b></font></td><td><font size="+1"><b>VUS_xy2AutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_xy2AutoPlot</b></font></td><td><font size="+1"><b>VUI_xy2AutoPlot</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Draws a Cartesian coordinate system and plots two X-Y vector pairs into it.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void VF_xy2AutoPlot( fVector X1, fVector Y1, ui size1, unsigned form1, COLORREF color1, fVector X2, fVector Y2, ui size2, unsigned form2, COLORREF color2 );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::xy2AutoPlot( const vector&lt;T&gt;& X1, unsigned form1, COLORREF color1, const vector&lt;T&gt;& X2, const vector&lt;T&gt;& Y2, unsigned form2, COLORREF color2 );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure VF_xy2AutoPlot( X1, Y1:fVector; size1:UInt; form1:UInt; color1:COLORREF; X2, Y2:fVector; size2:UInt; form2:UInt; color2:COLORREF );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector Y1 is plotted against the vector X1 and Y2 against X2 after automatically drawing a Cartesian coordinate system. For a description of the parameters form1, form2, and color1, color2, see <I><a href="#xyAutoPlot">VF_xyAutoPlot</a></I>. Prior to calling <I>VF_xy2AutoPlot</I>, the plotting routines have to be initialized by <I><a href="#initGraph">V_initGraph</a></I> or <I><a href="#initPlot">V_initPlot</a></I>.
<BR>The VecObj version of this function has to be called as a member function of Y1 (rather than of X1).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#yAutoPlot">VF_yAutoPlot</a>,&nbsp;&nbsp; <a href="#autoPlot">VCF_autoPlot</a>,&nbsp;&nbsp; <a href="#drawAxes">V_drawAxes</a>,&nbsp;&nbsp; <a href="#findAxes">V_findAxes</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="xyDataPlot"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_xyDataPlot</b></font></td><td width="33%"><font size="+1"><b>VD_xyDataPlot</b></font></td><td><font size="+1"><b>VE_xyDataPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VI_xyDataPlot</b></font></td><td width="33%"><font size="+1"><b>VBI_xyDataPlot</b></font></td><td><font size="+1"><b>VSI_xyDataPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VLI_xyDataPlot</b></font></td><td><font size="+1"><b>VQI_xyDataPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_xyDataPlot</b></font></td><td width="33%"><font size="+1"><b>VUB_xyDataPlot</b></font></td><td><font size="+1"><b>VUS_xyDataPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_xyDataPlot</b></font></td><td><font size="+1"><b>VUI_xyDataPlot</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>X-Y-plot into an existing Cartesian coordinate system.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void VF_xyDataPlot( fVector X, fVector Y, ui size, unsigned form, COLORREF color );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::xyDataPlot( const vector&lt;T&gt;& X, unsigned form, COLORREF color );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure VF_xyDataPlot( X, Y:fVector; size:UInt; form:UInt; color:COLORREF );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The vector Y is plotted against the vector X into a Cartesian coordinate system drawn by a prior call to one of the AutoPlot functions or to <I><a href="#drawAxes">V_drawAxes</a></I>. For a description of the parameters form and color, see <I><a href="#xyAutoPlot">VF_xyAutoPlot</a></I>.
<BR>The VecObj version of this function has to be called as a member function of Y (rather than of X).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#yAutoPlot">VF_yAutoPlot</a>,&nbsp;&nbsp; <a href="#autoPlot">VCF_autoPlot</a>,&nbsp;&nbsp; <a href="#drawAxes">V_drawAxes</a>,&nbsp;&nbsp; <a href="#findAxes">V_findAxes</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="yAutoPlot"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_yAutoPlot</b></font></td><td width="33%"><font size="+1"><b>VD_yAutoPlot</b></font></td><td><font size="+1"><b>VE_yAutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VI_yAutoPlot</b></font></td><td width="33%"><font size="+1"><b>VBI_yAutoPlot</b></font></td><td><font size="+1"><b>VSI_yAutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VLI_yAutoPlot</b></font></td><td><font size="+1"><b>VQI_yAutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_yAutoPlot</b></font></td><td width="33%"><font size="+1"><b>VUB_yAutoPlot</b></font></td><td><font size="+1"><b>VUS_yAutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_yAutoPlot</b></font></td><td><font size="+1"><b>VUI_yAutoPlot</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Draws a Cartesian coordinate system and plots each element of a Y-vector against its index.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;.
<BR>void VF_yAutoPlot( fVector Y, ui size, unsigned form, COLORREF color );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::yAutoPlot( unsigned form, COLORREF color );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure VF_yAutoPlot( Y:fVector; size:UInt; form:UInt; color:COLORREF );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A Cartesian coordinate system is automatically scaled and drawn. Each element of the vector Y is plotted against its index into this coordinate system. For a description of the parameters form and color, see <I><a href="#xyAutoPlot">VF_xyAutoPlot</a></I>. The plotting routines have to be initialized by <I><a href="#initGraph">V_initGraph</a></I> or <I><a href="#initPlot">V_initPlot</a></I> prior to calling <I>VF_yAutoPlot</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#yDataPlot">VF_yDataPlot</a>,&nbsp;&nbsp; <a href="#y2AutoPlot">VF_y2AutoPlot</a>,&nbsp;&nbsp; <a href="#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#autoPlot">VCF_autoPlot</a>,&nbsp;&nbsp; <a href="#drawAxes">V_drawAxes</a>,&nbsp;&nbsp; <a href="#findAxes">V_findAxes</a></I>,&nbsp;&nbsp;<a href="HANDBOOK.HTM#chap4_12">chapter&nbsp;4.12</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="y2AutoPlot"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_y2AutoPlot</b></font></td><td width="33%"><font size="+1"><b>VD_y2AutoPlot</b></font></td><td><font size="+1"><b>VE_y2AutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VI_y2AutoPlot</b></font></td><td width="33%"><font size="+1"><b>VBI_y2AutoPlot</b></font></td><td><font size="+1"><b>VSI_y2AutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VLI_y2AutoPlot</b></font></td><td><font size="+1"><b>VQI_y2AutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_y2AutoPlot</b></font></td><td width="33%"><font size="+1"><b>VUB_y2AutoPlot</b></font></td><td><font size="+1"><b>VUS_y2AutoPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_y2AutoPlot</b></font></td><td><font size="+1"><b>VUI_y2AutoPlot</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Draws a Cartesian coordinate system and plots two Y-vectors, taking the index as the X-axis.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void VF_y2AutoPlot( fVector Y1, ui size1, unsigned form1, COLORREF color1, fVector Y2, ui size2, unsigned form2, COLORREF color2 );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::y2AutoPlot( unsigned form1, COLORREF color1, const vector&lt;T&gt;& Y2, unsigned form2, COLORREF color2 );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure VF_y2AutoPlot( Y1:fVector; size1:UInt; form1:UInt; color1:COLORREF; Y2:fVector; size2:UInt; form2:UInt; color2:COLORREF );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A Cartesian coordinate system is automatically scaled and drawn. Each element of the vectors Y1 and Y2 is plotted at the X-position given by its index. For a description of the parameters form1, form2, and color1, color2, see <I><a href="#xyAutoPlot">VF_xyAutoPlot</a></I>. The plotting routines have to be initialized by <I><a href="#initGraph">V_initGraph</a></I> or <I><a href="#initPlot">V_initPlot</a></I> prior to calling <I><a href="#yAutoPlot">VF_yAutoPlot</a></I>.
<BR>The VecObj version of this function has to be called as a member function of Y1.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#yDataPlot">VF_yDataPlot</a>,&nbsp;&nbsp; VF_y2AutoPlot,&nbsp;&nbsp; <a href="#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#autoPlot">VCF_autoPlot</a>,&nbsp;&nbsp; <a href="#drawAxes">V_drawAxes</a>,&nbsp;&nbsp; <a href="#findAxes">V_findAxes</a></I>,&nbsp;&nbsp;<a href="HANDBOOK.HTM#chap4_12">chapter&nbsp;4.12</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="yDataPlot"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_yDataPlot</b></font></td><td width="33%"><font size="+1"><b>VD_yDataPlot</b></font></td><td><font size="+1"><b>VE_yDataPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VI_yDataPlot</b></font></td><td width="33%"><font size="+1"><b>VBI_yDataPlot</b></font></td><td><font size="+1"><b>VSI_yDataPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VLI_yDataPlot</b></font></td><td><font size="+1"><b>VQI_yDataPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VU_yDataPlot</b></font></td><td width="33%"><font size="+1"><b>VUB_yDataPlot</b></font></td><td><font size="+1"><b>VUS_yDataPlot</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VUL_yDataPlot</b></font></td><td><font size="+1"><b>VUI_yDataPlot</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Plots a Y-vector into an existing Cartesian coordinate system, taking the index as the X-axis.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Vgraph.h&gt;
<BR>void VF_yDataPlot( fVector Y, ui size, unsigned form, COLORREF color );</font></td></tr>
<tr valign="TOP">
<td>C++ VecObj</td><td><font face="courier new">#include &lt;OptiVec.h&gt;
<BR>void vector&lt;T&gt;::yDataPlot( unsigned form, COLORREF color );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses Vgraph;
<BR>procedure VF_yDataPlot( Y:fVector; size:UInt; form:UInt; color:COLORREF );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of the vector Y is plotted into a Cartesian coordinate system that has to be already drawn by a prior call to one of the DataPlot functions or to <I><a href="#drawAxes">V_drawAxes</a></I>. The X-position is given by the index of the Y-element to be plotted. For a description of the parameters form and color, see <I><a href="#xyAutoPlot">VF_xyAutoPlot</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#yAutoPlot">VF_yAutoPlot</a>,&nbsp;&nbsp; <a href="#y2AutoPlot">VF_y2AutoPlot</a>,&nbsp;&nbsp; <a href="#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#autoPlot">VCF_autoPlot</a>,&nbsp;&nbsp; <a href="#drawAxes">V_drawAxes</a>,&nbsp;&nbsp; <a href="#findAxes">V_findAxes</a></I>,&nbsp;&nbsp;<a href="HANDBOOK.HTM#chap4_12">chapter&nbsp;4.12</a></td></tr></table></td></tr>
</table>&nbsp;

<P><a name="chap9"></a>
<H1><HR width="100%">9. Scalar (non-vectorized) Functions </H1>
There are a few non-vectorized functions, stemming from <I>CMATH</I> and <I>XMATH</I>, which are necessary to use <I>VectorLib</I>. They are described here:

<P>&nbsp;<P><a name="fcplx"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>fcplx</b></font></td><td width="33%"><font size="+1"><b>dcplx</b></font></td><td><font size="+1"><b>ecplx</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initialization of cartesian-complex numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>fComplex fcplx( float ReVal, float ImVal );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>dcplx,&nbsp;&nbsp; ecplx</I>)</td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>procedure fcplx( var zy:fComplex; xRe, xIm: Single );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>dcplx,&nbsp;&nbsp; ecplx</I>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>These functions allow to generate complex numbers of the three cartesian data types fComplex, dComplex, and eComplex. <I>CMATH</I> offers overloaded versions of these functions for C++. See <a href="CMATH.HTM#chap2_1">CMATH.HTM, chapter 2.1</a> for details.
<BR>In C/C++, <I>fcplx</I> should be used whenever temporary complex variables are needed as arguments for functions. In this case, fcplx replaces the less elegant direct assignment of the real and imaginary parts, e.g.:
<BR><font face="courier new">&nbsp;&nbsp;z.Re = 3.0; z.Im = 4.0;
<BR>&nbsp;&nbsp;VCF_equC( X, size, z ); /* less convenient */
<BR>&nbsp;&nbsp;VCF_equC( Y, size, fcplx( 3.0, 4.0 )); /* easier */</font>
<BR>In Pascal/Delphi, writing
<BR><font face="courier new">&nbsp;&nbsp;fcplx( z, 3.0, 4.0 );</font>
<BR>is just equivalent to
<BR><font face="courier new">&nbsp;&nbsp;z.Re = 3.0; z.Im = 4.0;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>the generated complex number (C/C++)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#fpolr">fpolr</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="isint"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>isint</b></font></td><td width="33%"><font size="+1"><b>isintl</b></font></td><td><font size="+1"><b>isintd</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>tests if a number is a whole number</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;xmath.h&gt;
<BR>int isint( double x );
<BR>int isintl( long double x );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses xmath;
<BR>function isint( x:Extended ): IntBool;
<BR>function isintd( x:Double ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Returns TRUE (a value different from 0), if x is an integer number. FALSE (0) is returned, if x contains a non-zero fractional part.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>see above</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="isipow2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>isipow2</b></font></td><td width="33%"><font size="+1"><b>sisipow2</b></font></td><td><font size="+1"><b>lisipow2</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>tests if an unsigned integer is an integer power of 2</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;xmath.h&gt;
<BR>int isipow2( unsigned x );
<BR>int sisipow2( unsigned short x );
<BR>int lisipow2( unsigned long x );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses xmath;
<BR>function isipow2( x:UInt ): IntBool;
<BR>function sisipow2( x:USmall ): IntBool;
<BR>function lisipow2( x:ULong ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Returns TRUE (non-zero), if x is an integer power of 2:
<BR>x = 2<sup>n</sup>,&nbsp;&nbsp;&nbsp;n=1,2,3,...
<BR>Otherwise, FALSE (0) is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>see above</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="_log"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>log</b></font></td><td><font size="+1"><b>logd</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Natural logarithm: Pascal/Delphi only!</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax</td><td><font face="courier new">uses xmath;
<BR>function log( x:Extended x ): Extended;
<BR>function logd( x:double x ): Double;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The logarithm of the argument to the basis <I>e</I> is calculated and the result returned. The &quot;extended&quot; version of this function is almost identical to the built-in Pascal function <I>Ln</I>. Only the error handling occurs via the same handler as for the other <I>OptiVec</I> functions, rather than via the built-in handler of Pascal. The &quot;double&quot;-version, <I>logd</I>, is slightly faster.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>A DOMAIN error with NAN (&quot;not-a-number&quot;) as return value results from x &lt; 0 (including -0). A SING error with -HUGE_VAL as return value results from x=0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The natural logarithm of the argument is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#_log2">log2</a>,&nbsp;&nbsp; <a href="#_log2">log2d</a>,&nbsp;&nbsp; <a href="#_log10">log10</a>,&nbsp;&nbsp; <a href="#_log10">log10d</a>,&nbsp;&nbsp; <a href="#log">VF_log</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="_log2"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>log2</b></font></td><td width="33%"><font size="+1"><b>log2l</b></font></td><td><font size="+1"><b>log2d</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Binary logarithm</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;xmath.h&gt;
<BR>double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log2( double x );
<BR>long double&nbsp;&nbsp;log2l( long double x );</font></td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses xmath;
<BR>function log2( x:Extended ): Extended;
<BR>function log2d( x:Double ): Double;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The logarithm of the argument to the basis 2 is calculated and the result returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>A DOMAIN error with NAN (&quot;not-a-number&quot;) as return value results from x &lt; 0 (including -0). A SING error with -HUGE_VAL as return value results from x=0.
<BR>In C/C++, the handling of both errors can be modified via <I>_matherr</I> or <I>_matherrl</I>, resp.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The binary logarithm of the argument is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#_log">log</a>,&nbsp;&nbsp; <a href="#_log10">log10</a>,&nbsp;&nbsp; <a href="#log2">VF_log2</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="_log10"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>log10</b></font></td><td><font size="+1"><b>log10d</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Decadic logarithm: Pascal/Delphi only!</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax</td><td><font face="courier new">uses xmath;
<BR>function log10( x:Extended x ): Extended;
<BR>function log10d( x:double x ): Double;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The logarithm of the argument to the basis 10 is calculated and the result returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>A DOMAIN error with NAN (&quot;not-a-number&quot;) as return value results from x &lt; 0 (including -0). A SING error with -HUGE_VAL as return value results from x=0.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>The decadic logarithm of the argument is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I>log,&nbsp;&nbsp; <a href="#_log">logd</a>,&nbsp;&nbsp; <a href="#_log2">log2</a>,&nbsp;&nbsp; <a href="#_log2">log2d</a>,&nbsp;&nbsp; <a href="#log10">VF_log10</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="fpolr"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>fpolr</b></font></td><td width="33%"><font size="+1"><b>dpolr</b></font></td><td><font size="+1"><b>epolr</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Initialization of polar-complex numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>fPolar fpolr( float MagVal, float ArgVal );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>dpolr,&nbsp;&nbsp; epolr</I>)</td></tr>
<tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">uses VecLib;
<BR>procedure fpolr( var py:fPolar; xMag, xArg: Single );</font>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(similarly <I>dpolr,&nbsp;&nbsp; epolr</I>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>These functions allow to generate numbers of the three polar-complex data types fPolar, dPolar, and ePolar. <I>CMATH</I> offers overloaded versions of these functions for C++. See <a href="CMATH.HTM#chap2_1">CMATH.HTM, chapter 2.1</a> for details.
<BR>In C/C++, <I>fpolr</I> should be used whenever temporary complex variables are needed as arguments for functions. In this case, fpolr replaces the less elegant direct assignment of the Mag and Arg parts, e.g.:
<BR><font face="courier new">&nbsp;&nbsp;p.Mag = 3.0; p.Arg = 1.5708;
<BR>&nbsp;&nbsp;VPF_equC( X, size, p ); /* less convenient */
<BR>&nbsp;&nbsp;VPF_equC( Y, size, fpolr( 3.0, 1.5708 )); /* easier */</font>
<BR>In Pascal/Delphi, writing
<BR><font face="courier new">&nbsp;&nbsp;fpolr( p, 3.0, 1.5708 );</font>
<BR>is just equivalent to
<BR><font face="courier new">&nbsp;&nbsp;p.Mag = 3.0; p.Arg = 1.5708;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>the generated polar-complex number (C/C++)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#fcplx">fcplx</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="quadtod"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>quadtod</b></font></td><td><font size="+1"><b>_quadtold</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>convert a quad into a double or long double: C/C++ only!</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quadtod( quad x );
<BR>long double&nbsp;_quadtold( quad x );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>These functions, along with their counterpart, <I><a href="#setquad">setquad</a></I>, provide the necessary interface for the use of the data type quad within C/C++ compilers which have no complete built-in support for 64-bit integers. If, e.g., the value of a quad (say, of x) has to be printed, this must be done by a function call like
<BR><font face="courier new">printf( &quot;% 20.0Lf&quot;, <I>_quadtold</I>( x ));</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>the value of x is returned as a double or long double.</td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="setquad"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td><font size="+1"><b>setquad</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>converts a long double into a quad: C/C++ only!</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;VecLib.h&gt;
<BR>quad setquad( long double x );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function, along with its counterparts, <I><a href="#quadtod">quadtod</a></I> and <I><a href="#quadtod">_quadtold</a></I>, provides the necessary interface for the use of the data type quad within C/C++ compilers which have no complete built-in support for 64-bit integers.
<BR>If, e.g., quad parameters are required by a function, they have to be passed either as existing variables of this data type, or else as in the following example:
<BR><font face="courier new"><a href="#addC">VQI_addC</a>( QI2, QI1,size, setquad( 53563369.L ));</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>the value of x is returned as a quad.</td></tr></table></td></tr>
</table>

<P><H1>E N D </H1>
Copyright for <I>OptiVec</I> software and documentation
<BR>&copy; 1996-2001 <I>OptiCode</I> - Dr. Martin Sander Software Dev.
<BR>All rights reserved!
</body>
</html>