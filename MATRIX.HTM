<html>
<head>
<title>OptiVec: MatrixLib</title></head>
<body bgcolor="#ffffff" text="#000000" link="#0000ff" vlink="#0000ff" alink="#ff0000">
<TABLE CELLSPACING=0 CELLPADDING=0 WIDTH="100%" >
<TR><TD><IMG SRC="optivec.gif" BORDER=0 WIDTH=280>&nbsp;
</TD><TD><h1><i><b><font size="+4">OptiVec</font></b></i><P>
Version 3</h1>
<BR><h2>for C/C++ and for Pascal/Delphi</h2>
</td></tr><tr><TD>
<i>OptiCode</i>
<BR>Dr. Martin Sander Software Development
<BR>Steinachstr. 9A
<BR>D-69198 Schriesheim
<BR>Germany
<BR><a href="http://www.optivec.com">http://www.optivec.com</a>
<BR>e-mail: <A HREF="mailto:support@optivec.com">support@optivec.com</A> or
<BR><A HREF="mailto:sales@optivec.com">sales@optivec.com</A>
</TD><TD><h1>Part II: <I>MatrixLib</I></h1>
</TD></TR></TABLE>&nbsp;
<BR>A general description of <i>OptiVec</i> is given in <a href="HANDBOOK.HTM">HANDBOOK.HTM</a>.
<BR><a href="HANDBOOK.HTM#chap1_2">Chapter 1.2</a> of that file contains the licence terms for the Shareware version, <a href="HANDBOOK.HTM#chap1_3">Chapter 1.3</a> for the Registered version.
<BR>See <a href="FUNCREF.HTM">FUNCREF.HTM</a> for the description of individual <i>VectorLib</i> functions,
<BR>and <a href="CMATH.HTM">CMATH.HTM</a> for <i>CMATH</i> functions.


<P><A NAME="TOC"></A>
<P><HR WIDTH="100%"><H1>Contents </H1>

&nbsp;&nbsp;<a href="#chap1">1. Introduction</a>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#chap1_1">1.1 Matrix Data Types</a>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#chap1_2">1.2 Prefixes of <i>MatrixLib</i> Functions</a>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#chap1_3">1.3 C/C++ Specifics</a>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#chap1_4">1.4 Pascal/Delphi Specifics</a>
<BR>&nbsp;&nbsp;<a href="#chap2">2. Management of Dynamically Generated Matrices</a>
<BR>&nbsp;&nbsp;<a href="#chap3">3. Initialization of Matrices</a>
<BR>&nbsp;&nbsp;<a href="#chap4">4. Data-Type Conversions</a>
<BR>&nbsp;&nbsp;<a href="#chap5">5. Transposing, Augmenting, Deleting and Extracting Parts from a Matrix</a>
<BR>&nbsp;&nbsp;<a href="#chap6">6. Arithmetic Operations Performed on a Single Row, Column, or the Diagonal</a>
<BR>&nbsp;&nbsp;<a href="#chap7">7. Operations Performed Along All Rows or All Columns Simultaneously, or the Diagonal</a>
<BR>&nbsp;&nbsp;<a href="#chap8">8. Operations Involving Two Rows or Two Colums</a>
<BR>&nbsp;&nbsp;<a href="#chap9">9. Whole-Matrix Arithmetics: Addition, Multiplication</a>
<BR><a href="#chap10">10. Linear Algebra </a>
<BR><a href="#chap11">11. Eigenvalues and Eigenvectors, Matrix Square-Root</a>
<BR><a href="#chap12">12. Two-Dimensional Fourier-Transform Methods</a>
<BR><a href="#chap13">13. Data Fitting</a>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#chap13_1">13.1 Polynomials</a>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#chap13_2">13.2 General Linear Model Functions</a>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#chap13_3">13.3 Non-Linear Models</a>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#chap13_4">13.4 Fitting Multiple Data Sets</a>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#chap13_5">13.5 Helper Functions for Nonlinear Fits</a>
<BR><a href="#chap14">14. Matrix Input and Output</a>
<BR><a href="#chap15">15. Graphical Representation of Matrices</a>
<BR><a href="#chap16">16. Alphabetical Reference for <I>MatrixLib</I></a>

<P><a name="chap1"></a>
<H2><HR WIDTH="100%">1. Introduction</H2>
The <I>MatrixLib</I> part of <I>OptiVec</I> builds upon the principles established in the <I>VectorLib</I> part. You may wish to refer to the introductory chapters of <a href="HANDBOOK.HTM">HANDBOOK.HTM</a>, before reading on for <I>MatrixLib</I>.
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap1_1"></a>
<H3>1.1 Matrix Data Types</H3>
As <i>VectorLib</i> defines vector data types, here are the matrix data types, defined in <i>MatrixLib</i>:
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><B>fMatrix</B></TD><TD>matrix of <B>float</B>s</TD></TR>
<TR><TD><B>dMatrix</B></TD><TD>matrix of <B>double</B>s</TD></TR>
<TR><TD><B>eMatrix</B></TD><TD>matrix of <B>extended (long double)</B></TD></TR>
<TR><TD><B>cfMatrix</B></TD><TD>matrix of <B>fComplex (complex&lt;float&gt;)</B></TD></TR>
<TR><TD><B>cdMatrix</B></TD><TD>matrix of <B>dComplex (complex&lt;double&gt;)</B></TD></TR>
<TR><TD><B>ceMatrix</B></TD><TD>matrix of <B>eComplex (complex&lt;extended&gt;)</B></TD></TR>
</TABLE>
&nbsp;
<BR>The ordering of elements is the same as in the two-dimensional arrays provided by the respective target compilers. This means that the matrices are stored row-wise in <I>MatrixLib</I> versions for C and C++ compilers, but column-wise in the Pascal/Delphi versions.
<BR>At present, integer matrices are defined, but no functions are available for them.

<P>While we recommend to exclusively use these dynamically allocated matrix types, static matrices defined, e.g., as 
<BR><font face="courier new"> float MX[4][6]; </font> (for C/C++), or
<BR><font face="courier new"> MX: array[0..3][0..5] of Single; </font> (for Pascal/Delphi)
<BR>can be used in all <i>MatrixLib</i> functions with the exception of the <I><a href="#multiLinfit">multiLinfit</a></I>
and <I><a href="#multiNonlinfit">multiNonlinfit</a></I> routines.
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap1_2"></a>
<H3>1.2 Prefixes of <I>MatrixLib</I> Functions</H3>
Each <i>MatrixLib</i> function has a prefix defining the data type on which it acts:
<TABLE BORDER WIDTH="100%" >
<TR><TD><B>Prefix:</B></TD> <TD><B>Arguments:</B></TD></TR>
<TR><TD WIDTH="25%">MF_</TD><TD><B>fMatrix</B>, <B>float</B> and <B>fVector</B></TD></TR>
<TR><TD>MD_</TD><TD><B>dMatrix</B>, <B>double</B> and <B>dVector</B></TD></TR>
<TR><TD>ME_</TD><TD><B>eMatrix</B>, <B>extended (long double)</B> and <B>eVector</B></TD></TR>
<TR><TD>MCF_</TD><TD><B>cfMatrix</B>, <B>fComplex</B> and <B>cfVector</B></TD></TR>
<TR><TD>MCD_</TD><TD><B>cdMatrix</B>, <B>dComplex</B> and <B>cdVector&nbsp;</B></TD></TR>
<TR><TD>MCE_</TD><TD><B>ceMatrix</B>, <B>eComplex</B> and <B>ceVector</B></TD></TR>
</TABLE>&nbsp;

<BR>In a few cases, the prefix is augmented by a three-letter code denoting special matrix properties:
<UL>
<LI><B><I>MFdia_</I></B> means that the function expects a diagonal matrix (i.e., a square matrix which has non-zero elements only on the diagonal); as there is no sense in storing all the zeros, diagonal matrix are actually stored as vectors, holding only the diagonal elements.
<BR>&nbsp;<LI><I><B>MFsym_ </B></I> denotes a function which expects the input matrix to be symmetric. At present, only <I><a href="#eigenvalues">MFsym_eigenvalues</a></I> and <I><a href="#sqrt">MFsym_sqrt</a></I> make use of this assumption.
<BR>&nbsp;<LI><I><B>MFtrd_</B></I> means the function is for a tridiagonal matrix (i.e., a square matrix with non-zero elements only on the diagonal plus or minus one column). A tridiagonal matrix has to be entered in the form of a matrix with three rows, representing the three vectors actually containing non-zero data. In other words, the original matrix 
<BR>&nbsp;<table border cellspacing=1><tr valign="top"><td>d<sub>0</sub></td><td>u<sub>0</sub></td><td>0</td><td>&#183;&#183;&#183;</td><td>&nbsp;</TD><td>&nbsp;</TD></tr>
<tr valign="top"><td>l<sub>1</sub></td><td>d<sub>1</sub></td><td>u<sub>1</sub></td><td>0</td><td>&#183;&#183;&#183;</td><td>&nbsp;</TD></tr>
<tr valign="top"><td>0</td><td>l<sub>2</sub></td><td>d<sub>2</sub></td><td>u<sub>2</sub></td><td>0</td><td>&#183;&#183;&#183;</td></tr>
<tr valign="top"><td>&nbsp;</TD><td>&nbsp;</TD><td>&nbsp;</TD><td>&#183;&#183;&#183;</td><td>&nbsp;</TD><td>&nbsp;</TD></tr>
<tr valign="top"><td>&nbsp;</TD><td>&nbsp;</TD><td>&nbsp;</TD><td>l<sub>N-2</sub></td><td>d<sub>N-2</sub></td><td>u<sub>N-2</sub></td></tr>
<tr valign="top"><td>&nbsp;</TD><td>&nbsp;</TD><td>&nbsp;</TD><td>0</td><td>l<sub>N-1</sub></td><td>d<sub>N-1</sub></td></tr>
</table>&nbsp;
<BR>is compacted into the form<BR>&nbsp;
<table border cellspacing=1><tr valign="top"><td>u<sub>0</sub>&nbsp;</td><td>u<sub>1</sub>&nbsp;</td><td>u<sub>2</sub>&nbsp;</td><td>&#183;&#183;&#183;&nbsp;</td><td>u<sub>N-2</sub>&nbsp;</td><td> * </td></tr>
<tr valign="top"><td>d<sub>0</sub></td><td>d<sub>1</sub></td><td>d<sub>2</sub></td><td>&#183;&#183;&#183;</td><td>d<sub>N-2</sub></td><td>d<sub>N-1</sub>&nbsp;</td></tr>
<tr valign="top"><td> * </td><td>l<sub>1</sub></td><td>l<sub>2</sub></td><td>&#183;&#183;&#183;</td><td>l<sub>N-2</sub></td><td>l<sub>N-1</sub></td></tr>
</table>&nbsp;
<BR>The elements l<sub>0</sub> and u<sub>N-1</sub>, marked with an asterisk, are undefined and never used.
</UL>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap1_3"></a>
<H3>1.3 C/C++ Version Specifics:</H3>
In the C/C++ version of <i>MatrixLib</i>, all functions taking matrix arguments exist in a second form. In this form, all matrix arguments are replaced by pointers to the first elements of the respective matrices. You can explicitly use the second form by leaving away the underbar of the function-name prefix. Calling
<BR><font face="courier new"> <a href="#mulM">MF_mulM</a>( MC, MA, MB, htA, lenA, lenB );</font>
<BR>is equivalent to calling
<BR><font face="courier new">MFmulM(&(MC[0][0]),&(MA[0][0]),&(MB[0][0]),htA,lenA,lenB);</font> or 
<BR><font face="courier new">MFmulM( MC[0], MA[0], MB[0], htA, lenA, lenB );</font>
<BR>Actually, the run-time routines are in the second form, and the macros defined in &lt;MFstd.h&gt; etc. convert calls to the first form into calls to the second form.
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap1_4"></a>
<H3>1.4 Pascal/Delphi Version Specifics:</H3>
In the Pascal/Delphi version of <i>MatrixLib</i>, matrices of all data types are actually defined as pointers to the element M[0][0]. This means you can pass static matrices (like <font face="courier new">MX: array[0..5][0..5] of Single; </font>) to <i>MatrixLib</i> functions with the address operator:
<BR><font face="courier new"><a href="#equ1">MF_equ1</a>( @(MX[0][0]), 6 );</font>
<P><U>Delphi 4 or higher:</U>
<BR>From version 4 on, Delphi offers dynamic arrays. In the one-dimensional case, they are declared as &quot;array of Single&quot;, &quot;array of Double&quot;, etc. The VecLib unit includes short-cut definitions for these types as fArray,
dArray, etc. By simply type-casting fArrays into fVectors, they can be used with all <i>VectorLib</i> functions.
<P>The situation is more complicated in the two-dimensional case. Dynamic two-dimensional arrays can be created in Delphi by declaring them as &quot;array of fArray&quot;, &quot;array of dArray&quot;, etc. Short-cut definitions for these types are also given in the VecLib unit, as f2DArray, d2DArray, etc. As a consequence of the described way of defining 2D-Arrays in Delphi, each row of a matrix is stored in a separate vector. This means that the matrix elements do no longer occupy a single, contiguous memory space. Therefore, 2DArrays cannot be used directly with <i>MatrixLib</i> functions.
Instead, they have to be copied into matrices by calling <I><a href="#2DArrayToMatrix">MF_2DArrayToMatrix</a></I> etc., before <i>MatrixLib</i> functions can be used on them. The reverse conversion is available as <I><a href="#MatrixTo2DArray">MF_MatrixTo2DArray</a></I>.
<P>In the following chapters, a brief summary of all <i>MatrixLib</i> function is given, ordered into groups according to their functionality. At the end of this file, <a href="#chap16">Kap.&nbsp;16</a> describes all <I>MatrixLib</I>functions in alphabetical order.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap2"></a>
<H2><HR width="100%">2. Management of Dynamically Generated Matrices</H2>
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="#matrix">MF_matrix</a></TD><TD>allocate memory for a matrix</TD></TR>
<TR><TD><a href="#matrix0">MF_matrix0</a></TD><TD>allocate memory and set all elements 0</TD></TR>
<TR><TD><a href="#free">M_free</a></TD><TD>free one matrix (data-type independent)</TD></TR>
<TR><TD><a href="#nfree">M_nfree</a></TD><TD>free n matrices (data-type independent; only C/C++)</TD></TR>
<TR><TD><a href="#freeAll">V_freeAll</a></TD><TD>free all existing vectors and matrices</TD></TR>
</TABLE>&nbsp;
<BR><I>OptiVec</I>'s dynamically allocated matrices are aligned on 32-byte boundaries, which allows for optimum cache-line matching for the Pentium processor and its currently available successors and competitors.
<P><U>C/C++ version only:</U>
<BR><i>OptiVec</i>'s dynamically allocated matrices can be addressed just like two-dimensional static arrays of C/C++. If you have, e.g., an <font face="courier new">fMatrix MX;</font> and a variable <font face="courier new">float a;</font>, you can write a line like
<BR><font face="courier new"> a = MX[3][5];</font>

<P><U>Both C/C++ and Pascal/Delphi versions:</U>
<BR>There are two functions addressing single elements. These functions are the only means to address elements in Pascal/Delphi, and are also needed for getting around the pointer arithmetics bug in some versions of Borland C++:
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="#Pelement">MF_Pelement</a></TD><TD>Pointer to a specific matrix element</TD></TR>
<TR><TD><a href="#element">MF_element</a></TD><TD>value of a specific matrix element</TD></TR>
</TABLE>

<BR>To assign a value to a specific matrix element, you should use the syntax
<BR><font face="courier new"> *(MF_Pelement( MX, ht, len, 3, 4 )) = 3.0; /* for C/C++*/ 
<BR>MF_Pelement( MX, ht, len, 3, 4 )^ := 3.0; (* for Pascal/Delphi *)</font>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap3"></a>
<H2><HR width="100%">3. Initialization of Matrices</H2>
In order to initialize all matrix elements with the same value, or to perform the same arithmetic operation on all matrix elements simultaneously, please use the respective <i>VectorLib</i> function. You can do so, because all matrices are in fact stored as vectors, occupying a contiguous space in memory. All you have to do is to pass the first row of the matrix (rather than the matrix itself) to the vector function. Fore example, you can initialize all matrix elements with a constant C by calling
<BR><font face="courier new"> <a href="FUNCREF.HTM#equC">VF_equC</a>( MA[0], ht*len, C ); /* C/C++ */
<BR>VF_equC( MA, ht*len, C ); (* Pascal/Delphi *)</font>
<BR>As you shall see, some of the most common operations of this kind are also explicitly defined in <i>MatrixLib</i>, like initialization with zero, <I><a href="#equ0">MF_equ0</a></I>, or multiplication by a constant, available as <I><a href="#mulC">MF_mulC</a></I> (see <a href="#chap9">Kap.&nbsp;9</a>). Here are the typical matrix initialization functions:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="#equ0">MF_equ0</a></TD><TD>set all elements to 0</TD></TR>
<TR><TD><a href="#equ1">MF_equ1</a></TD><TD>identity matrix: set all diagonal elements to 1.0, all others to 0</TD></TR>
<TR><TD><a href="#equm1">MF_equm1</a></TD><TD>negative identity matrix: set all diagonal elements to -1.0, all others to 0</TD></TR>
<TR><TD><a href="#outerprod">MF_outerprod</a></TD><TD>matrix formed by the &quot;outer product&quot; of two vectors</TD></TR>
<TR><TD><a href="#Row_equ0">MF_Row_equ0</a></TD><TD>set all elements of one specific row to 0</TD></TR>
<TR><TD><a href="#Col_equ0">MF_Col_equ0</a></TD><TD>set all elements of one specific column to 0</TD></TR>
<TR><TD><a href="#Dia_equ0">MF_Dia_equ0</a></TD><TD>set all diagonal elements to 0</TD></TR>
<TR><TD><a href="#Row_equC">MF_Row_equC</a></TD><TD>set all elements of one specific row to the constant C</TD></TR>
<TR valign="top"><TD><a href="#Col_equC">MF_Col_equC</a></TD><TD>set all elements of one specific column to the constant C</TD></TR>
<TR><TD><a href="#Dia_equC">MF_Dia_equC</a></TD><TD>set all diagonal elements to the constant C</TD></TR>
<TR><TD><a href="#Row_equV">MF_Row_equV</a></TD><TD>copy a vector into one specific row</TD></TR>
<TR><TD><a href="#Col_equV">MF_Col_equV</a></TD><TD>copy a vector into one specific column</TD></TR>
<TR><TD><a href="#Dia_equV">MF_Dia_equV</a></TD><TD>copy a vector into the diagonal</TD></TR>
<TR><TD><a href="#Trd_equM">MF_Trd_equM</a></TD><TD>copy a compacted tridiagonal matrix into a general matrix</TD></TR>
<TR><TD><a href="#equM">MF_equM</a></TD><TD>make one matrix the copy of another</TD></TR>
<TR><TD><a href="#neg">MF_neg</a></TD><TD>make one matrix the negative of another</TD></TR>
<TR><TD><a href="#conj">MCF_conj</a></TD><TD>make one matrix the complex conjugate of another</TD></TR>
<TR><TD><a href="#hermconj">MCF_hermconj</a></TD><TD>make one matrix the Hermitian conjugate of another: MB = MA<SUP>T*</SUP></TD></TR>
<TR valign="top"><TD><a href="#UequL">MF_UequL</a></TD><TD>copy lower-diagonal elements into upper-diagonal by index-reflection, so as to get a symmetric matrix</TD></TR>
<TR><TD><a href="#LequU">MF_LequU</a></TD><TD>copy upper-diagonal elements into lower-diagonal</TD></TR>
</TABLE>
&nbsp;
<BR>Two-dimensional windows for spectral analysis are provided by:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="#Hanning">MF_Hanning</a></TD><TD>Hanning window</TD></TR>
<TR><TD><a href="#Parzen">MF_Parzen</a></TD><TD>Parzen window</TD></TR>
<TR><TD><a href="#Welch">MF_Welch</a></TD><TD>Welch window</TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap4"></a>
<H2><HR width="100%">4. Data-Type Conversions</H2>
Matrices of every data type can be converted into every other. Only a few examples are given; the rest should be obvious.
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="#FtoD">M_FtoD</a></TD><TD><B>fMatrix</B> to <B>dMatrix</B></TD></TR>
<TR><TD><a href="#FtoD">M_EtoD</a></TD><TD><B>eMatrix</B> to <B>dMatrix</B> (with overflow protection)</TD></TR>
<TR><TD><a href="#FtoD">M_CDtoCF</a></TD><TD><B>cdMatrix</B> to <B>cfMatrix</B> (with overflow protection)</TD></TR>
<TR><TD><a href="#FtoD">M_DtoE</a></TD><TD><B>dMatrix</B> to <B>eMatrix</B></TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap5"></a>
<H2><HR width="100%">5. Transposing, Augmenting, Deleting and Extracting Parts from a Matrix</H2>
<TABLE BORDER WIDTH="100%" >
<TR><TD><a href="#transpose">MF_transpose</a></TD><TD>transpose a matrix: MB = MA<SUP>T</SUP></TD></TR>
<TR><TD><a href="#hermconj">MCF_hermconj</a></TD><TD>Hermitian conjugate: MB = MA<SUP>T*</SUP></TD></TR>
<TR><TD><a href="#submatrix">MF_submatrix</a></TD><TD>extract a submatrix</TD></TR>
<TR valign="top"><TD><a href="#submatrix_equM">MF_submatrix_equM</a></TD><TD>copy a submatrix back into another (normally larger) matrix</TD></TR>
<TR><TD><a href="#Row_extract">MF_Row_extract</a></TD><TD>extract a single row and copy it into a vector</TD></TR>
<TR><TD><a href="#Col_extract">MF_Col_extract</a></TD><TD>extract a single column and copy it into a vector</TD></TR>
<TR valign="top"><TD><a href="#Dia_extract">MF_Dia_extract</a></TD><TD>extract the diagonal and copy it into a vector</TD></TR>
<TR><TD><a href="#Trd_extract">MF_Trd_extract</a></TD><TD>extract a tridiagonal matrix from a general matrix</TD></TR>
<TR><TD><a href="#Row_insert">MF_Row_insert</a></TD><TD>augment a matrix by insertion of one row</TD></TR>
<TR><TD><a href="#Col_insert">MF_Col_insert</a></TD><TD>augment a matrix by insertion of one column</TD></TR>
<TR><TD><a href="#Row_delete">MF_Row_delete</a></TD><TD>delete one row of a matrix</TD></TR>
<TR><TD><a href="#Col_delete">MF_Col_delete</a></TD><TD>delete one column of a matrix</TD></TR>
</TABLE>&nbsp;
<BR>Note that, in contrast to the <i>VectorLib</i> functions <I><a href="FUNCREF.HTM#insert">VF_insert</a></I> and <I><a href="FUNCREF.HTM#delete">VF_delete</a></I>, insertion and deletion of rows or columns of matrices is not done in-place. Rather, the <I>MF_Row_insert</I> etc. store the augmented or truncated input matrix MA in an output matrix MB. If augmenting, be sure that MB is large enough to accommodate the enlarged output matrix! Normally, this means that you have to create a new matrix MB before calling <I>MF_???_insert</I> and possibly discarding MA by calling
<font face="courier new"><a href="#free">M_free</a>( MA );</font> afterwards.
<BR>If this process is repeated more often, you might wish to avoid the inefficiency of these &quot;create new&quot; - &quot;copy&quot; - &quot;delete old&quot; cycles. In this case, you can create MA from the outset with the maximum dimensions that will eventually be reached (or, if these are not known beforehand, with the upper limits of both ht and len). During the build-up process then, you have to keep track of the actual dimensions and use these (not the maxima
used for allocation!) in all <i>MatrixLib</i> function calls. Now you may overwrite the original matrix by the augmented one in each call to <I>MF_???_insert</I> as, e.g., in:
<BR><font face="courier new">MF_Row_insert( MA, MA, actualhtA+1, actuallenA+1, 0, X );</font>
<P><u>C++ with dynamic matrices only:</u>
<BR>If you overwrite MA by MB in the column insertion/deletion functions, you lose the possibility of accessing individual matrix elements by writing <font face="courier new">MB[i][j]</font>. This is no longer possible, as the row pointers of the output matrix will still remain those of the input matrix. Then, you can only use <I><a href="#element">MF_element</a></I> and <I><a href="#Pelement">MF_Pelement</a></I> to access individual elements. If you are exclusively inserting/deleting rows rather than columns, on the other hand, the row pointers remain valid.

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap6"></a>
<H2><HR width="100%">6. Arithmetic Operations Performed on a Single Row, Column, or the Diagonal</H2>
<TABLE BORDER WIDTH="100%" >
<TR><TD><a href="#Row_addC">MF_Row_addC</a></TD><TD>add a constant to all elements of a specific row</TD></TR>
<TR><TD><a href="#Col_addC">MF_Col_addC</a></TD><TD>add a constant to all elements of a specific column</TD></TR>
<TR><TD><a href="#Dia_addC">MF_Dia_addC</a></TD><TD>add a constant to all diagonal elements</TD></TR>
<TR><TD><a href="#Row_addV">MF_Row_addV</a></TD><TD>add corresponding vector elements to all elements of a specific row</TD></TR>
<TR><TD><a href="#Col_addV">MF_Col_addV</a></TD><TD>add corresponding vector elements to all elements of a specific column</TD></TR>
<TR><TD><a href="#Dia_addV">MF_Dia_addV</a></TD><TD>add corresponding vector elements to the diagonal elements</TD></TR>
</TABLE>
&nbsp;
<BR>A few examples should suffice for the other functions of this family:&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD><a href="#Row_subC">MF_Row_subC</a></TD><TD>subtract a constant from all elements of a specific row</TD></TR>
<TR><TD><a href="#Col_subrC">MF_Col_subrC</a></TD><TD>reverse substraction: difference between column elements and a constant</TD></TR>
<TR><TD><a href="#Dia_mulV">MF_Dia_mulV</a></TD><TD>multiply the diagonal elements with corresponding vector elements</TD></TR>
<TR><TD><a href="#Row_divV">MF_Row_divV</a></TD><TD>divide all elements of a specific row by corresponding vector elements</TD></TR>
<TR><TD><a href="#Col_divrC">MF_Col_divrC</a></TD><TD>reverse division: division of a constant by the individual column elements</TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap7"></a>
<H2><HR width="100%">7. Operations Performed Along All Rows or All Columns Simultaneously, or Along the Diagonal of a Square Matrix</H2>

<TABLE BORDER WIDTH="100%" >
<TR><TD><a href="#Rows_max">MF_Rows_max</a></TD><TD>store the maxima of all rows in a column vector</TD></TR>
<TR><TD><a href="#Cols_max">MF_Cols_max</a></TD><TD>store the maxima of all colums in a row vector</TD></TR>
<TR><TD><a href="#Dia_max">MF_Dia_max</a></TD><TD>return the maximum of the diagonal as a scalar</TD></TR>
<TR><TD><a href="#Rows_absmax">MF_Rows_absmax</a></TD><TD>store the absolute maxima of all rows in a column vector</TD></TR>
<TR><TD><a href="#Cols_absmax">MF_Cols_absmax</a></TD><TD>store the absolute maxima of all colums in a row vector</TD></TR>
<TR><TD><a href="#Dia_absmax">MF_Dia_absmax</a></TD><TD>return the absolute maximum of the diagonal as a scalar</TD></TR>
<TR><TD><a href="#Rows_sum">MF_Rows_sum</a></TD><TD>sum, taken along rows and stored in a column vector</TD></TR>
<TR><TD><a href="#Cols_sum">MF_Cols_sum</a></TD><TD>sum, taken along colums and stored in a row vector</TD></TR>
<TR><TD><a href="#Dia_sum">MF_Dia_sum</a></TD><TD>sum of the diagonal elements</TD></TR>
<TR><TD><a href="#Rows_prod">MF_Rows_prod</a></TD><TD>product, taken along rows and stored in a column vector</TD></TR>
<TR><TD><a href="#Cols_prod">MF_Cols_prod</a></TD><TD>product, taken along colums and stored in a row vector</TD></TR>
<TR><TD><a href="#Dia_prod">MF_Dia_prod</a></TD><TD>product of the diagonal elements</TD></TR>
<TR><TD><a href="#Rows_runsum">MF_Rows_runsum</a></TD><TD>running sum along rows</TD></TR>
<TR><TD><a href="#Cols_runsum">MF_Cols_runsum</a></TD><TD>running sum along columns</TD></TR>
<TR><TD><a href="#Rows_runprod">MF_Rows_runprod</a></TD><TD>running product along rows</TD></TR>
<TR><TD><a href="#Cols_runprod">MF_Cols_runprod</a></TD><TD>running product along columns</TD></TR>
<TR><TD><a href="#Rows_rotate">MF_Rows_rotate</a></TD><TD>rotate all rows by a specified number of positions</TD></TR>
<TR><TD><a href="#Cols_rotate">MF_Cols_rotate</a></TD><TD>rotate all columns by a specified number of positions</TD></TR>
<TR><TD><a href="#Rows_reflect">MF_Rows_reflect</a></TD><TD>set the upper halves of all rows equal to their reversed lower halves</TD></TR>
<TR><TD><a href="#Cols_reflect">MF_Cols_reflect</a></TD><TD>set the upper halves of all columns equal to their reversed lower halves</TD></TR>
</TABLE>
<P>Please note that multiplying all rows or all columns by one and the same vector is equivalent to a multiplication by a diagonal matrix, which is provided by <I><a href="#mulMdia">MF_mulMdia</a></I> and <I><a href="#TmulMdia">MF_TmulMdia</a></I>.
<BR>For all of the above functions involving maxima (<I>...max, &nbsp;...absmax</I>), the corresponding minima are found by the functions named <I>...min,&nbsp; ...absmin</I>. 
<BR>For complex numbers, maxima can be defined by various criteria. The following table summarizes the functions finding them (again, of course, the corresponding functions for the minima exist as well):<BR>&nbsp;

<TABLE BORDER WIDTH="100%" >
<TR VALIGN="TOP"><TD><a href="#Rows_absmax">MCF_Rows_absmax</a></TD><TD>store the maxima of the absolute values of all rows in a (real-valued) column vector</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Cols_absmax">MCF_Cols_absmax</a></TD><TD>store the maxima of the absolute values of all colums in a (real-valued) row vector</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Dia_absmax">MCF_Dia_absmax</a></TD><TD>return the maximum of the absolute values of the diagonal elements as a (real) scalar</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Rows_absmaxReIm">MCF_Rows_absmaxReIm</a></TD><TD>find the maximum absolute values of all real and of all imaginary parts separately along the rows of a matrix; merge the maxima into complex numbers, and store them in a column vector</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Cols_absmaxReIm">MCF_Cols_absmaxReIm</a></TD><TD>find the maximum absolute values of all real and of all imaginary parts separately along the columns of a matrix; merge the maxima into complex numbers, and store them in a row vector</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Dia_absmaxReIm">MCF_Dia_absmaxReIm</a></TD><TD>find the maximum absolute values of all real and of all imaginary parts separately along the diagonal of a square matrix; merge these two maxima into one complex number and return it as a scalar</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Rows_cabsmax">MCF_Rows_cabsmax</a></TD><TD>find the complex numbers of largest magnitude along rows and store these row maxima in a (complex) column vector</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Cols_cabsmax">MCF_Cols_cabsmax</a></TD><TD>find the complex numbers of largest magnitude along columns and store these column maxima in a (complex) row vector</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Dia_cabsmax">MCF_Dia_cabsmax</a></TD><TD>find the complex number of largest magnitude along the diagonal of a square matrix and return it as a (complex) scalar</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Rows_maxReIm">MCF_Rows_maxReIm</a></TD><TD>find the maxima of all real and of all imaginary parts separately along the rows of a matrix; merge the maxima into complex numbers, and store them in a column vector</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Cols_maxReIm">MCF_Cols_maxReIm</a></TD><TD>find the maxima of all real and of all imaginary parts separately along the columns of a matrix; merge the maxima into complex numbers, and store them in a row vector</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Dia_maxReIm">MCF_Dia_maxReIm</a></TD><TD>find the maximum of all real and of all imaginary parts separately along the diagonal of a square matrix; merge these two maxima into one complex number and return it as a scalar</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Rows_sabsmax">MCF_Rows_sabsmax</a></TD><TD>find the complex numbers of largest sum |Re|+|Im| along rows and store these row maxima in a (complex) column vector</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Cols_sabsmax">MCF_Cols_sabsmax</a></TD><TD>find the complex numbers of largest sum |Re|+|Im| along columns and store these column maxima in a (complex) row vector</TD></TR>
<TR VALIGN="TOP"><TD><a href="#Dia_sabsmax">MCF_Dia_sabsmax</a></TD><TD>find the complex number of largest sum |Re|+|Im| along the diagonal of a square matrix and return it as a (complex) scalar</TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap8"></a>
<H2><HR width="100%">8. Operations Involving Two Rows or Two Colums</H2>

<TABLE BORDER WIDTH="100%" >
<TR><TD><a href="#Rows_exchange">MF_Rows_exchange</a></TD><TD>exchange two rows</TD></TR>
<TR><TD><a href="#Cols_exchange">MF_Cols_exchange</a></TD><TD>exchange two columns</TD></TR>
<TR><TD><a href="#Rows_add">MF_Rows_add</a></TD><TD>add one row to another (destination += source)</TD></TR>
<TR><TD><a href="#Cols_add">MF_Cols_add</a></TD><TD>add one column to another</TD></TR>
<TR><TD><a href="#Rows_sub">MF_Rows_sub</a></TD><TD>subtract one row from another (destination -= source)</TD></TR>
<TR><TD><a href="#Cols_sub">MF_Cols_sub</a></TD><TD>subtract one column from another</TD></TR>
<TR><TD><a href="#Rows_Cadd">MF_Rows_Cadd</a></TD><TD>add scaled row to another (destination += C * source)</TD></TR>
<TR><TD><a href="#Cols_Cadd">MF_Cols_Cadd</a></TD><TD>add scaled column to another</TD></TR>
<TR><TD><a href="#Rows_lincomb">MF_Rows_lincomb</a></TD><TD>linear combination of two rows</TD></TR>
<TR><TD><a href="#Cols_lincomb">MF_Cols_lincomb</a></TD><TD>linear combination of two columns</TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap9"></a>
<H2><HR width="100%">9. Whole-Matrix Arithmetics: Addition, Multiplication</H2>
<B>a) Element-wise operations</B>
<TABLE BORDER WIDTH="100%" >
<TR valign="top"><TD WIDTH="25%"><a href="#addM">MF_addM</a></TD><TD>add two matrices</TD></TR>
<TR valign="top"><TD><a href="#addMT">MF_addMT</a></TD><TD>add one matrix and the transpose of another matrix<BR>
MC = MA + MB<sup>T</sup></TD></TR>
<TR valign="top"><TD><a href="#subM">MF_subM</a></TD><TD>subtract one matrix from another</TD></TR>
<TR valign="top"><TD><a href="#subMT">MF_subMT</a></TD><TD>subtract a transposed matrix<BR>
MC = MA - MB<sup>T</sup></TD></TR>
<TR valign="top"><TD><a href="#subrMT">MF_subrMT</a></TD><TD>subtract a matrix from another, transposed, matrix<BR>
MC = MB<sup>T</sup> - MA</TD></TR>
<TR valign="top"><TD><a href="#mulC">MF_mulC</a></TD><TD>multiply all matrix elements by a constant</TD></TR>
<TR valign="top"><TD><a href="#mulC">MCF_mulReC</a></TD><TD>multiply all elements of a complex matrix by a real number</TD></TR>
<TR valign="top"><TD><a href="#divC">MF_divC</a></TD><TD>divide all matrix elements by a constant</TD></TR>
<TR valign="top"><TD><a href="#divC">MCF_divReC</a></TD><TD>divide all elements of a complex matrix by a real number</TD></TR>
<TR valign="top"><TD><a href="#addM">MFs_addM</a></TD><TD>scaled addition of two matrices:<BR>
MC = c * (MA + MB)</TD></TR>
<TR valign="top"><TD><a href="#addMT">MFs_addMT</a></TD><TD>scaled addition of one matrix and the transpose of another:<BR>MC = c * (MA + MB<sup>T</sup>)</TD></TR>
<TR valign="top"><TD><a href="#subM">MFs_subM</a></TD><TD>scaled subtraction of two matrices:<BR>
MC = c * (MA - MB)</TD></TR>
<TR valign="top"><TD><a href="#subMT">MFs_subMT</a></TD><TD>scaled subtraction of one matrix and the transpose of another:<BR>MC = c * (MA - MB<sup>T</sup>)</TD></TR>
<TR valign="top"><TD><a href="#subrMT">MFs_subrMT</a></TD><TD>scaled reverse subtraction of one matrix and the transpose of another:<BR>MC = c * (MB<sup>T</sup> - MA)</TD></TR>
<TR valign="top"><TD><a href="#lincomb">MF_lincomb</a></TD><TD>linear combination:<BR>
MC = ca * MA + cb * MB</TD></TR>
</TABLE>
<P><B>b) Matrix multiplication:</B>
<TABLE BORDER WIDTH="100%" >
<TR valign="top"><TD WIDTH="25%"><a href="#mulV">MF_mulV</a></TD><TD>multiply a matrix by a column vector:<BR>
Y = MA * X</TD></TR>
<TR valign="top"><TD><a href="#TmulV">MF_TmulV</a></TD><TD>multiply the transpose of a matrix by a column vector:<BR>
Y = MA<SUP>T</SUP> * X</TD></TR>
<TR valign="top"><TD><a href="#mulM">VF_mulM</a></TD><TD>multiply a row vector by a matrix:<BR>
Y = X * MA</TD></TR>
<TR valign="top"><TD><a href="#mulMT">VF_mulMT</a></TD><TD>multiply a row vector by the transpose of a matrix:<BR>
Y = X * MA<SUP>T</SUP></TD></TR>
<TR valign="top"><TD><a href="#mulM">MF_mulM</a></TD><TD>multiply two matrices:<BR>
MC = MA * MB</TD></TR>
<TR valign="top"><TD><a href="#mulMT">MF_mulMT</a></TD><TD>multiply one matrix by the transpose of another matrix:<BR>
MC = MA * MB<SUP>T</SUP></TD></TR>
<TR valign="top"><TD><a href="#TmulM">MF_TmulM</a></TD><TD>multiply the transpose of a matrix by another matrix:<BR>
MC = MA<SUP>T</SUP> * MB</TD></TR>
<TR valign="top"><TD><a href="#TmulMT">MF_TmulMT</a></TD><TD>multiply the transpose of one matrix by the transpose of another matrix:<BR>
MC = MA<SUP>T</SUP> * MB<SUP>T</SUP></TD></TR>
<TR valign="top"><TD><a href="#mulMH">MCF_mulMJ</a></TD><TD>multiply one matrix by the hermitian conjugate of another matrix:<BR>
MC = MA * MB<SUP>T *</SUP></TD></TR>
<TR valign="top"><TD><a href="#HmulM">MCF_HmulM</a></TD><TD>multiply the hermitian conjugate of a matrix by another matrix:<BR>
MC = MA<SUP>T *</SUP> * MB</TD></TR>
</TABLE>
<P><B>c) Multiplications of general matrices by diagonal matrices or <I>vice versa</I></B>
<BR>The diagonal matrix is passed to the respective function as a vector.
<TABLE BORDER WIDTH="100%" >
<TR valign="top"><TD WIDTH="25%"><a href="#mulMdia">MF_mulMdia</a></TD><TD>multiply a general matrix by a diagonal matrix:<BR>
MC = MA * MBDia</TD></TR>
<TR valign="top"><TD><a href="#TmulMdia">MF_TmulMdia</a></TD><TD>multiply the transpose of a matrix by a diagonal matrix:<BR>
MC = MA<SUP>T</SUP> * MBDia</TD></TR>
<TR valign="top"><TD><a href="#dia_mulM">MFdia_mulM</a></TD><TD>multiply a diagonal matrix by a general matrix:<BR>
MC = MADia * MB</TD></TR>
<TR valign="top"><TD><a href="#dia_mulMT">MFdia_mulMT</a></TD><TD>multiply a diagonal matrix by the transpose of a general matrix:<BR>
MC = MADia * MB<SUP>T</SUP></TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap10"></a>
<H2><HR width="100%">10. Linear Algebra</H2>
There are three groups of linear algebra functions. The first group consists of &quot;easy-to-use&quot; versions which can be used as black-box functions without caring about their internal working. The second group consists of functions
for LU decomposition and its applications. The third group, finally, is devoted to Singular Value Decomposition (SVD). Except for the functions based on SVD, the linear algebra functions are available both for real and for complex matrices.
<BR>Here are the &quot;easy-to-use&quot; versions of linear algebra functions:
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="#solve">MF_solve</a></TD>
<TD>solve simultaneous linear equations (using LU decomposition)</TD></TR>
<TR><TD><a href="#inv">MF_inv</a></TD><TD>invert a matrix</TD></TR>
<TR><TD><a href="#det">MF_det</a></TD><TD>determinant of a matrix</TD></TR>
<TR><TD><a href="#solveBySVD">MF_solveBySVD</a></TD><TD>solve simultaneous linear equations, using Singular Value Decomposition</TD></TR>
<TR><TD><a href="#safeSolve">MF_safeSolve</a></TD><TD>tries first solution by LUD; if that fails, SVD is done</TD></TR>
</TABLE>&nbsp;
<BR>Now some functions for explicit LU decomposition and for treatment of LU decomposed matrices:
<TABLE BORDER WIDTH="100%" >
<TR><TD><a href="#LUdecompose">MF_LUdecompose</a>&nbsp;</TD><TD>decompose into LU form</TD></TR>
<TR><TD><a href="#LUDresult">MF_LUDresult</a></TD><TD>check if <a href="#LUdecompose">MF_LUdecompose</a> was successful</TD></TR>
<TR><TD><a href="#LUDsetEdit">MF_LUDsetEdit</a></TD><TD>set editing threshold for <a href="#LUdecompose">MF_LUdecompose</a>; may be used to work around singularities</TD></TR>
<TR><TD><a href="#LUDgetEdit">MF_LUDgetEdit</a></TD><TD>retrieve currently set threshold</TD></TR>
<TR><TD><a href="#LUsolve">MF_LUsolve</a></TD><TD>solve simultaneous linear equations, given the matrix in LU form</TD></TR>
<TR><TD><a href="#LUimprove">MF_LUimprove</a></TD><TD>improve the accuracy of the solution of an LU-decomposed linear system by iteration</TD></TR>
<TR><TD><a href="#LUinv">MF_LUinv</a></TD><TD>invert matrix already composed into LU form</TD></TR>
<TR><TD><a href="#LUdet">MF_LUdet</a></TD><TD>determinant of matrix already composed into LU form</TD></TR>
</TABLE>&nbsp;
<BR>Singular Value Decomposition and related functions are offered as:
<TABLE BORDER WIDTH="100%" >
<TR><TD><a href="#SVdecompose">MF_SVdecompose</a>&nbsp;</TD>
<TD>Singular Value Decomposition</TD></TR>
<TR><TD><a href="#SVsolve">MF_SVsolve</a></TD><TD>solve SV-decomposed set of linear equations</TD></TR>
<TR><TD><a href="#SVDsetEdit">MF_SVDsetEdit</a></TD><TD>set threshold for Singular Value editing</TD></TR>
<TR><TD><a href="#SVDgetEdit">MF_SVDgetEdit</a></TD><TD>retrieve current threshold for Singular Value editing</TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap11"></a>
<H2><HR width="100%">11. Eigenvalues and Eigenvectors, Matrix Square-Root</H2>
At present, only the special, but most frequent case of symmetric real matrices is covered:
<TABLE BORDER WIDTH="100%" >
<TR><TD><a href="#eigenvalues">MFsym_eigenvalues</a>&nbsp;</TD>
<TD>eigenvalues with or without eigenvectors of a symmetric real matrix</TD></TR>
<TR><TD><a href="#sqrt">MFsym_sqrt</a>&nbsp;</TD>
<TD>square-root of a symmetric, positive definite matrix</TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap12"></a>
<H2><HR width="100%">12. Two-Dimensional Fourier-Transform Methods</H2>
By analogy with the corresponding one-dimensional Fourier Transform methods described in the <a href="HANDBOOK.HTM#chap4_8"><i>VectorLib</i> handbook</a>, the following functions for the two-dimensional case are available in <i>MatrixLib</i>:
<TABLE BORDER WIDTH="100%" >
<TR valign="top"><TD WIDTH="20%"><a href="#FFT">MF_FFTtoC</a></TD><TD>Forward Fast Fourier Transform (FFT) of a real matrix; the result is a cartesian complex matrix</TD></TR>
<TR valign="top"><TD><a href="#FFT">MF_FFT</a></TD><TD>Forward and backward FFT of real matrices; using symmetry relations, the complex result is packed into a real matrix of the same size as the input matrix</TD></TR>
<TR valign="top"><TD><a href="#FFT">MCF_FFT</a></TD><TD>Forward and backward FFT of complex matrices</TD></TR>
<TR valign="top"><TD><a href="#convolve">MF_convolve</a></TD><TD>Convolution with a spatial response function</TD></TR>
<TR><TD><a href="#deconvolve">MF_deconvolve</a></TD><TD>Deconvolution</TD></TR>
<TR><TD><a href="#filter">MF_filter</a></TD><TD>Spatial filtering</TD></TR>
<TR><TD><a href="#autocorr">MF_autocorr</a></TD><TD>Spatial autocorrelation</TD></TR>
<TR><TD><a href="#xcorr">MF_xcorr</a></TD><TD>Spatial cross-correlation</TD></TR>
<TR><TD><a href="#spectrum">MF_spectrum</a></TD><TD>Spatial frequency spectrum</TD></TR>
</TABLE>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>
<P><a name="chap13"></a>
<H2><HR width="100%">13. Data Fitting</H2>
<i>MatrixLib</i> provides a broad range of data fitting functions for various classes of model functions. Let us first show you an overview over the available functions, before we describe the various classes of model functions and their treatment in <I>OptiVec</I> fitting functions in detail.<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="25%"><a href="FUNCREF.HTM#linregress">VF_linregress</a></TD>
<TD>equally-weighted linear regression on X-Y data</TD></TR>
<TR><TD><a href="FUNCREF.HTM#linregress">VF_linregresswW</a></TD>
<TD>the same with non-equal weighting</TD></TR>
<TR><TD><a href="#polyfit">VF_polyfit</a></TD>
<TD>fitting of one X-Y data set to a polynomial</TD></TR>
<TR><TD><a href="#polyfit">VF_polyfitwW</a></TD>
<TD>the same for non-equal data-point weighting</TD></TR>
<TR><TD><a href="#linfit">VF_linfit</a></TD>
<TD>fitting of one X-Y data set to an arbitrary function linear in its parameters</TD></TR>
<TR><TD><a href="#linfit">VF_linfitwW</a></TD>
<TD>the same for non-equal data-point weighting</TD></TR>
<TR><TD><a href="#nonlinfit">VF_nonlinfit</a></TD>
<TD>fitting of one X-Y data set to an arbitrary, possibly non-linear function</TD></TR>
<TR><TD><a href="#nonlinfit">VF_nonlinfitwW</a></TD>
<TD>the same for non-equal data-point weighting</TD></TR>
<TR><TD><a href="#multiLinfit">VF_multiLinfit</a></TD>
<TD>fitting of multiple X-Y data sets to one common linear function</TD></TR>
<TR><TD><a href="#multiLinfit">VF_multiLinfitwW</a></TD>
<TD>the same for non-equal data-point weighting</TD></TR>
<TR><TD><a href="#multiNonlinfit">VF_multiNonlinfit</a></TD>
<TD>fitting of multiple X-Y data sets to one common nonlinear function</TD></TR>
<TR><TD><a href="#multiNonlinfit">VF_multiNonlinfitwW</a></TD>
<TD>the same for non-equal data-point weighting</TD></TR>
<TR><TD><a href="#Mlinfit">MF_linfit</a></TD><TD>fit X-Y-Z data to a function linear in its parameters</TD></TR>
<TR><TD><a href="#Mlinfit">MF_linfitwW</a></TD><TD>the same with non-equal weighting of individual data points</TD></TR>
<TR><TD><a href="#Mnonlinfit">MF_nonlinfit</a></TD><TD>fit X-Y-Z data to an arbitrary, possibly non-linear function</TD></TR>
<TR><TD><a href="#Mnonlinfit">MF_nonlinfitwW</a></TD><TD>the same for non-equal data-point weighting</TD></TR>
<TR><TD><a href="#MmultiLinfit">MF_multiLinfit</a></TD><TD>fit multiple X-Y-Z data sets to one common linear function</TD></TR>
<TR><TD><a href="#MmultiLinfit">MF_multiLinfitwW</a></TD><TD>the same for non-equal data-point weighting</TD></TR>
<TR><TD><a href="#MmultiNonlinfit">MF_multiNonlinfit</a></TD><TD>fit multiple X-Y-Z data sets to one common nonlinear function</TD></TR>
<TR><TD><a href="#MmultiNonlinfit">MF_multiNonlinfitwW</a>&nbsp;</TD><TD>the same for non-equal data-point weighting</TD></TR>
</TABLE>&nbsp;
<BR>Now let us have a look at the various classes of model functions. The most simple one is a straight line, 
<BR><font face="courier new">Y<sub>i</sub> = a * X<sub>i</sub> + b;</font>
<BR>Fitting <font face="courier new">Y = f(X)</font> data to a straight line is called &quot;linear regression&quot; and accomplished by <a href="FUNCREF.HTM#linregress">VF_linregress</a>. 
<BR>The next level of sophistication are polynomials, described in the following paragraph:

<P><a name="chap13_1"></a>
<H3>13.1 Polynomials</H3>
Polynomials are functions of the form
<BR><font face="courier new"> Y<sub>i</sub> = a<sub>0</sub> + a<sub>1</sub>X<sub>i</sub> + a<sub>2</sub>X<sub>i</sub><sup>2</sup> ... a<sub>n</sub>X<sub>i</sub><sup>n</sup></font>
<BR>Just as linear regression, polynomial fitting is available for Y-X data (<a href="#polyfit">VF_polyfit</a>), but not for MZ=f(X,Y) data. In polynomial fitting, you are interested in the coefficients <I>a<sub>i</sub></I> up to a certain limit, the degree <I>n</I> of the polynomial. In the simplest form, all coefficients are treated as free parameters, without the possibility of &quot;fixing&quot; those whose values you happen to know beforehand. Polynomial fitting is most useful for degrees of 2 to 4. With degrees higher than 5, you will be able to fit almost any data - but the resulting coefficients will be at best inaccurate and at worst useless, as already very little experimental noise will strongly influence the balance of the higher terms. If you do need polynomials of higher degrees, you should carefully examine your problem to see which terms you can eliminate. This leads us from polynomials to the next class of fitting functions, namely:

<P><a name="chap13_2"></a>
<H3>13.2 General Linear Model Functions</H3>
In the general linear case, you have to write the model function yourself and pass it as an argument to the fitting routine. The word &quot;linear&quot; means that the model function consists of a linear combination of basis functions each of which depends linearly on the fitting coefficients:
<BR><font face="courier new"> y = a<sub>0</sub>f<sub>0</sub>(x) + a<sub>1</sub>f<sub>1</sub>(x) + a<sub>2</sub>f<sub>2</sub>(x)...</font>
<BR>The individual functions f<sub>i</sub>(x) may be non-linear in x, but not in the coefficients <I>a<sub>i</sub></I>. For example, <BR>
<font face="courier new"> y = a<sub>0</sub>sin(x)+ a<sub>1</sub>cos(x)</font><BR>
is a valid linear fitting function, but <BR>
<font face="courier new">y = sin(a<sub>0</sub>x)+ cos(a<sub>1</sub>x)</font><BR>
is not.
<table width="100%"><tr><td width="10%">&nbsp;</TD><td>
<U>Pascal with DOS only:</U>
<BR>The module, containing the model function to be passed to <I><a href="#linfit">VF_linfit</a></I>, must be compiled using the &quot;Force Far Calls&quot; option (Options/Compiler in the IDE or switch {$F+} ) !</td></tr></table>&nbsp;

<BR>For general linear fits, the model function has to be provided in a form which calculates the individual basis functions for each x-value present in the data set. The above example with sine and cosine functions would be coded in C/C++ as
<P><font face="courier new"> void LinModel( fVector BasFuncs, float x, unsigned nfuncs )
<BR>{
<BR>&nbsp;&nbsp;BasFuncs[0] = sin(x);
<BR>&nbsp;&nbsp;BasFuncs[1] = cos(x);
<BR>}</font>
<P>Note that the coefficients <I>a<sub>i</sub></I> are not used in the model function itself. The argument <I>nfuncs</I> (which is neglected in the above example) allows to use a variable number of basis functions. It is also possible to switch fitting parameters &quot;on&quot; and &quot;off&quot;, i.e., &quot;free&quot; or &quot;fixed&quot;. To this end, the routine <I><a href="#linfit">VF_linfit</a></I> takes a &quot;status&quot; array as an argument. For all members of the parameter vector that are to be treated as free, the corresponding &quot;status&quot; entry must be set to 1. If status<sub>i</sub> is set to 0, the corresponding parameter, <I>a<sub>i</sub></I>, is treated as fixed at its value upon input.
<BR>Internally, <I>VF_linfit</I> employs a Singular Value Decomposition algorithm to obtain a solution even for (near-)singular linear systems. Thereby, coefficients <I>a<sub>i</sub></I> whose significance is lower than a threshold, Thresh, are
set to 0 instead of infinity. This threshold can be modified by calling <I><a href="#setLinfitNeglect">VF_setLinfitNeglect</a></I>. The current threshold can be retrieved by <I><a href="#getLinfitNeglect">VF_getLinfitNeglect</a></I>.
<P>Having noted above that functions like
<BR><font face="courier new"> y = sin(a<sub>0</sub>x)+ cos(a<sub>1</sub>x)</font>
<BR>require their own treatment, we arrive at the last and most general class of model functions:

<P><a name="chap13_3"></a>
<H3>13.3 Non-Linear Models</H3>
As described above, fits to linear model functions (which include, of course, simple polynomials) are performed internally by solving a set of coupled linear equations - which is basically a simple matrix inversion process. The situation for non-linear model functions is completely different: no closed-form solution exists, and the fitting problem can be solved only iteratively. Therefore, fitting to non-linear models is much more time-consuming (by 3-5 orders of magnitude!) than fitting to linear models. Two non-linear fitting algorithms are offered:
<UL><LI>the Levenberg-Marquardt method, and the
<LI>Downhill-Simplex method by Nelder and Mead.</UL>
As a starting-point, it is normally a good idea to choose a combination of both (choose <font face="courier new">FitOptions.LevelOfMethod = 3</font>, see below).
<BR>The fundamental difference between linear and non-linear data fitting is reflected also in the required formulation of the model functions. In contrast to the linear case, here it is not the individual basis functions which are needed. Rather, the model function will be called by <I><a href="#nonlinfit">VF_nonlinfit</a></I> with the whole X-vector as input argument and has to return the whole Y-vector. For the above non-linear sine and cosine example, this would be coded in C/C++ as
<P><font face="courier new"> void NonlinModel( fVector Y, fVector X, ui size)
<BR>{
<BR>&nbsp;&nbsp;for( ui i=0; i&lt;size; i++ ) 
<BR>&nbsp;&nbsp;Y[i] = sin( a[0]*X[i] ) + cos( a[1]*X[i] );
<BR>}</font>
<P>The parameter array &quot;a&quot; should be global. It is passed as an argument to <I>VF_nonlinfit</I>, and its elements are changed during the fitting process. Upon input, &quot;a&quot; must (!) contain your initial &quot;best guess&quot; of the parameters. The better your guess, the faster <I>VF_nonlinfit</I> will converge. If your initial
guess is too far off, convergence might be very slow or even never attained.
<P>All <I>nonlinfit</I> functions return the figure-of-merit of the best parameter array &quot;A&quot; found. To perform the fit, these functions need not only the fitting function itself, but also its partial derivatives with respect to the individual coefficients. Therefore, an argument &quot;Derivatives&quot; is required in calling the <I>nonlinfit</I> functions. If you happen to know the partial derivatives analytically, Derivatives should point to a function calculating them. If you do not know them, call with Derivatives = NULL (<B>nil</B> in Pascal/Delphi). In the latter case, all derivatives will be calculated numerically inside the functions. In cases where you know some, but not all of the partial derivatives of Y with respect to the coefficients <I>a<sub>i</sub></I>, you could also calculate dY / d<I>a<sub>i</sub></I> wherever you have an analytic formula, and call <I><a href="#nonlinfit_">VF_nonlinfit_autoDeriv</a></I> for the remaining coefficients. To demonstrate this possibility, here is a function coding the derivatives for our non-linear sine and cosine example:
<P><font face="courier new">void DerivModel( fVector dYdAi, fVector X, ui size, unsigned iPar )
<BR>{
<BR>&nbsp;&nbsp;switch( iPar )
<BR>&nbsp;&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;case 0:
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for( ui i=0; i&lt;size; i++ ) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dYdAi[i] = X[i] * cos( a[0]*X[i] );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;case 1: /* say we don't know this derivative: */
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VF_nonlinfit_autoDeriv( dYdAi, X, size, iPar);
<BR>&nbsp;&nbsp;}
<BR>}</font>
<P>For actual working examples for the polynomial, general linear, and general non-linear cases, please see FITDEMO.CPP, FITDEMOW.CPP, FITDEMOB.BPR, FITDEMO.PAS, or FITDEMO.DPR.

<a name="chap13_3NONLINFITOPTIONS"></a>
<P>The nonlinear fitting routines are highly sophisticated and offer the user a lot of different options. These options may be set by the function <I><a href="#setNonlinfitOptions">V_setNonlinfitOptions</a></I>. To retrieve current settings, use
<BR><I><a href="#getNonlinfitOptions">V_getNonlinfitOptions</a></I>.
<BR>All options are packed into a structure (struct in C/C++, record in Pascal/Delphi) named <I>VF_NONLINFITOPTIONS</I>.
It has the following fields:<BR>&nbsp;
<table border width="100%"><tr valign="top"><td width="40%"><font face="courier new">int FigureOfMerit;</font></td><td>0: least squares fitting 
<BR>1: robust fitting, optimizing for minimum absolute deviation
<BR>(default: 0)</td></tr>
<tr valign="top"><td><font face="courier new">float AbsTolChi;</font></td><td>absolute change of <font face="symbol">c</font><sup>2</sup> (default: EPSILON)</td></tr>
<tr valign="top"><td><font face="courier new">float FracTolChi;</font></td><td>fractional change of <font face="symbol">c</font><sup>2</sup> (default: SQRT_EPSILON)</td></tr>
<tr valign="top"><td><font face="courier new">float AbsTolPar;</font></td><td>absolute change of all parameters (default: SQRT_MIN) </td></tr>
<tr valign="top"><td><font face="courier new">float FracTolPar;</font></td><td> fractional change of all parameters (default: SQRT_EPSILON)
<P>The four <font face="courier new">xxxTolChi</font> and <font face="courier new">xxxTolPar</font> parameters describe the convergence conditions: if the changes achieved in successive iterations are smaller than demanded by these criteria, this signals convergence. Criteria
which are not applicable should be set to 0.0.</td></tr>
<tr valign="top"><td><font face="courier new">unsigned HowOftenFulfill;</font></td><td> how often fulfill one of the above conditions before convergence is considered achieved (default: 3)</td></tr>
<tr valign="top"><td><font face="courier new">unsigned LevelOfMethod;</font></td><td>1: Levenberg-Marquardt method,
<BR>2: Downhill Simplex (Nelder and Mead) method,
<BR>3: both methods alternating;
<BR>add 4 to this in order to try breaking out of local minima;
<BR>0: no fit, calculate only <font face="symbol">c</font><sup>2</sup> (and Covar)
<BR>(default: 1)</td></tr>
<tr valign="top"><td><font face="courier new">unsigned LevMarIterations;</font></td><td>max.number of successful iterations of LevMar during one run (default: 100)</td></tr>
<tr valign="top"><td><font face="courier new">unsigned LevMarStarts;</font></td><td>number of LevMar restarts per run (default: 2)</td></tr>
<tr valign="top"><td><font face="courier new">float LambdaStart,
<BR>LambdaMin,
<BR>LambdaMax,
<BR>LambdaDiv,
<BR>LambdaMul; </font></td><td>treatment of LevMar parameter lambda (don't touch, unless you are an expert!)</td></tr>
<tr valign="top"><td><font face="courier new">unsigned DownhillIterations;</font></td><td>max. number of successful iterations in Downhill Simplex method (default: 200)</td></tr>
<tr valign="top"><td><font face="courier new">float DownhillReflection,
<BR>DownhillContraction,
<BR>DownhillExpansion;</font></td><td>treatment of re-shaping of the simplex in Downhill Simplex method (don't touch
unless you are an expert!)</td></tr>
<tr valign="top"><td><font face="courier new">unsigned TotalStarts;</font></td><td>max. number of LevMar/Downhill pairs (default: 16)</td></tr>
<tr valign="top"><td><font face="courier new">fVector UpperLimits,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LowerLimits;</font></td><td> impose upper and/or lower limits on parameters. Default for both: NULL or nil</td></tr>
<tr valign="top"><td><font face="courier new">void (*Restrictions)(void);</font></td><td>pointer to a user-defined function, implementing restrictions on the parameters which cannot be formulated as simple upper/lower limits. The function must check the whole parameter vector and edit the parameters as needed. Default: NULL or nil.</td></tr>
</table>

<P><a name="chap13_4"></a>
<H3>13.4 Fitting Multiple Data Sets</H3>
In addition to the fitting functions for single data sets, there are routines for fitting multiple data sets simultaneously. Say, you are a physicist or a chemist and want to measure a rate constant <I>k</I>. You have performed the same kinetic measurement ten times under slightly different conditions. All these measurements have, of course, the same <I>k</I>, but other parameters, like amplitude and time-zero, will differ from experiment to experiment. Now, the usual way would be to perform one fit for each of these ten data sets and average over the resulting <I>k</I>'s. 
<BR>There is a problem with this approach: you don't really know which weight you have to assign to each of the measurements, and how to treat the overlapping error margins of the individual fits. You might want to perform a fit on all your data sets simultaneously, taking the same <I>k</I> for all data sets, and assigning individual amplitudes etc. to each set. This is precisely what the <I><a href="#multiLinfit">multiLinfit</a></I> and <I><a href="#multiNonlinfit">multiNonlinfit</a></I> functions of <i>MatrixLib</i> are designed for. You can fit multiple data-sets both to linear and nonlinear models, for Y = f(X) data as well as for MZ = f(X,Y) data.
<table width="100%"><tr><td width="10%">&nbsp;</TD><td>
<U>Pascal with DOS only:</U>
<BR>The module in which you define your model function must be compiled using the &quot;Force Far Calls&quot; option (Options/Compiler in the IDE or switch {$F+} ) !</td></tr></table>&nbsp;
<BR>The <I><a href="#multiLinfit">multiLinfit</a></I> and <I><a href="#multiNonlinfit">multiNonlinfit</a></I> functions need the input data to be passed in structures named VF_EXPERIMENT for X-Y data and MF_EXPERIMENT for X-Y-Z data. In C/C++, <a name="chap13_4EXPERIMENT"></a>VF_EXPERIMENT has the following fields:<BR>&nbsp;
<table border width="100%"><tr valign="top"><td width="40%"><font face="courier new">fVector X, Y;</font></td><td>X and Y vectors: independent variable x and measured y=f(x) data</td></tr>
<tr valign="top"><td><font face="courier new">fVector InvVar;</font></td><td> inverse variances of the individual data points (needed only for the &quot;with weights&quot; functions)</td></tr>
<tr valign="top"><td><font face="courier new">ui size;</font></td><td>the number of data points</td></tr>
<tr valign="top"><td><font face="courier new">float WeightOfExperiment;</font></td><td>individual weight to be assigned to the whole experiment (again needed only for the weighted variants)</td></tr>
</table>&nbsp;
<BR>In C/C++, MF_EXPERIMENT has the following fields:<BR>&nbsp;
<table border width="100%"><tr valign="top"><td width="40%"><font face="courier new">fVector X, Y;</font></td><td>X and Y vectors (independent variables)</td></tr>
<tr valign="top"><td><font face="courier new">fMatrix MZ;</font></td><td>measured data z=f(x,y)</td></tr>
<tr valign="top"><td><font face="courier new">fMatrix MInvVar;</font></td><td> inverse variances of the individual matrix
elements (needed only for the &quot;with weights&quot; functions)</td></tr>
<tr valign="top"><td><font face="courier new">unsigned htZ, lenZ;</font></td><td>matrix dimensions</td></tr>
<tr valign="top"><td><font face="courier new">float WeightOfExperiment;</font></td><td>individual weight to be assigned to the whole experiment (again needed only for the weighted variants)</td></tr>
</table>&nbsp;


<BR>In Pascal/Delphi, VF_EXPERIMENT and MF_EXPERIMENT are defined as follows:
<P><font face="courier new">type VF_EXPERIMENT = record
<BR>&nbsp;&nbsp;X, Y, InvVar: fVector;
<BR>&nbsp;&nbsp;size: UInt;
<BR>&nbsp;&nbsp;WeightOfExperiment: Single;
<BR>end;
<BR>type PVF_EXPERIMENT = ^VF_EXPERIMENT;

<P>type MF_EXPERIMENT = record
<BR>&nbsp;&nbsp;X, Y: fVector;
<BR>&nbsp;&nbsp;MZ, MInvVar: fMatrix;
<BR>&nbsp;&nbsp;htZ, lenZ: UInt;
<BR>&nbsp;&nbsp;WeightOfExperiment: Single;
<BR>end;
<BR>type PMF_EXPERIMENT = ^MF_EXPERIMENT;</font>

<P>Both in VF_EXPERIMENT and MF_EXPERIMENT, <I>InvVar</I> and <I>WeightOfExperiment</I> are needed only for the weighted variants of the <I>multifit</I> functions.

<P><a name="chap13_5"></a>
<H3>13.5 Helper Functions for Nonlinear Fits</H3>
As nonlinear fitting tasks - especially with multiple data sets - may become quite tedious and take a very long time (sometimes many hours!) to converge, there is a number of functions which allow to follow the course of nonlinear
fits. The names of these functions are always derived from the fitting function they are used with. For example, the helper functions for <I><a href="#nonlinfit">VF_nonlinfit</a></I> are:<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR><TD WIDTH="32%"><a href="FUNCREF.HTM#nonlinfit_">VF_nonlinfit_getBestValues</a></td><td>best set of parameters found so far</td></tr>
<tr valign="top"><td><a href="#nonlinfit_">VF_nonlinfit_getChi2</a></td><td>the best figure-of-merit (<font face="symbol">c</font><sup>2</sup>, chi-square) obtained so far</td></tr>
<tr valign="top"><td><a href="#nonlinfit_">VF_nonlinfit_getTestDir</a></td><td>returns the test direction (+1 for upwards, -1 for downwards) during &quot;breakout&quot; attempts (level-of-method greater than 3, see the description of <I><a href="#chap13_3NONLINFITOPTIONS">VF_NONLINFITOPTIONS</a></I> above)</td></tr>
<tr valign="top"><td><a href="#nonlinfit_">VF_nonlinfit_getTestPar</a></td><td>index of the parameter currently under &quot;breakout&quot; investigation</td></tr>
<tr valign="top"><td><a href="#nonlinfit_">VF_nonlinfit_getTestRun</a></td><td>index of the current &quot;breakout&quot; test run (for each fitted parameter, one test run is performed)</td></tr>
<tr valign="top"><td><a href="#nonlinfit_">VF_nonlinfit_stop</a></td><td>stops fitting after completion of the current Levenberg-Marquardt or Downhill cycle</td></tr>
</table>&nbsp;
<BR>For the other nonlinear fitting functions, the corresponding helper-function names are obtained by replacing the &quot;VF_nonlinfit_&quot; prefix with the respective fitting function name, as in <I><a href="#nonlinfit_">VF_nonlinfitwW_getBestValues</a></I>,
<I><a href="#MmultiNonlinfit_">MF_multiNonlinfit_stop</a></I>, and so on.
<BR>There are two possibilities how these functions can be called. The first way is to call them from within your model function. For example, you might install a counter into your model function and, upon reaching a certain
number of calls, retrieve the current chi2, parameter set, etc. The second way is open only for multithreaded programs: a thread, different from the one performing the fit, may call any of the above functions to control the progress of the fit.
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap14"></a>
<H2>14. Matrix Input and Output</H2>
The matrix input/output functions are all analogous to the corresponding vector functions
<TABLE BORDER WIDTH="100%" >
<TR valign="top"><TD WIDTH="25%"><a href="#cprint">MF_cprint</a></TD>
<TD>print a matrix to the screen. If necessary, rows are cut off at the screen boundaries. If there are more rows than screen lines, proper paging is applied. (DOS and Delphi only)</TD></TR>
<TR valign="top"><TD><a href="#print">MF_print</a></TD><TD>print a matrix to the screen (without paging or row cut-off); (DOS, EasyWin and Delphi only)</TD></TR>
<TR><TD><a href="#fprint">MF_fprint</a></TD><TD>print a matrix in ASCII format to a stream</TD></TR>
<TR><TD><a href="#store">MF_store</a></TD><TD>store in binary format</TD></TR>
<TR><TD><a href="#recall">MF_recall</a></TD><TD>retrieve in binary format</TD></TR>
<TR><TD><a href="#write">MF_write</a></TD><TD>write in ASCII format in a stream</TD></TR>
<TR><TD><a href="#read">MF_read</a></TD><TD>read from an ASCII file</TD></TR>
</TABLE>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap15"></a>
<H2><HR width="100%">15. Graphical Representation of Matrices</H2>
True 3D-plotting functions will be included in future versions. For now, only color-density plots are available. In these plots, each data value is translated into a color value by linear interpolation between two colors, specified as <I>mincolor</I> and <I>maxcolor</I>.<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR valign="top"><TD><a href="#xyzAutoDensityMap">MF_xyzAutoDensityMap</a>&nbsp;</TD><TD>Color density map for z=f(x,y) with automatic scaling of the <I>x</I> and <I>y</I> axes and of the color density scale between <I>mincolor</I> and <I>maxcolor</I></TD></TR>
<TR valign="top"><TD><a href="#xyzDataDensityMap">MF_xyzDataDensityMap</a>&nbsp;</TD><TD>z=f(x,y) color density map, plotted into an existing axis frame, and using the color density scale set by the last call to an <I>AutoDensityMap</I> function</TD></TR>
<TR valign="top"><TD><a href="#zAutoDensityMap">MF_zAutoDensityMap</a></TD><TD>Color density map for z=f(i,j) with automatic scaling of the <I>x</I> and <I>y</I> axes and of the color density scale between <I>mincolor</I> and <I>maxcolor</I>. i and j are the indices in <I>x</I> and <I>y</I> direction, respectively</TD></TR>
<TR valign="top"><TD><a href="#zDataDensityMap">MF_zDataDensityMap</a></TD><TD>Color density map for z=f(i,j), plotted into an existing axis frame, and using the color density scale set by the last call to an <I>AutoDensityMap</I> function</TD></TR>
<TR valign="top"><TD><a href="#setDensityBounds">M_setDensityBounds</a></TD><TD>Set a color scale for matrix color-density plots.</TD></TR>
<TR valign="top"><TD><a href="#setDensityMapBounds">M_setDensityMapBounds</a></TD><TD>Set a color scale and draw an X-Y coordinate system for matrix color-density plots.</TD></TR>
<TR valign="top"><TD><a href="#findDensityMapBounds">M_findDensityMapBounds</a></TD><TD>Calculate a color scale and draw an X-Y coordinate system for matrix color-density plots, ensuring that the grid lines of the coordinate system correspond to exact (rather than only rounded) values.</TD></TR>
</TABLE>
<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><a name="chap16"></a>
<H2><HR width="100%">16. Alphabetical Reference of <I>MatrixLib</I></H2>
This Kap.&nbsp;describes, in alphabetical order, all <i>MatrixLib</i> functions. Similarly to the indexing of the vector functions in <a href="#FUNCREF.HTM#chap8">FUNCREF.HTM</a>, the <i>MF_</i> or <I>M_</I> prefix is neglected in the ordering of entries. The particles &quot;Row_&quot;, &quot;Rows_&quot;, &quot;Col_&quot;, &quot;Cols_&quot;, &quot;Dia_&quot;, and &quot;Trd_&quot;, however, are fully taken into account. For example, &quot;<I>MF_Rows_</I>&quot; functions will come after all &quot;<I>MF_Row_</I>&quot; functions. While most <i>MatrixLib</i> functions have the prefixes <i>MF_</i> or <I>M_</I>, please note that some - notably the X-Y fitting functions - have the prefix <I>VF_</I> as a reminder that they actually work on vectors, even if they rely on matrix methods and form a part of <I>MatrixLib</I>. In cases where both the <I>VF_</I> and the <I>MF_</I> versions exist, contrary to the alphabetical order the <I>VF_</I> version is described first, as it is the simpler one.


<P>&nbsp;<a name="addM"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_addM</b></font>
</td><td width="33%"><font size="+1"><b>MD_addM</b></font></td>
<td><font size="+1"><b>ME_addM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MFs_addM</b></font></td>
<td width="33%"><font size="+1"><b>MDs_addM</b></font></td>
<td><font size="+1"><b>MEs_addM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_addM</b></font></td>
<td width="33%"><font size="+1"><b>MCD_addM</b></font></td>
<td><font size="+1"><b>MCE_addM</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise addition of two matrices</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_addM( fMatrix MC, fMatrix MA, fMatrix MB, unsigned ht, unsigned len );<BR>
void MFs_addM( fMatrix MC, fMatrix MA, fMatrix MB, unsigned ht, unsigned len, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_addM( MC, MA, MB:fMatrix MC; ht, len:UInt );<BR>
procedure MFs_addM( MC, MA, MB:fMatrix MC; ht, len:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal version: MC<sub>ij</sub> = MA<sub>ij</sub> + MB<sub>ij</sub>
<BR>scaled version: MC<sub>ij</sub> = C * (MA<sub>ij</sub> + MB<sub>ij</sub>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#addMT">MF_addMT</a>,&nbsp;&nbsp; <a href="#subM">MF_subM</a>,&nbsp;&nbsp; <a href="subrM">MF_subrM</a>,&nbsp;&nbsp; <a href="#chap9">Kap.&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="addMT"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_addMT</b></font>
</td><td width="33%"><font size="+1"><b>MD_addMT</b></font></td>
<td><font size="+1"><b>ME_addMT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MFs_addMT</b></font></td>
<td width="33%"><font size="+1"><b>MDs_addMT</b></font></td>
<td><font size="+1"><b>MEs_addMT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_addMT</b></font></td>
<td width="33%"><font size="+1"><b>MCD_addMT</b></font></td>
<td><font size="+1"><b>MCE_addMT</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise addition of one matrix and the transpose of another</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_addMT( fMatrix MC, fMatrix MA, fMatrix MB, unsigned ht, unsigned len );<BR>
void MFs_addMT( fMatrix MC, fMatrix MA, fMatrix MB, unsigned ht, unsigned len, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_addMT( MC, MA, MB:fMatrix MC; ht, len:UInt );<BR>
procedure MFs_addMT( MC, MA, MB:fMatrix MC; ht, len:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal version: MC<sub>ij</sub> = MA<sub>ij</sub> + MB<sup>T</sup><sub>ji</sub>
<BR>scaled version: MC<sub>ij</sub> = C * (MA<sub>ij</sub> + MB<sup>T</sup><sub>ji</sub>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#addM">MF_addM</a>,&nbsp;&nbsp; <a href="#subMT">MF_subMT</a>,&nbsp;&nbsp; <a href="#chap9">Kap.&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="autocorr"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_autocorr</b></font>
</td><td width="33%"><font size="+1"><b>MD_autocorr</b></font></td>
<td><font size="+1"><b>ME_autocorr</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Spatial autocorrelation function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_autocorr( fMatrix MY, fMatrix MX, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_autocorr( MY, MX:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The spatial autocorrelation function (SACF) of MX is calculated and stored in MY in wrap-around order in both dimensions: The row elements MY<sub>i,0</sub> to MY<sub>i,len/2-1</sub> contain the SACF for zero and positive x lags. Beginning with the most negative lag in MY<sub>i,len/2+1</sub>, the elements up to MY<sub>i,len-1</sub> contain the SACF for negative lags. Since this function assumes MX to be periodic, the SACF for the most positive lag is identical to the SACF for the most negative lag. This element is stored as Y<sub>i,len/2</sub>.
<BR>Similarly, the column elements MY<sub>0,j</sub> to MY<sub>len/2-1,j</sub> contain the SACF for zero and positive y lags. Beginning with the most negative lag in MY<sub>len/2+1,j</sub>, the elements up to MY<sub>len-1,j</sub> contain the SACF for negative lags.
<BR>To get the SACF into normal order, you may call
<BR><font face="courier new"> <a href="#Rows_rotate">MF_Rows_rotate</a>( MY, ht, len, len/2 );
<BR><a href="#Cols_rotate">MF_Cols_rotate</a>( MY, ht, len, ht/2 );</font>
<BR>After that, the zero point is at the position MY<sub>ht/2,len/2</sub>.
<BR>In case MX is non-periodic, you should avoid end effects by the methods described in connection with <I><a href="#convolve">MF_convolve</a></I>.
<BR>Both <I>ht</I> and <I>len</I> must be integer powers of 2.
<BR>About special versions with the prefixes <I>MFl_</I> and <I>MFs_</I>, consult <a href="HANDBOOK.HTM#chap4_8">Kap.&nbsp;4.8 of HANDBOOK.HTM</a>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If either len or ht is not a power of 2, <I><a href="FUNCREF.HTM#FFT">VF_FFT</a></I> (on which <I>MF_autocorr</I> is based) complains &quot;Size must be an integer power of 2&quot; and the program is aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#FFT">MF_FFT</a>,&nbsp;&nbsp; <a href="#convolve">MF_convolve</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#autocorr">VF_autocorr</a>,&nbsp;&nbsp; <a href="#chap12">Kap.&nbsp;12</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<P><a name="CDtoCF"></a>
<table border width="100%">
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>M_CDtoCF</b></font></td><td><font size="+1"><b>M_CDtoCE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>M_CEtoCF</b></font></td><td><font size="+1"><b>M_CEtoCD</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>M_CFtoCD</b></font></td><td><font size="+1"><b>M_CFtoCE</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Data type conversions. See <I><a href="#FtoD">M_FtoD</a></I>.
</td></tr></table></td></tr></table>


<P>&nbsp;<a name="Col_addC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_addC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_addC</b></font></td>
<td><font size="+1"><b>ME_Col_addC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_addC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_addC</b></font></td>
<td><font size="+1"><b>MCE_Col_addC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>add a constant to all elements of one column</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_addC( fMatrix MA, unsigned ht, unsigned len, unsigned iCol, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_addC( MA:fMatrix; ht, len, iCol:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> += C,&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_subC">MF_Col_subC</a>,&nbsp;&nbsp; <a href="#Row_addC">MF_Row_addC</a>,&nbsp;&nbsp; <a href="#Col_addV">MF_Col_addV</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_addV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_addV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_addV</b></font></td>
<td><font size="+1"><b>ME_Col_addV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_addV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_addV</b></font></td>
<td><font size="+1"><b>MCE_Col_addV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>add a vector to a column</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_addV( fMatrix MA, unsigned ht, unsigned len, unsigned iCol, fVector X );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_addV( MA:fMatrix; ht, len, iCol:UInt; X:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> += X<sub>i</sub>,&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_subV">MF_Col_subV</a>,&nbsp;&nbsp; <a href="#Row_addV">MF_Row_addV</a>,&nbsp;&nbsp; <a href="#Col_addC">MF_Col_addC</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_delete"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_delete</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_delete</b></font></td>
<td><font size="+1"><b>ME_Col_delete</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_delete</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_delete</b></font></td>
<td><font size="+1"><b>MCE_Col_delete</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>delete one column from a matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_delete( fMatrix MB, fMatrix MA, unsigned htA, unsigned lenA, unsigned iCol );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_delete( MB, MA:fMatrix; htA, lenA, iCol:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MB<sub>i,j</sub> = MA<sub>i,j</sub>,&nbsp;&nbsp;i=0,..htA-1,&nbsp;&nbsp;j=0,..iCol-1<BR>
MB<sub>i,j</sub> = MA<sub>i,j+1</sub>,&nbsp;&nbsp;i=0,...,htA-1,&nbsp;&nbsp;j=iCol,...,lenA-2<BR>
The parameters htA and lenA refer to the <U>input</U> matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_insert">MF_Col_insert</a>,&nbsp;&nbsp; <a href="#Row_delete">MF_Row_delete</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#delete">VF_delete</a>,&nbsp;&nbsp; <a href="#chap5">Kap.&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_divC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_divC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_divC</b></font></td>
<td><font size="+1"><b>ME_Col_divC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_divC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_divC</b></font></td>
<td><font size="+1"><b>MCE_Col_divC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>divide all elements of one column by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_divC( fMatrix MA, unsigned ht, unsigned len, unsigned iCol, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_divC( MA:fMatrix; ht, len, iCol:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> /= C,&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_divrC">MF_Col_divrC</a>,&nbsp;&nbsp; <a href="#Row_divC">MF_Row_divC</a>,&nbsp;&nbsp; <a href="#Col_mulC">MF_Col_mulC</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_divrC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_divrC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_divrC</b></font></td>
<td><font size="+1"><b>ME_Col_divrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_divrC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_divrC</b></font></td>
<td><font size="+1"><b>MCE_Col_divrC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Reverse division: divide a constant by a column</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_divrC( fMatrix MA, unsigned ht, unsigned len, unsigned iCol, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_divrC( MA:fMatrix; ht, len, iCol:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> = C / MA<sub>i,iCol</sub>,&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_divC">MF_Col_divC</a>,&nbsp;&nbsp; <a href="#Row_divrC">MF_Row_divrC</a>,&nbsp;&nbsp; <a href="#Col_divV">MF_Col_divV</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_divrV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_divrV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_divrV</b></font></td>
<td><font size="+1"><b>ME_Col_divrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_divrV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_divrV</b></font></td>
<td><font size="+1"><b>MCE_Col_divrV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Reverse division: divide a vector by a column (element-wise)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_divrV( fMatrix MA, unsigned ht, unsigned len, unsigned iCol, fVector X );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_divrV( MA:fMatrix; ht, len, iCol:UInt; X:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> = X<sub>i</sub> / MA<sub>i,iCol</sub>,&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_divV">MF_Col_divV</a>,&nbsp;&nbsp; <a href="#Row_divrV">MF_Row_divrV</a>,&nbsp;&nbsp; <a href="#Col_divrC">MF_Col_divrC</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_divV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_divV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_divV</b></font></td>
<td><font size="+1"><b>ME_Col_divV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_divV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_divV</b></font></td>
<td><font size="+1"><b>MCE_Col_divV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise division of a column by a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_divV( fMatrix MA, unsigned ht, unsigned len, unsigned iCol, fVector X );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_divV( MA:fMatrix; ht, len, iCol:UInt; X:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> /= X<sub>i</sub>,&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_divrV">MF_Col_divrV</a>,&nbsp;&nbsp; <a href="#Row_divV">MF_Row_divV</a>,&nbsp;&nbsp; <a href="#Col_divC">MF_Col_divC</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_equ0"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_equ0</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_equ0</b></font></td>
<td><font size="+1"><b>ME_Col_equ0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_equ0</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_equ0</b></font></td>
<td><font size="+1"><b>MCE_Col_equ0</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>set all elements of one column to zero</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_equ0( fMatrix MA, unsigned ht, unsigned len, unsigned iCol );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_equ0( MA:fMatrix; ht, len, iCol:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> = 0,&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_equC">MF_Col_equC</a>,&nbsp;&nbsp; <a href="#Row_equ0">MF_Row_equ0</a>,&nbsp;&nbsp; <a href="#Dia_equ0">MF_Dia_equ0</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_equC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_equC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_equC</b></font></td>
<td><font size="+1"><b>ME_Col_equC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_equC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_equC</b></font></td>
<td><font size="+1"><b>MCE_Col_equC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>initialize all elements of one column with a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_equC( fMatrix MA, unsigned ht, unsigned len, unsigned iCol, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_equC( MA:fMatrix; ht, len, iCol:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> = C,&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_equV">MF_Col_equV</a>,&nbsp;&nbsp; <a href="#Row_equC">MF_Row_equC</a>,&nbsp;&nbsp; <a href="#Dia_equC">MF_Dia_equC</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_equV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_equV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_equV</b></font></td>
<td><font size="+1"><b>ME_Col_equV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_equV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_equV</b></font></td>
<td><font size="+1"><b>MCE_Col_equV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>copy a vector into one column</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_equV( fMatrix MA, unsigned ht, unsigned len, unsigned iCol, fVector X );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_equV( MA:fMatrix; ht, len, iCol:UInt; X:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> = X<sub>i</sub>,&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_equ0">MF_Col_equ0</a>,&nbsp;&nbsp; <a href="#Row_equV">MF_Row_equV</a>,&nbsp;&nbsp; <a href="#Dia_equV">MF_Dia_equV</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_extract"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_extract</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_extract</b></font></td>
<td><font size="+1"><b>ME_Col_extract</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_extract</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_extract</b></font></td>
<td><font size="+1"><b>MCE_Col_extract</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>copy one column into a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_extract( fVector Y, fMatrix MA, unsigned ht, unsigned len, unsigned iCol );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_extract( Y:fVector; MA:fMatrix; ht, len, iCol:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = MA<sub>i,iCol</sub>,&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Row_extract">MF_Row_extract</a>,&nbsp;&nbsp; <a href="#Dia_extract">MF_Dia_extract</a>,&nbsp;&nbsp; <a href="#Col_equV">MF_Col_equV</a>,&nbsp;&nbsp; <a href="#chap3">Kap.&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_insert"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_insert</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_insert</b></font></td>
<td><font size="+1"><b>ME_Col_insert</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_insert</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_insert</b></font></td>
<td><font size="+1"><b>MCE_Col_insert</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>augment a matrix by insertion of one column</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_insert( fMatrix MB, fMatrix MA, unsigned htB, unsigned lenB, unsigned iCol, fVector X );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_insert( MB, MA:fMatrix; htB, lenB, iCol:UInt; X:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MB<sub>i,j</sub> = MA<sub>i,j</sub>,&nbsp;&nbsp;i=0,...,htB-1,&nbsp;&nbsp;j=0,...,iCol-1<BR>
MB<sub>i,iCol</sub> = X<sub>i</sub>,&nbsp;&nbsp;i=0,...,htB-1<BR>
MB<sub>i,j</sub> = MA<sub>i,j-1</sub>,&nbsp;&nbsp;i=0,...,htB-1,&nbsp;&nbsp;j=iCol,...,lenB-1<BR>
The parameters htB and lenB refer to the <U>output</U> matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_delete">MF_Col_delete</a>,&nbsp;&nbsp; <a href="#chap5">Kap.&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_mulC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_mulC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_mulC</b></font></td>
<td><font size="+1"><b>ME_Col_mulC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_mulC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_mulC</b></font></td>
<td><font size="+1"><b>MCE_Col_mulC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply all elements of one column by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_mulC( fMatrix MA, unsigned ht, unsigned len, unsigned iCol, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_mulC( MA:fMatrix; ht, len, iCol:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> *= C,&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_divC">MF_Col_divC</a>,&nbsp;&nbsp; <a href="#Row_divC">MF_Row_divC</a>,&nbsp;&nbsp; <a href="#Col_mulV">MF_Col_mulV</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_mulV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_mulV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_mulV</b></font></td>
<td><font size="+1"><b>ME_Col_mulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_mulV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_mulV</b></font></td>
<td><font size="+1"><b>MCE_Col_mulV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise multiplication of a column by a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_mulV( fMatrix MA, unsigned ht, unsigned len, unsigned iCol, fVector X );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_mulV( MA:fMatrix; ht, len, iCol:UInt; X:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> *= X<sub>i</sub>,&nbsp;&nbsp;i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_divV">MF_Col_divV</a>,&nbsp;&nbsp; <a href="#Row_divV">MF_Row_divV</a>,&nbsp;&nbsp; <a href="#Col_mulC">MF_Col_mulC</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_subC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_subC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_subC</b></font></td>
<td><font size="+1"><b>ME_Col_subC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_subC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_subC</b></font></td>
<td><font size="+1"><b>MCE_Col_subC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>subtract a constant from all elements of one column</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_subC( fMatrix MA, unsigned ht, unsigned len, unsigned iCol, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_subC( MA:fMatrix; ht, len, iCol:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> -= C,&nbsp;&nbsp;i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_addC">MF_Col_addC</a>,&nbsp;&nbsp; <a href="#Row_subC">MF_Row_subC</a>,&nbsp;&nbsp; <a href="#Col_subV">MF_Col_subV</a>,&nbsp;&nbsp; <a href="#Col_subrC">MF_Col_subrC</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_subrC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_subrC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_subrC</b></font></td>
<td><font size="+1"><b>ME_Col_subrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_subrC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_subrC</b></font></td>
<td><font size="+1"><b>MCE_Col_subrC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>reverse subtraction: a constant minus one column</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_subrC( fMatrix MA, unsigned ht, unsigned len, unsigned iCol, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_subrC( MA:fMatrix; ht, len, iCol:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> = C - MA<sub>i,iCol</sub>,&nbsp;&nbsp;i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_addC">MF_Col_addC</a>,&nbsp;&nbsp; <a href="#Row_subC">MF_Row_subC</a>,&nbsp;&nbsp; <a href="#Col_subrV">MF_Col_subrV</a>,&nbsp;&nbsp; <a href="#Col_subC">MF_Col_subC</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_subV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_subV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_subV</b></font></td>
<td><font size="+1"><b>ME_Col_subV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_subV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_subV</b></font></td>
<td><font size="+1"><b>MCE_Col_subV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>subtract a vector from a column (element-wise)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_subV( fMatrix MA, unsigned ht, unsigned len, unsigned iCol, fVector X );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_subV( MA:fMatrix; ht, len, iCol:UInt; X:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> -= X<sub>i</sub>,&nbsp;&nbsp;i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_subC">MF_Col_subC</a>,&nbsp;&nbsp; <a href="#Row_subV">MF_Row_subV</a>,&nbsp;&nbsp; <a href="#Col_subrC">MF_Col_subrC</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Col_subrV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Col_subrV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Col_subrV</b></font></td>
<td><font size="+1"><b>ME_Col_subrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Col_subrV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Col_subrV</b></font></td>
<td><font size="+1"><b>MCE_Col_subrV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>reverse subtraction: a vector minus one column (element-wise)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Col_subrV( fMatrix MA, unsigned ht, unsigned len, unsigned iCol, fVector X );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Col_subrV( MA:fMatrix; ht, len, iCol:UInt; X:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,iCol</sub> = X<sub>i</sub> - MA<sub>i,iCol</sub>,&nbsp;&nbsp;i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_subV">MF_Col_subV</a>,&nbsp;&nbsp; <a href="#Row_subrV">MF_Row_subrV</a>,&nbsp;&nbsp; <a href="#Col_subrC">MF_Col_subrC</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_absmax"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_absmax</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_absmax</b></font></td>
<td><font size="+1"><b>ME_Cols_absmax</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_absmax</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_absmax</b></font></td>
<td><font size="+1"><b>MCE_Cols_absmax</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>store the absolute maxima of all individual columns in a row vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_absmax( fVector Y, fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_absmax( Y:fVector; MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The maximum absolute value of each column <I>j</I> is stored as the element Y<sub>j</sub> for j=0,..,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_max">MF_Cols_max</a>,&nbsp;&nbsp; <a href="#Cols_absmin">MF_Cols_absmin</a>,&nbsp;&nbsp; <a href="#Rows_absmax">MF_Rows_absmax</a>,&nbsp;&nbsp; <a href="#Dia_absmax">MF_Dia_absmax</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_absmin"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_absmin</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_absmin</b></font></td>
<td><font size="+1"><b>ME_Cols_absmin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_absmin</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_absmin</b></font></td>
<td><font size="+1"><b>MCE_Cols_absmin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>store the absolute minima of all individual columns in a row vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_absmin( fVector Y, fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_absmin( Y:fVector; MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The minimum absolute value of each column <I>j</I> is stored as the element Y<sub>j</sub> for j=0,..,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_min">MF_Cols_min</a>,&nbsp;&nbsp; <a href="#Cols_absmax">MF_Cols_absmax</a>,&nbsp;&nbsp; <a href="#Rows_absmin">MF_Rows_absmin</a>,&nbsp;&nbsp; <a href="#Dia_absmin">MF_Dia_absmin</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_add"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_add</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_add</b></font></td>
<td><font size="+1"><b>ME_Cols_add</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_add</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_add</b></font></td>
<td><font size="+1"><b>MCE_Cols_add</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>make one column the sum of itself and another column</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_add( fMatrix MA, unsigned ht, unsigned len, unsigned destCol, unsigned sourceCol );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_add( MA:fMatrix; ht, len, destCol, sourceCol:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,destCol</sub> += MA<sub>i,sourceCol</sub>,&nbsp;&nbsp;i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_sub">MF_Cols_sub</a>,&nbsp;&nbsp; <a href="#Cols_Cadd">MF_Cols_Cadd</a>,&nbsp;&nbsp; <a href="#Cols_lincomb">MF_Cols_lincomb</a>,&nbsp;&nbsp; <a href="#chap8">Kap.&nbsp;8</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_Cadd"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_Cadd</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_Cadd</b></font></td>
<td><font size="+1"><b>ME_Cols_Cadd</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_Cadd</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_Cadd</b></font></td>
<td><font size="+1"><b>MCE_Cols_Cadd</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>make one column the sum of itself and another column, scaled by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_Cadd( fMatrix MA, unsigned ht, unsigned len, unsigned destCol, unsigned sourceCol, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_Cadd( MA:fMatrix; ht, len, destCol, sourceCol:UInt;
C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,destCol</sub> += C * MA<sub>i,sourceCol</sub>,&nbsp;&nbsp;i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_add">MF_Cols_add</a>,&nbsp;&nbsp; <a href="#Cols_lincomb">MF_Cols_lincomb</a>,&nbsp;&nbsp; <a href="#chap8">Kap.&nbsp;8</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_exchange"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_exchange</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_exchange</b></font></td>
<td><font size="+1"><b>ME_Cols_exchange</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_exchange</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_exchange</b></font></td>
<td><font size="+1"><b>MCE_Cols_exchange</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>exchange two columns</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_exchange( fMatrix MA, unsigned ht, unsigned len, unsigned i1, unsigned i2 );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_exchange( MA:fMatrix; ht, len, i1, i2:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The elements of the columns i1 and i2 are exchanged.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_exchange">MF_Rows_exchange</a>,&nbsp;&nbsp; <a href="#chap 8">Kap.&nbsp;8</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_lincomb"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_lincomb</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_lincomb</b></font></td>
<td><font size="+1"><b>ME_Cols_lincomb</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_lincomb</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_lincomb</b></font></td>
<td><font size="+1"><b>MCE_Cols_lincomb</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>linear combination of two columns</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_lincomb( fMatrix MA, unsigned ht, unsigned len, unsigned destCol, float destC, unsigned srceCol, float srceC );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_lincomb( MA:fMatrix; ht, len:UInt; destCol:UInt; destC:Single; srceCol:Uint; srceC:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,destCol</sub> = destC * MA<sub>i,destCol</sub>+ srceC * MA<sub>i,srceCol</sub>,&nbsp;&nbsp;i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_add">MF_Cols_add</a>,&nbsp;&nbsp; <a href="#Cols_Cadd">MF_Cols_Cadd</a>,&nbsp;&nbsp; <a href="#chap8">Kap.&nbsp;8</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_max"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_max</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_max</b></font></td>
<td><font size="+1"><b>ME_Cols_max</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_max</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_max</b></font></td>
<td><font size="+1"><b>MCE_Cols_max</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>store the maxima of all individual columns in a row vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_max( fVector Y, fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_max( Y:fVector; MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The maximum value of each column <I>j</I> is stored as the element Y<sub>j</sub> for j=0,..,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_absmax">MF_Cols_absmax</a>,&nbsp;&nbsp; <a href="#Cols_min">MF_Cols_min</a>,&nbsp;&nbsp; <a href="#Rows_max">MF_Rows_max</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_min"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_min</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_min</b></font></td>
<td><font size="+1"><b>ME_Cols_min</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_min</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_min</b></font></td>
<td><font size="+1"><b>MCE_Cols_min</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>store the minima of all individual columns in a row vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_min( fVector Y, fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_min( Y:fVector; MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The minimum value of each column <I>j</I> is stored as the element Y<sub>j</sub> for j=0,..,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_absmax">MF_Cols_absmax</a>,&nbsp;&nbsp; <a href="#Cols_min">MF_Cols_min</a>,&nbsp;&nbsp; <a href="#Rows_max">MF_Rows_max</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_prod"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_prod</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_prod</b></font></td>
<td><font size="+1"><b>ME_Cols_prod</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_prod</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_prod</b></font></td>
<td><font size="+1"><b>MCE_Cols_prod</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>products over all elements of each individual column, stored in a row vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_prod(fVector Y, fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_prod(Y:fVector; MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>j</sub> = prod( MA<sub>i,j</sub>, i=0,..,ht-1),&nbsp;&nbsp;j=0,..,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_runprod">MF_Cols_runprod</a>,&nbsp;&nbsp; <a href="#Cols_sum">MF_Cols_sum</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_reflect"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_reflect</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_reflect</b></font></td>
<td><font size="+1"><b>ME_Cols_reflect</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Derive the second halves of all columns from their first halves by reflection at the horizontal line through the center of the matrix.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_reflect( fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_reflect( MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>ht-i-1,j</sub> = MA<sub>i, j</sub>,&nbsp;&nbsp;i=0,..(ht-1)/2;&nbsp;&nbsp;j=0,..,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_rotate">MF_Cols_rotate</a>,&nbsp;&nbsp; <a href="#Rows_reflect">MF_Rows_reflect</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_rotate"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_rotate</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_rotate</b></font></td>
<td><font size="+1"><b>ME_Cols_rotate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_rotate</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_rotate</b></font></td>
<td><font size="+1"><b>MCE_Cols_rotate</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>rotate all columns by a specified number of positions; thereby, whole rows are moved</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_rotate( fMatrix MA, unsigned ht, unsigned len, int pos );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_rotate( MA:fMatrix; ht, len:UInt; pos:Integer );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,j</sub> = MA<sub>ht-pos+i, j</sub>,&nbsp;&nbsp;&nbsp;i=0,..,pos-1
<BR>MA<sub>i,j</sub> = MA<sub>i-pos, j</sub>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i=pos,...,ht-1
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_reflect">MF_Cols_reflect</a>,&nbsp;&nbsp; <a href="#Rows_rotate">MF_Rows_rotate</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_runprod"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_runprod</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_runprod</b></font></td>
<td><font size="+1"><b>ME_Cols_runprod</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_runprod</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_runprod</b></font></td>
<td><font size="+1"><b>MCE_Cols_runprod</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>running product over column elements</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_runprod( fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_runprod( MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>For all columns separately, each element is the product of itself and all preceding elements. This function should be used with care: overflow is easily reached, and underflow may lead to all elements from a certain position on being zero.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_prod">MF_Cols_prod</a>,&nbsp;&nbsp; <a href="#Rows_runprod">MF_Rows_runprod</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_runsum"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_runsum</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_runsum</b></font></td>
<td><font size="+1"><b>ME_Cols_runsum</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_runsum</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_runsum</b></font></td>
<td><font size="+1"><b>MCE_Cols_runsum</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>running sum over column elements</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_runsum( fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_runsum( MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>For all columns separately, each element is the sum of itself and all preceding elements.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_sum">MF_Cols_sum</a>,&nbsp;&nbsp; <a href="#Rows_runsum">MF_Rows_runsum</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_sub"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_sub</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_sub</b></font></td>
<td><font size="+1"><b>ME_Cols_sub</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_sub</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_sub</b></font></td>
<td><font size="+1"><b>MCE_Cols_sub</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>subtract one column from another and store the result back into the subtrahend</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_sub( fMatrix MA, unsigned ht, unsigned len, unsigned destCol, unsigned sourceCol );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_sub( MA:fMatrix; ht, len, destCol, sourceCol:UInt; );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,destCol</sub> -= MA<sub>i,sourceCol</sub>,&nbsp;&nbsp;i=0,..,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_add">MF_Cols_add</a>,&nbsp;&nbsp; <a href="#Cols_Cadd">MF_Cols_Cadd</a>,&nbsp;&nbsp; <a href="#chap8">Kap.&nbsp;8</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Cols_sum"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Cols_sum</b></font>
</td><td width="33%"><font size="+1"><b>MD_Cols_sum</b></font></td>
<td><font size="+1"><b>ME_Cols_sum</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Cols_sum</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Cols_sum</b></font></td>
<td><font size="+1"><b>MCE_Cols_sum</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>sums over all columns, returned in a row vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Cols_sum( fVector Y, fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Cols_sum( Y:fVector; MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>j</sub> = sum( MA<sub>i,j</sub>, i=0,..,ht-1),&nbsp;&nbsp;j=0,..,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_prod">MF_Cols_prod</a>,&nbsp;&nbsp; <a href="#Cols_runsum">MF_Cols_runsum</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="conj"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_conj</b></font>
</td><td width="33%"><font size="+1"><b>MCD_conj</b></font></td>
<td><font size="+1"><b>MCE_conj</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>complex conjugate</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MCF_conj( cfMatrix MB, cfMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MCF_conj( MB, MA:cfMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MB<sub>ij</sub>.Re = MA<sub>ij</sub>.Re<BR>
MB<sub>ij</sub>.Im = -MA<sub>ij</sub>.Im</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#neg">MCF_neg</a>,&nbsp;&nbsp; <a href="#chap3">Kap.&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="convolve"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_convolve</b></font>
</td><td width="33%"><font size="+1"><b>MD_convolve</b></font></td>
<td><font size="+1"><b>ME_convolve</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>convolution with a spatial response function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_convolve( fMatrix MY, fMatrix MFlt, fMatrix MX, fMatrix MRsp, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_convolve( MY, MFlt, MX, MRsp:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td> The convolution of MX with the response function MRsp is calculated and stored in MY. A filter MFlt is also calculated. If more than one matrix is to be convolved with the same MRsp, use <I><a href="#convolve">MF_convolve</a></I> only once and use <I><a href="#filter">MF_filter</a></I> for the other matrices.
<P>The response has to be stored in MRsp in wrap-around order in both dimensions: in each row i of MRsp, the response for zero and positive x-values is stored in MRsp<sub>i,0</sub> to MRsp<sub>i,len/2</sub> and the response for negative x-values (beginning with the most negative x) in MRsp<sub>i,len/2+1</sub> to MRsp<sub>i,len-1</sub>.
<BR>Similarly, in each column of MRsp, the response for zero and positive y-values is stored in MRsp<sub>0,j</sub> to MRsp<sub>len/2,j</sub> and the response for negative y-values (beginning with the most negative y) in MRsp<sub>len/2+1,j</sub> to MRsp<sub>len-1,j</sub>.
<BR>You may wish to use <I><a href="#Rows_rotate">MF_Rows_rotate</a></I> and <I><a href="#Cols_rotate">MF_Cols_rotate</a></I>, or <I><a href="#Rows_reflect">MF_Rows_reflect</a></I> and <I><a href="#Cols_reflect">MF_Cols_reflect</a></I> to achieve this wrap-around order and to construct the response matrix.<P>The result of the convolution appears scaled with the sum of all elements of MRsp. Normally, therefore, MRsp should be normalized to 1.0.
<P>MX, MY, MRsp, and MFlt must all be of the same dimensions. Both len and ht have to be integer powers of 2. MX may be overwritten by MY, MRsp may be overwritten by MFlt, but MX and MFlt as well as MY and MRsp have to be distinct from each other.
<P>As in the one-dimensional case, the treatment of round-off errors in the construction of MFlt may be modified by <I><a href="FUNCREF.HTM#setRspEdit">VF_setRspEdit</a></I>.
<BR>The input matrix is assumed to be periodic in both dimensions. See the description of <I><a href="FUNCREF.HTM#convolve">VF_convolve</a></I> on how to avoid end effects, in case it is not periodic.
<BR>About special versions with the prefixes <I>MFl_</I> and <I>MFs_</I>, consult <a href="HANDBOOK.HTM#chap4_8">Kap.&nbsp;4.8 of HANDBOOK.HTM</a>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If either len or ht is not a power of 2, <I><a href="FUNCREF.HTM#FFT">VF_FFT</a></I> (on which <I>MF_convolve</I> is based) complains &quot;Size must be an integer power of 2&quot; and the program is aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#deconvolve">MF_deconvolve</a>,&nbsp;&nbsp; <a href="#FFT">MF_FFT</a>,&nbsp;&nbsp; <a href="#chap12">Kap.&nbsp;12</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="cprint"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_cprint</b></font>
</td><td width="33%"><font size="+1"><b>MD_cprint</b></font></td>
<td><font size="+1"><b>ME_cprint</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_cprint</b></font></td>
<td width="33%"><font size="+1"><b>MCD_cprint</b></font></td>
<td><font size="+1"><b>MCE_cprint</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>print a matrix to the screen (DOS and Win32-console only; not for Visual C++)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_cprint( fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_cprint( MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The matrix MA is printed to the screen. Each line corresponds to one row of the matrix. The lines are numbered. If necessary, rows are cut off at the screen boundaries. If there are more rows than screen lines, proper paging is applied. 
<P>This family of functions is available only for DOS and Win32 console applications with the Borland compilers. It should not be used within TurboVision DOS programs.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If the number of columns exceeds the maximum number of entries possible in the current text mode, an error message &quot;Cannot use requested format (too many entries per line)!&quot; is generated; in this case, the rows are truncated.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#fprint">MF_fprint</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#cprint">VF_cprint</a>,&nbsp;&nbsp; <a href="#chap14">Kap.&nbsp;14</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="deconvolve"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_deconvolve</b></font>
</td><td width="33%"><font size="+1"><b>MD_deconvolve</b></font></td>
<td><font size="+1"><b>ME_deconvolve</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>spatial deconvolution, edge sharpening</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_deconvolve( fMatrix MY, fMatrix MFlt, fMatrix MX, fMatrix MRsp, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_deconvolve( MY, MFlt, MX, MRsp:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MX is assumed to be the result of a convolution of some &quot;true&quot; profile with the response function MRsp; a deconvolution is attempted and stored in MY. A filter MFlt is also calculated; if more than one matrix is to be deconvolved with the same MRsp, use <I>MF_deconvolve</I> only once and use the filter MFlt thus obtained to deconvolve other matrices by calling <I><a href="#filter">MF_filter</a></I>. The response has to be stored in the wrap-around order described above for <I><a href="#convolve">MF_convolve</a></I>.
<P>As for <I><a href="#convolve">MF_convolve</a></I>, MX, MY, MRsp, and MFlt must all be of the same dimensions, which have to be integer powers of 2. MX may be overwritten by MY, MRsp may be overwritten by MFlt, but MX and MFlt as well as MY and MRsp have to be distinct from each other.
<P>Mathematically, MFlt is the inverse of the Fourier transform of MRsp. If the Fourier transform of MRsp contains elements equal to zero, all information is lost for the respective frequency and no reconstruction is possible. The best one can do in this case is to accept this loss and to deconvolve only up to those frequencies where still something is left to be reconstructed.
<BR>You are therefore advised not to use this function blindly but rather to inspect the Fourier transform of MRsp and decide what to do on the basis of your specific application. If you wish to use this function nevertheless, you may rely on the automatic editing of the filter, built into <I>MF_deconvolve</I>. Thereby, MFlt is set to zero (instead of infinity) at those frequences where all information has been lost. You may set the threshold for this implicit editing by <I><a href="FUNCREF.HTM#setRspEdit">VF_setRspEdit</a></I>. In order to retrieve the threshold actually set, use <I><a href="FUNCREF.HTM#getRspEdit">VF_getRspEdit</a></I>. (These two functions are shared between the one- and two-dimensional FFT functions and described in FUNCREF.HTM.)
<P>This deconvolution is based on the implicit assumption that MX is periodic; if this is not the case, see the description of <I><a href="FUNCREF.HTM#convolve">VF_convolve</a></I> about how to avoid end effects.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If either len or ht is not a power of 2, <I><a href="FUNCREF.HTM#FFT">VF_FFT</a></I> (on which <I>MF_deconvolve</I> is based) complains &quot;Size must be an integer power of 2&quot; and the program is aborted.
<BR>If, by <I><a href="FUNCREF.HTM#setRspEdit">VF_setRspEdit</a></I>, you specified Trunc.Re = Trunc.Im = 0, SING errors may occur that are handled by setting MFlt to &#177;HUGE_VAL at the respective frequency. During multiplication with the transform of MX, this may lead to unhandled floating-point overflow errors (in case your guess of MRsp was wrong and there is some information left at the frequencies where you thought it was not).
<BR>About special versions with the prefixes <I>MFl_</I> and <I>MFs_</I>, consult <a href="HANDBOOK.HTM#chap4_8">Kap.&nbsp;4.8 of HANDBOOK.HTM</a>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#convolve">MF_convolve</a>,&nbsp;&nbsp; <a href="#FFT">MF_FFT</a>,&nbsp;&nbsp; <a href="#chap12">Kap. 12</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="det"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_det</b></font>
</td><td width="33%"><font size="+1"><b>MD_det</b></font></td>
<td><font size="+1"><b>ME_det</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_det</b></font></td>
<td width="33%"><font size="+1"><b>MCD_det</b></font></td>
<td><font size="+1"><b>MCE_det</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>determinant of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float MF_det( fMatrix MA, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_det( MA:fMatrix; len:UInt ):Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The determinant of MA is calculated. For large matrices, this is done <I>via</I> LU decomposition. For small matrices, individual formulae are applied.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>determinant of the matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#LUdecompose">MF_LUdecompose</a>,&nbsp;&nbsp; <a href="#solve">MF_solve</a>,&nbsp;&nbsp; <a href="#chap10">Kap.&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_absmax"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_absmax</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_absmax</b></font></td>
<td><font size="+1"><b>ME_Dia_absmax</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_absmax</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_absmax</b></font></td>
<td><font size="+1"><b>MCE_Dia_absmax</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>absolute maximum of the elements of the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float MF_Dia_absmax( fMatrix MA, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_Dia_absmax( MA:fMatrix; len:UInt ):Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The maximum absolute value of all elements MA<sub>i,i</sub> is returned as a scalar</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>absolute maximum of the diagonal</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_max">MF_Dia_max</a>,&nbsp;&nbsp; <a href="#Dia_absmin">MF_Dia_absmin</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_absmin"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_absmin</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_absmin</b></font></td>
<td><font size="+1"><b>ME_Dia_absmin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_absmin</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_absmin</b></font></td>
<td><font size="+1"><b>MCE_Dia_absmin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>absolute minimum of the elements of the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float MF_Dia_absmin( fMatrix MA, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_Dia_absmin( MA:fMatrix; len:UInt ):Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The minimum absolute value of all elements MA<sub>i,i</sub> is returned as a scalar</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>absolute minimum of the diagonal</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_min">MF_Dia_min</a>,&nbsp;&nbsp; <a href="#Dia_absmax">MF_Dia_absmax</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_addC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_addC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_addC</b></font></td>
<td><font size="+1"><b>ME_Dia_addC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_addC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_addC</b></font></td>
<td><font size="+1"><b>MCE_Dia_addC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>add a constant to all elements of the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_addC( fMatrix MA, unsigned len, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_addC( MA:fMatrix; len:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> += C,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_addV">MF_Dia_addV</a>,&nbsp;&nbsp; <a href="#Dia_subC">MF_Dia_subC</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_addV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_addV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_addV</b></font></td>
<td><font size="+1"><b>ME_Dia_addV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_addV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_addV</b></font></td>
<td><font size="+1"><b>MCE_Dia_addV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise addition of a vector to the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_addV( fMatrix MA, unsigned len, fVector X );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_addV( MA:fMatrix; len:UInt; X:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> += X<sub>i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_addC">MF_Dia_addC</a>,&nbsp;&nbsp; <a href="#Dia_subV">MF_Dia_subV</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_divC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_divC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_divC</b></font></td>
<td><font size="+1"><b>ME_Dia_divC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_divC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_divC</b></font></td>
<td><font size="+1"><b>MCE_Dia_divC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>divide all elements of the diagonal of a square matrix by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_divC( fMatrix MA, unsigned len, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_divC( MA:fMatrix; len:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> /= C,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_divV">MF_Dia_divV</a>,&nbsp;&nbsp; <a href="#Dia_mulC">MF_Dia_mulC</a>,&nbsp;&nbsp; <a href="#Dia_divrC">MF_Dia_divrC</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_divrC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_divrC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_divrC</b></font></td>
<td><font size="+1"><b>ME_Dia_divrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_divrC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_divrC</b></font></td>
<td><font size="+1"><b>MCE_Dia_divrC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>reverse division: divide a constant by the elements of the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_divrC( fMatrix MA, unsigned len, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_divrC( MA:fMatrix; len:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> = C / MA<sub>i,i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_divrV">MF_Dia_divrV</a>,&nbsp;&nbsp; <a href="#Dia_mulC">MF_Dia_mulC</a>,&nbsp;&nbsp; <a href="#Dia_divC">MF_Dia_divC</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_divrV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_divrV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_divrV</b></font></td>
<td><font size="+1"><b>ME_Dia_divrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_divrV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_divrV</b></font></td>
<td><font size="+1"><b>MCE_Dia_divrV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>reverse division: divide a vector by the diagonal of a square matrix, storing the result back into the diagonal</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_divrV( fMatrix MA, unsigned len, fVector X );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_divrV( MA:fMatrix; len:UInt; X:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> = X<sub>i</sub> / MA<sub>i,i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_divV">MF_Dia_divV</a>,&nbsp;&nbsp; <a href="#Dia_mulV">MF_Dia_mulV</a>,&nbsp;&nbsp; <a href="#Dia_divrC">MF_Dia_divrC</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_divV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_divV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_divV</b></font></td>
<td><font size="+1"><b>ME_Dia_divV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_divV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_divV</b></font></td>
<td><font size="+1"><b>MCE_Dia_divV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise division of the diagonal of a square matrix by a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_divV( fMatrix MA, unsigned len, fVector X );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_divV( MA:fMatrix; len:UInt; X:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> / X<sub>i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_divrV">MF_Dia_divrV</a>,&nbsp;&nbsp; <a href="#Dia_mulV">MF_Dia_mulV</a>,&nbsp;&nbsp; <a href="#Dia_divC">MF_Dia_divC</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_equ0"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_equ0</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_equ0</b></font></td>
<td><font size="+1"><b>ME_Dia_equ0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_equ0</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_equ0</b></font></td>
<td><font size="+1"><b>MCE_Dia_equ0</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>initialize all elements of the diagonal of a square matrix with zero</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_equ0( fMatrix MA, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_equ0( MA:fMatrix; len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> = 0,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_equC">MF_Dia_equC</a>,&nbsp;&nbsp; <a href="#Dia_equV">MF_Dia_equV</a>,&nbsp;&nbsp; <a href="#chap3">Kap.&nbsp;3</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_equC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_equC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_equC</b></font></td>
<td><font size="+1"><b>ME_Dia_equC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_equC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_equC</b></font></td>
<td><font size="+1"><b>MCE_Dia_equC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>initialize all elements of the diagonal of a square matrix with a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_equC( fMatrix MA, unsigned len, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_equC( MA:fMatrix; len:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> = C,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_equ0">MF_Dia_equ0</a>,&nbsp;&nbsp; <a href="#Dia_equV">MF_Dia_equV</a>,&nbsp;&nbsp; <a href="#chap3">Kap.&nbsp;3</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_equV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_equV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_equV</b></font></td>
<td><font size="+1"><b>ME_Dia_equV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_equV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_equV</b></font></td>
<td><font size="+1"><b>MCE_Dia_equV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>copy a vector into the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_equV( fMatrix MA, unsigned len, fVector X );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_equV( MA:fMatrix; len:UInt; X:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> = X<sub>i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_equ0">MF_Dia_equ0</a>,&nbsp;&nbsp; <a href="#Dia_equC">MF_Dia_equC</a>,&nbsp;&nbsp; <a href="#chap3">Kap.&nbsp;3</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_extract"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_extract</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_extract</b></font></td>
<td><font size="+1"><b>ME_Dia_extract</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_extract</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_extract</b></font></td>
<td><font size="+1"><b>MCE_Dia_extract</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>copy the diagonal of a square matrix into a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_extract( fVector Y, fMatrix MA, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_extract( Y:fVector; MA:fMatrix; len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = MA<sub>i,i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_equV">MF_Dia_equV</a>,&nbsp;&nbsp; <a href="#chap3">Kap.&nbsp;3</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_max"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_max</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_max</b></font></td>
<td><font size="+1"><b>ME_Dia_max</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_max</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_max</b></font></td>
<td><font size="+1"><b>MCE_Dia_max</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>maximum of all elements of the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float MF_Dia_max( fMatrix MA, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_Dia_max( MA:fMatrix; len:UInt ):Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>the largest element of the diagonal is returned as a scalar</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>maximum of the diagonal</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_absmax">MF_Dia_absmax</a>,&nbsp;&nbsp; <a href="#Dia_min">MF_Dia_min</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_min"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_min</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_min</b></font></td>
<td><font size="+1"><b>ME_Dia_min</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_min</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_min</b></font></td>
<td><font size="+1"><b>MCE_Dia_min</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>minimum of all elements of the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float MF_Dia_min( fMatrix MA, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_Dia_min( MA:fMatrix; len:UInt ):Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>the smallest or most negative element of the diagonal is returned as a scalar</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>minimum of the diagonal</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_absmin">MF_Dia_absmin</a>,&nbsp;&nbsp; <a href="#Dia_max">MF_Dia_max</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_mulC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_mulC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_mulC</b></font></td>
<td><font size="+1"><b>ME_Dia_mulC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_mulC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_mulC</b></font></td>
<td><font size="+1"><b>MCE_Dia_mulC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply all elements of the diagonal of a square matrix by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_mulC( fMatrix MA, unsigned len, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_mulC( MA:fMatrix; len:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> *= C,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_mulV">MF_Dia_mulV</a>,&nbsp;&nbsp; <a href="#Dia_divC">MF_Dia_divC</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_mulV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_mulV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_mulV</b></font></td>
<td><font size="+1"><b>ME_Dia_mulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_mulV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_mulV</b></font></td>
<td><font size="+1"><b>MCE_Dia_mulV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise multiplication of the diagonal of a square matrix by a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_mulV( fMatrix MA, unsigned len, fVector X );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_mulV( MA:fMatrix; len:UInt; X:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> *= X<sub>i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_mulC">MF_Dia_mulC</a>,&nbsp;&nbsp; <a href="#Dia_divV">MF_Dia_divV</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_prod"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_prod</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_prod</b></font></td>
<td><font size="+1"><b>ME_Dia_prod</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_prod</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_prod</b></font></td>
<td><font size="+1"><b>MCE_Dia_prod</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>product of all elements of the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float MF_Dia_prod( fMatrix MA, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_Dia_prod( MA:fMatrix; len:UInt ):Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>the product of the diagonal elements is returned as a scalar</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>product of the diagonal elements</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_sum">MF_Dia_sum</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_subC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_subC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_subC</b></font></td>
<td><font size="+1"><b>ME_Dia_subC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_subC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_subC</b></font></td>
<td><font size="+1"><b>MCE_Dia_subC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>subtract a constant from all elements of the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_subC( fMatrix MA, unsigned len, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_subC( MA:fMatrix; len:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> -= C,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_subV">MF_Dia_subV</a>,&nbsp;&nbsp; <a href="#Dia_subrC">MF_Dia_subrC</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_subrC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_subrC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_subrC</b></font></td>
<td><font size="+1"><b>ME_Dia_subrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_subrC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_subrC</b></font></td>
<td><font size="+1"><b>MCE_Dia_subrC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>reverse subtraction: a constant minus the elements of the diagonal of a square matrix, storing the result back into the diagonal</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_subrC( fMatrix MA, unsigned len, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_subrC( MA:fMatrix; len:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> = C - MA<sub>i,i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_subrV">MF_Dia_subrV</a>,&nbsp;&nbsp; <a href="#Dia_subC">MF_Dia_subC</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_subrV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_subrV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_subrV</b></font></td>
<td><font size="+1"><b>ME_Dia_subrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_subrV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_subrV</b></font></td>
<td><font size="+1"><b>MCE_Dia_subrV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>reverse subtraction: subtract the elements of the diagonal of a square matrix from corresponding elements of a vector, storing the result back into the diagonal</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_subrV( fMatrix MA, unsigned len, fVector X );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_subrV( MA:fMatrix; len:UInt; X:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> = X<sub>i</sub> - MA<sub>i,i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_subV">MF_Dia_subV</a>,&nbsp;&nbsp; <a href="#Dia_subrC">MF_Dia_subrC</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_subV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_subV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_subV</b></font></td>
<td><font size="+1"><b>ME_Dia_subV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_subV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_subV</b></font></td>
<td><font size="+1"><b>MCE_Dia_subV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise subtraction of a vector from the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Dia_subV( fMatrix MA, unsigned len, fVector X );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Dia_subV( MA:fMatrix; len:UInt; X:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> -= X<sub>i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_subrV">MF_Dia_subrV</a>,&nbsp;&nbsp; <a href="#Dia_subC">MF_Dia_subC</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Dia_sum"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Dia_sum</b></font>
</td><td width="33%"><font size="+1"><b>MD_Dia_sum</b></font></td>
<td><font size="+1"><b>ME_Dia_sum</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Dia_sum</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Dia_sum</b></font></td>
<td><font size="+1"><b>MCE_Dia_sum</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>sum over all elements of the diagonal of a square matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float MF_Dia_sum( fMatrix MA, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_Dia_sum( MA:fMatrix; len:UInt ):Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>the elements of the diagonal are summed up and returned as a scalar</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>sum over the diagonal elements</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_prod">MF_Dia_prod</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="divC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_divC</b></font>
</td><td width="33%"><font size="+1"><b>MD_divC</b></font></td>
<td><font size="+1"><b>ME_divC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_divC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_divC</b></font></td>
<td><font size="+1"><b>MCE_divC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_divReC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_divReC</b></font></td>
<td><font size="+1"><b>MCE_divReC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>divide all matrix elements by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_divC( fMatrix MB, fMatrix MA, unsigned ht, unsigned len, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_divC( MB, MA:fMatrix; ht, len:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>M<sub>i,j</sub> /= C,&nbsp;&nbsp;i=0,...,ht-1;&nbsp;&nbsp;j=0,..,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#mulC">MF_mulC</a>,&nbsp;&nbsp; <a href="#chap3">Kap.&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="DtoF"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>M_DtoF</b></font></td><td><font size="+1"><b>M_DtoE</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Data type conversions. See <I><a href="#FtoD">M_FtoD</a></I>.</td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="element"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_element</b></font>
</td><td width="33%"><font size="+1"><b>MD_element</b></font></td>
<td><font size="+1"><b>ME_element</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_element</b></font></td>
<td width="33%"><font size="+1"><b>MCD_element</b></font></td>
<td><font size="+1"><b>MCE_element</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>read-only access to a matrix element</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float MF_element( fMatrix X, unsigned ht, unsigned len, unsigned m, unsigned n );<BR>
fComplex MCF_element( cfMatrix X, unsigned ht, unsigned len, unsigned m, unsigned n );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_element( MA:fMatrix; ht, len, m, n:UInt );<BR>
procedure MCF_element( var RetVal:fComplex; MA:cfMatrix; ht, len, m, n:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP">
<td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The element MA<sub>m,n</sub> is returned.
<BR>Pascal/Delphi only: As fComplex return values are not possible, the <i>MCF_</i> version stores MA<sub>m,n</sub> into the variable RetVal.
<BR>This function is needed to read elements of dynamically allocated matrices, for which older versions of Borland C++ had a pointer arithmetics bug, and Pascal/Delphi - unlike C - does not provide an own mechanism at all.
<BR><i>MF_element</i> is &quot;read-only&quot;. This means, you c a n n o t write something like
<BR><font face="courier new">MF_element( MX, ht, len, 3, 4 ) := 5;</font><BR>
Write access to individual matrix elements is provided by <I><a href="#Pelement">MF_Pelement</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>the matrix element m,n (except complex version in Pascal/Delphi)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Pelement">MF_Pelement</a>,&nbsp;&nbsp; <a href="#chap2">Kap.&nbsp;2</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="eigenvalues"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MFsym_eigenvalues</b></font>
</td><td width="33%"><font size="+1"><b>MDsym_eigenvalues</b></font></td>
<td><font size="+1"><b>MEsym_eigenvalues</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Eigenvalues and/or Eigenvectors of a real symmetric matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MFsym_eigenvalues( fVector EigVals, fMatrix EigVecs, fMatrix MA, unsigned len, int CalcEigenVec );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MFsym_eigenvalues( EigVals:fVector; EigVecs, MA:fMatrix; len:UInt; CalcEigenVec:IntBool );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The eigenvalues, with or without the eigenvectors, of MA are calculated. This function is for symmetric real matrices only! It takes the following arguments:
<UL><LI>EigVals: a vector in which the eigenvalues will be returned
<LI>EigVecs: a matrix whose columns will be filled with the eigenvectors
<LI>MA: the input matrix, which may or may not be overwritten by EigVecs
<LI>len: the length of the rows (which is the same as the height of the columns, as MA must be a symmetric square matrix)
<LI>CalcEigenVec: an int or IntBool, deciding if only the eigenvalues are needed (CalcEigenVec = FALSE or 0), or if the eigenvectors are desired as well (CalcEigenVec = TRUE or 1). Calculating the eigenvalues alone, without the eigenvectors, can speed up the calculation by up to a factor of two.
</UL></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap10">Kap.&nbsp;10</a>,&nbsp;&nbsp; <a href="#chap11">Kap.&nbsp;11</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="equ0"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_equ0</b></font>
</td><td width="33%"><font size="+1"><b>MD_equ0</b></font></td>
<td><font size="+1"><b>ME_equ0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_equ0</b></font></td>
<td width="33%"><font size="+1"><b>MCD_equ0</b></font></td>
<td><font size="+1"><b>MCE_equ0</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>initialize a matrix with all elements set to 0</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_equ0( fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_equ0( MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,j</sub> = 0</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#equ1">MF_equ1</a>,&nbsp;&nbsp; <a href="#equM">MF_equM</a>,&nbsp;&nbsp; <a href="#chap3">Kap.&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="equ1"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_equ1</b></font>
</td><td width="33%"><font size="+1"><b>MD_equ1</b></font></td>
<td><font size="+1"><b>ME_equ1</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_equ1</b></font></td>
<td width="33%"><font size="+1"><b>MCD_equ1</b></font></td>
<td><font size="+1"><b>MCE_equ1</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>identity matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_equ1( fMatrix MA, unsigned len ); </font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_equ1( MA:fMatrix; len:UInt ); </font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> = 1<BR>
MA<sub>i,j</sub> = 0,&nbsp;&nbsp;i != j</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#equ0">MF_equ0</a>,&nbsp;&nbsp; <a href="#equm1">MF_equm1</a>,&nbsp;&nbsp; <a href="#chap3">Kap.&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="equm1"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_equm1</b></font>
</td><td width="33%"><font size="+1"><b>MD_equm1</b></font></td>
<td><font size="+1"><b>ME_equm1</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_equm1</b></font></td>
<td width="33%"><font size="+1"><b>MCD_equm1</b></font></td>
<td><font size="+1"><b>MCE_equm1</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>negative identity matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_equm1( fMatrix MA, unsigned len ); </font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_equm1( MA:fMatrix; len:UInt ); </font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,i</sub> = -1<BR>
MA<sub>i,j</sub> = 0,&nbsp;&nbsp;i != j</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#equ0">MF_equ0</a>,&nbsp;&nbsp; <a href="#equm1">MF_equ1</a>,&nbsp;&nbsp; <a href="#chap3">Kap.&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="equM"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_equM</b></font>
</td><td width="33%"><font size="+1"><b>MD_equM</b></font></td>
<td><font size="+1"><b>ME_equM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_equM</b></font></td>
<td width="33%"><font size="+1"><b>MCD_equM</b></font></td>
<td><font size="+1"><b>MCE_equM</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>make one matrix the copy of another</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_equM( fMatrix MB, fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_equM( MB, MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MB<sub>i,j</sub> = MA<sub>i,j</sub></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#transpose">MF_transpose</a>,&nbsp;&nbsp; <a href="#neg">MF_neg</a>,&nbsp;&nbsp; <a href="#chap3">Kap.&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="FFT"></a><a name="FFTtoC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_FFT</b></font></td>
<td width="33%"><font size="+1"><b>MD_FFT</b></font></td>
<td><font size="+1"><b>ME_FFT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_FFTtoC</b></font>
</td><td width="33%"><font size="+1"><b>MD_FFTtoC</b></font></td>
<td><font size="+1"><b>ME_FFTtoC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_FFT</b></font></td>
<td width="33%"><font size="+1"><b>MCD_FFT</b></font></td>
<td><font size="+1"><b>MCE_FFT</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>two-dimensional Fast Fourier Transform</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_FFT( fMatrix MY, fMatrix MX, unsigned ht, unsigned len, int dir );<BR>
void MCF_FFT( cfMatrix MY, cfMatrix MX, unsigned ht, unsigned len, int dir );<BR>
void MF_FFTtoC( cfMatrix MY, fMatrix MX, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_FFT( MY, MX:fMatrix; ht, len:UInt; dir:Integer );<BR>
procedure MCF_FFT( MY, MX:cfMatrix; ht, len:UInt; dir:Integer );<BR>
procedure MF_FFTtoC( MY:cfMatrix; MX:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The Fourier transform of MX is calculated and stored in MY. The forward transform is obtained by setting dir = 1, the inverse (or backward) transform by setting dir = -1. A Fast Fourier Transform algorithm is used that requires both ht and len to be powers of 2.
<BR>Complex version: Both MX and the output MY are complex matrices.
<BR>Real-to-complex version: The input matrix MX is real. The output matrix MY is complex. As this function can only perform a forward transform, no argument &quot;dir&quot; is needed.
<BR>Purely real version: For the forward transform, MX is a real matrix. The output MY is also defined as fMatrix, although it consists of complex numbers. The reason is that, just as in the one-dimensional case, the symmetry properties of two-dimensional FFT allow to store the result in a packed format, fitting into the same memory space as the input matrix. The order of storage in MY is derived from the ordering in the one-dimensional case, with the packing applied first to all rows, then to the columns. The resulting order is indicated in the following table. U means the uncompressed result.
<table border cols=7 width="100%">
<tr valign="top"><td>U<sub>0,0</sub>.Re</td><td>U<sub>0,len/2</sub>.Re</td><td>U<sub>0,1</sub>.Re</td><td>U<sub>0,1</sub>.Im</td><td>&#183;&#183;&#183;</td><td>U<sub>0,len/2-1</sub>.Re</td><td>U<sub>0,len/2-1</sub>.Im</td></tr>
<tr valign="top"><td>U<sub>ht/2,0</sub>.Re</td><td>U<sub>ht/2,len/2</sub>.Re</td><td>U<sub>1,1</sub>.Re</td><td>U<sub>1,1</sub>.Im</td><td>&#183;&#183;&#183;</td><td>U<sub>1,len/2-1</sub>.Re</td><td>U<sub>1,len/2-1</sub>.Im</td></tr>
<tr valign="top"><td>U<sub>1,0</sub>.Re</td><td>U<sub>1,len/2</sub>.Re</td><td>U<sub>2,1</sub>.Re</td><td>U<sub>2,1</sub>.Im</td><td>&#183;&#183;&#183;</td><td>U<sub>2,len/2-1</sub>.Re</td><td>U<sub>2,len/2-1</sub>.Im</td></tr>
<tr valign="top"><td>U<sub>1,0</sub>.Im</td><td>U<sub>1,len/2</sub>.Im</td><td>U<sub>3,1</sub>.Re</td><td>U<sub>3,1</sub>.Im</td><td>&#183;&#183;&#183;</td><td>U<sub>3,len/2-1</sub>.Re</td><td>U<sub>3,len/2-1</sub>.Im</td></tr>
<tr valign="top"><td>&#183;&#183;&#183;</td><td>&#183;&#183;&#183;</td><td>&#183;&#183;&#183;</td><td>&#183;&#183;&#183;</td><td>&#183;&#183;&#183;</td><td>&#183;&#183;&#183;</td><td>&#183;&#183;&#183;</td></tr>
<tr valign="top"><td>U<sub>ht/2-1,0</sub>.Re</td><td>U<sub>ht/2-1,len/2</sub>.Re</td><td>&#183;&#183;&#183;</td><td>&#183;&#183;&#183;</td><td>&#183;&#183;&#183;</td><td>&#183;&#183;&#183;</td><td>&#183;&#183;&#183;</td></tr>
<tr valign="top"><td>U<sub>ht/2-1,0</sub>.Im</td><td>U<sub>ht/2-1,len/2</sub>.Im</td><td>U<sub>ht-1,1</sub>.Re</td><td>U<sub>ht-1,1</sub>.Im</td><td>&#183;&#183;&#183;</td><td>U<sub>ht-1,len/2-1</sub>.Re</td><td>U<sub>ht-1,len/2-1</sub>.Im</td></tr>
</table>&nbsp;
<BR>For inverse real-matrix FFT, the input matrix has to be of this packed-complex format, and you get a real matrix. If you prefer to get the result of forward FFT as a true complex matrix, use <I>MF_FFTtoC</I>.
<P>About special versions with the prefixes <i>VFs_</i> and <i>VFl_</i>, consult <a href="HANDBOOK.HTM#chap4_8">Kap.&nbsp;4.8.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If either ht or len is not a power of 2, <I><a href="FUNCREF.HTM#FFT">VF_FFT</a></I> (on which <I>MF_FFT</I> is based) complains &quot;Size must be an integer power of 2&quot; and the program is aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap12">Kap.&nbsp;12</a>,&nbsp;&nbsp; <a href="HANDBOOK.HTM#chap4_8">Kap.&nbsp;4.8 of HANDBOOK.HTM</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="filter"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_filter</b></font>
</td><td width="33%"><font size="+1"><b>MD_filter</b></font></td>
<td><font size="+1"><b>ME_filter</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_filter</b></font></td>
<td width="33%"><font size="+1"><b>MCD_filter</b></font></td>
<td><font size="+1"><b>MCE_filter</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Spatial frequency filtering</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_filter( fMatrix MY, fMatrix MX, fMatrix MFlt, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_filter( MY, MX, MFlt:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A spatial frequency filter MFlt is applied to the matrix MX. Internally, this is done by performing a Fourier transform on MX, multiplying the transform with MFlt and transforming the product back into the space domain.
<P>Complex versions: MX, MY and the filter MFlt are complex matrices.
<BR>Real versions: MX and MY are real. MFlt has to be in the packed complex format that is obtained by Fourier transforming a real matrix with <I><a href="#FFT">MF_FFT</a></I> (see that function for the description of the packed complex format) or by using <I><a href="#convolve">MF_convolve</a></I>.
<P>If MX is non-periodic, the edges of the filtered function may be spoiled by wrap-around. See <I><a href="FUNCREF.HTM#convolve">VF_convolve</a></I> about how to avoid end-effects. As described there for vectors, embed the matrix MX in a larger matrix or remove a possible linear trends in both dimensions.
<BR>About special versions with the prefixes <i>VFs_</i> and <I>VFl_</I>, consult <a href="HANDBOOK.HTM#chap4_8">Kap.&nbsp;4.8.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If either ht or len is not a power of 2, <I><a href="#FFT">VF_FFT</a></I> (on which <I>MF_filter</I> is based) complains &quot;Size must be an integer power of 2&quot; and the program is aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#FFT">MF_FFT</a>,&nbsp;&nbsp; <a href="#convolve">MF_convolve</a>,&nbsp;&nbsp; <a href="#chap12">Kap.&nbsp;12</a>,&nbsp;&nbsp; <a href="HANDBOOK.HTM#chap4_8">Kap.&nbsp;4.8 of HANDBOOK.HTM</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="findDensityMapBounds"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="90%"><font size="+1"><b>M_findDensityMapBounds</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Calculate a color scale and draw an X-Y coordinate system for matrix color-density plots</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Mgraph.h&gt;<BR>
void M_findDensityMapBounds( extended xmin, extended xmax, extended ymin, extended ymax, extended zmin, extended zmax, COLORREF mincolor, COLORREF maxcolor );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses Mgraph;<BR>
procedure M_findDensityMapBounds( xmin, xmax, ymin, ymax, zmin, zmax: Extended; mincolor, maxcolor: COLORREF );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Similarly to the function <I><a href="FUNCREF.HTM#findAxes">V_findAxes</a></I> for X-Y vector plots, this function calculates a color scale from the parameters mincolor, maxcolor, zmin and zmax, and prepares an X-Y coordinate system for color-density plots of matrices. If necessary, the <I>x</I> and <I>y</I> ranges are slightly enlarged so as to ensure that the grid-lines correspond to exact (rather than only rounded) values. If zero falls into either or both ranges, it will fall onto a grid line. 
<P>The user will rarely call this function himself. It is internally called by all functions of the <I><a href="#xyzAutoDensityMap">MF_xyzAutoDensityMap</a></I> and <I><a href="#zAutoDensityMap">MF_zAutoDensityMap</a></I> families.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#xyzAutoDensityMap">MF_xyzAutoDensityMap</a>,&nbsp;&nbsp; <a href="#zAutoDensityMap">MF_zAutoDensityMap</a>,&nbsp;&nbsp; <a href="#chap15">Kap.&nbsp;15</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="fprint"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_fprint</b></font>
</td><td width="33%"><font size="+1"><b>MD_fprint</b></font></td>
<td><font size="+1"><b>ME_fprint</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_fprint</b></font></td>
<td width="33%"><font size="+1"><b>MCD_fprint</b></font></td>
<td><font size="+1"><b>MCE_fprint</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>print a matrix in ASCII format to a stream</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_fprint( FILE *stream, fMatrix MA, unsigned ht, unsigned len, unsigned linewidth );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
{Delphi version:}<BR>
&nbsp;&nbsp;procedure MF_fprint( var Stream:TextFile; MA:fMatrix; ht, len, linewidth:UInt );<BR>
{Turbo Pascal version:}<BR>
&nbsp;&nbsp;procedure MF_fprint( var Stream:Text; MA:fMatrix; ht, len, linewidth:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The matrix MA is written to stream. Each line corresponds to one row of the matrix. The lines are numbered. If the specified linewidth is too small to write all columns, rows are cut off.
<BR>Printing starts always with a new line. This may lead to an empty line at the beginning. Especially the first line of a file is reserved for a possible headline.
<BR>Cartesian complex numbers are printed in braces, with the real and imaginary parts separated by a komma: {Re, Im}.<P>In contrast to <I><a href="#write">MF_write</a></I>, it is not possible to override the automatic choice of the format used for printing. The number of digits per element is determined by the available space, which depends in turn on the parameters len and linewidth.
</td></tr></table></td></tr><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>if len exceeds the maximum number of entries possible for the linewidth chosen, an error message &quot;Cannot use requested format (too many entries per line)!&quot; is generated; in this case, the program truncates the rows at the maximum number of columns possible.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#cprint">MF_cprint</a>,&nbsp;&nbsp; <a href="#chap14">Kap.&nbsp;14</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="free"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="90%"><font size="+1"><b>M_free</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>de-allocate a matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void M_free( void **M );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure M_free( M:Pointer );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The matrix M is freed (i.e. de-allocated). <I>M_free</I> should be used only for the de-allocation of matrices which have previously be allocated by one of the functions of the <I><a href="#matrix">MF_matrix</a></I> or <I><a href="#matrix0">MF_matrix0</a></I> family. To free several matrices simultaneously, use <I><a href="#nfree">M_nfree</a></I> (C/C++ only). To free all allocated vectors and matrices simultaneously, call <I><a href="FUNCREF.HTM#freeAll">V_freeAll</a></I>.
</td></tr></table></td></tr><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Trying to free a matrix that has already been freed, or that has never been allocated memory, leads to a warning message &quot;Cannot free non-existent vector&quot;. Program execution is continued without freeing anything in this case.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#nfree">M_nfree</a></I>,&nbsp;&nbsp;<I><a href="FUNCREF.HTM#freeAll">V_freeAll</a></I>,&nbsp;&nbsp;<I><a href="#matrix">MF_matrix</a></I>,&nbsp;&nbsp;<I><a href="#matrix0">MF_matrix0</a></I></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="FtoD"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>M_FtoD</b></font></td><td width="25%"><font size="+1"><b>M_FtoE</b></font></td><td width="25%"><font size="+1"><b>M_CFtoCD</b></font></td><td><font size="+1"><b>M_CFtoCE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>M_DtoF</b></font></td><td width="25%"><font size="+1"><b>M_DtoE</b></font></td><td width="25%"><font size="+1"><b>M_CDtoCF</b></font></td><td><font size="+1"><b>M_CDtoCE</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="25%"><font size="+1"><b>M_EtoF</b></font></td><td width="25%"><font size="+1"><b>M_EtoD</b></font></td><td width="25%"><font size="+1"><b>M_CEtoCF</b></font></td><td><font size="+1"><b>M_CEtoCD</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Data type interconversions.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MDstd.h&gt;</font><BR>
&nbsp;&nbsp;&nbsp;&nbsp;(always include the <font face="courier new">&lt;M..std.h&gt;</font> file of the destination data-type!)<br><font face="courier new">
void M_FtoD( dMatrix MY, fMatrix MX, unsigned ht, unsigned len );</font><BR>
&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MDstd;</font><BR>
&nbsp;&nbsp;&nbsp;&nbsp;(always include the unit of the destination data-type!)<BR><font face="courier new">
procedure M_FtoD( MY:dMatrix; MX:fMatrix; ht, len:UInt );</font><BR>
&nbsp;&nbsp;&nbsp;&nbsp;(similarly all other functions of this family)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Each element of MX is converted from the data type specified for MX to the data type specified for MY and stored in MY.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>OVERFLOW errors may occur in the course of the &quot;down-conversions&quot; (e.g., <I>M_EtoF</I>); by default, the extreme value possible for the destination data type is stored in MY with the correct sign.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap4">Kap.&nbsp;4</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="getLinfitNeglect"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_getLinfitNeglect</b></font>
</td><td width="33%"><font size="+1"><b>VD_getLinfitNeglect</b></font></td>
<td><font size="+1"><b>VE_getLinfitNeglect</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>retrieve the current significance threshold for data fitting to linear models</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float VF_getLinfitNeglect( void );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function VF_getLinfitNeglect:Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Internally, the linear-fitting functions like <I><a href="#linfit">VF_linfit</a></I> employ a Singular Value Decomposition algorithm to obtain a solution even for (near-)singular linear systems. Thereby, coefficients <I>a<sub>i</sub></I> whose significance is lower than a threshold, <I>Thresh</I>, are set to 0 instead of infinity. This threshold can be modified by calling <I><a href="#setLinfitNeglect">VF_setLinfitNeglect</a></I>. The current threshold can be retrieved by
<I>VF_getLinfitNeglect</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>current significance threshold for linear fitting</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#linfit">VF_linfit</a>,&nbsp;&nbsp; <a href="#multiLinfit">VF_multiLinfit</a>,&nbsp;&nbsp; <a href="#chap13_2">Kap.&nbsp;13.2</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="getNonlinfitOptions"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_getNonlinfitOptions</b></font>
</td><td width="33%"><font size="+1"><b>VD_getNonlinfitOptions</b></font></td>
<td><font size="+1"><b>VE_getNonlinfitOptions</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>retrieve current set of options for nonlinear fitting</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void VF_getNonlinfitOptions( VF_NONLINFITOPTIONS *Options );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure VF_getNonlinfitOptions( var Options: VF_NONLINFITOPTIONS );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The nonlinear fitting routines like <I><a href="#nonlinfit">VF_nonlinfit</a></I> offer the user a lot of different options, packed into a structure <I><a href="#chap13_3NONLINFITOPTIONS">VF_NONLINFITOPTIONS</a></I> (<I>VD_NONLINFITOPTIONS</I> and <I>VE_NONLINFITOPTIONS</I> for the higher accuracy data-types). These options may be set by the function <I><a href="#setNonlinfitOptions">V_setNonlinfitOptions</a></I>. To retrieve current settings, use
<I>V_getNonlinfitOptions</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap13_3">Kap.&nbsp;13.3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Hanning"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Hanning</b></font>
</td><td width="33%"><font size="+1"><b>MD_Hanning</b></font></td>
<td><font size="+1"><b>ME_Hanning</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>two-dimensional Hanning window for spatial frequency analysis</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Hanning( fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Hanning( MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,j</sub> = 0.25 * (1 - cos( 2 <font face="symbol">p</font> i / (ht-1) )) * (1 - cos( 2 <font face="symbol">p</font> j / (len-1) ))</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Parzen">MF_Parzen</a>,&nbsp;&nbsp; <a href="#Welch">MF_Welch</a>,&nbsp;&nbsp; <a href="#spectrum">MF_spectrum</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="hermconj"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_hermconj</b></font>
</td><td width="33%"><font size="+1"><b>MCD_hermconj</b></font></td>
<td><font size="+1"><b>MCE_hermconj</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Hermitian conjugate of a matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MCFstd.h&gt;<BR>
void MCF_hermconj( cfMatrix MTr, cfMatrix MA, unsigned htTr, unsigned lenTr );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MCFstd;<BR>
procedure MCF_hermconj( MTr, MA:cfMatrix; htTr, lenTr:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The Hermitian conjugate of a complex matrix is defined as the complex conjugate of its transpose:<BR>
MTr<sub>i,j</sub> = MA<sub>j,i</sub><sup>*</sup>
<BR>The dimensions fed into this function, htTr and lenTr, refer to the transposed matrix rather than to the input matrix.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#transpose">MCF_transpose</a>,&nbsp;&nbsp; <a href="#conj">MCF_conj</a>,&nbsp;&nbsp; <a href="#chap5">Kap.&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="HmulM"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_HmulM</b></font></td>
<td width="33%"><font size="+1"><b>MCD_HmulM</b></font></td>
<td><font size="+1"><b>MCE_HmulM</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply the hermitian conjugate of one matrix by another matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MCFstd.h&gt;<BR>
void MCF_HmulM( cfMatrix MC, cfMatrix MA, cfMatrix MB, unsigned htA, unsigned lenA, unsigned lenB );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MCFstd;<BR>
procedure MCF_HmulM( MC, MA, MB:cfMatrix; htA, lenA, lenB:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MC = MA<sup>T*</sup> * MB
<BR>htA, lenA, and lenB must be specified; the other dimensions are implicitly given as: htB = htA, lenC = lenB, htC = lenA. htA and lenA refer to the original, un-transposed input matrix.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#hermconj">MCF_hermconj</a>,&nbsp;&nbsp; <a href="#mulMH">MCF_mulMH</a>,&nbsp;&nbsp; <a href="#TmulM">MF_TmulM</a>,&nbsp;&nbsp; <a href="#chap9">Kap.&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="inv"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_inv</b></font>
</td><td width="33%"><font size="+1"><b>MD_inv</b></font></td>
<td><font size="+1"><b>ME_inv</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_inv</b></font></td>
<td width="33%"><font size="+1"><b>MCD_inv</b></font></td>
<td><font size="+1"><b>MCE_inv</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>matrix inversion</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
int MF_inv( fMatrix MInv, fMatrix MA, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_inv( MInv, MA:fMatrix; len:UInt ):IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The inverse of the matrix MA is stored in MInv. If MA is non-invertible, the function fails with an error message and returns TRUE (1). Internally, inversion is accomplished <I>via</I> LU decomposition. In order to prevent the function from failing, you can define a minimum pivot for the decomposition, using <I><a href="#LUDsetEdit">MF_LUDsetEdit</a></I>. In that case, any matrix is made invertible, and <I>MF_inv</I> returns always FALSE (0). Only a call to <I><a href="#LUDresult">MF_LUDresult</a></I> will tell you if editing has actually been necessary to avoid a singularity. If such a result is still useful, shall depend on your specific application.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if no error occurred, otherwise TRUE (non-zero).</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap10">Kap.&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="LequU"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_LequU</b></font>
</td><td width="33%"><font size="+1"><b>MD_LequU</b></font></td>
<td><font size="+1"><b>ME_LequU</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_LequU</b></font></td>
<td width="33%"><font size="+1"><b>MCD_LequU</b></font></td>
<td><font size="+1"><b>MCE_LequU</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>copy upper-diagonal elements into lower-diagonal by index-reflection, so as to get a symmetric matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_LequU( fMatrix MA, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_LequU( MA:fMatrix; len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,j</sub> = MA<sub>j,i</sub>,&nbsp;&nbsp;i &gt; j</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#UequL">MF_UequL</a>,&nbsp;&nbsp; <a href="#chap3">Kap.&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="lincomb"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_lincomb</b></font>
</td><td width="33%"><font size="+1"><b>MD_lincomb</b></font></td>
<td><font size="+1"><b>ME_lincomb</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_lincomb</b></font></td>
<td width="33%"><font size="+1"><b>MCD_lincomb</b></font></td>
<td><font size="+1"><b>MCE_lincomb</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>linear combination of two matrices</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_lincomb( fMatrix MC, fMatrix MA, fMatrix MB, unsigned ht, unsigned len, float CA, float CB );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_lincomb( MC, MA, MB:fMatrix; ht, len:UInt; CA, CB:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MC = CA * MA + CB * MB</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_lincomb">MF_Rows_lincomb</a>,&nbsp;&nbsp; <a href="#chap9">Kap.&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="linfit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_linfit</b></font>
</td><td width="33%"><font size="+1"><b>VD_linfit</b></font></td>
<td><font size="+1"><b>VE_linfit</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_linfitwW</b></font></td>
<td width="33%"><font size="+1"><b>VD_linfitwW</b></font></td>
<td><font size="+1"><b>VE_linfitwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Data-fitting to models y=f(x) linear in the parameters</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void VF_linfit( fVector A, iVector AStatus, unsigned npars, fVector X, fVector Y, ui sizex,<BR>
void (*funcs)(fVector BasFuncs, float x, unsigned nfuncs));<P>
void VF_linfitwW( fVector A, fMatrix Covar, iVector AStatus, unsigned npars, fVector X, fVector Y, fVector InvVar, ui sizex,<BR>
void (*funcs)(fVector BasFuncs, float x, unsigned nfuncs));</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure VF_linfit( A:fVector; AStatus:iVector; npars:UInt; X, Y:fVector; sizex:UInt; funcs:Pointer );<P>
procedure VF_linfitwW( A:fVector; Covar:fMatrix; AStatus:iVector; npars:UInt; X, Y, InvVar:fVector; sizex:UInt; funcs:Pointer );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The input data X, Y (and InvVar) are used to evaluate the parameters <I>a<sub>i</sub></I> of a general linear function,<BR>
<font face="courier new"> y = a<sub>0</sub>f<sub>0</sub>(x) + a<sub>1</sub>f<sub>1</sub>(x) + a<sub>2</sub>f<sub>2</sub>(x)...</font><BR>
The parameters <I>a<sub>i</sub></I> are returned in the vector A. 
<P>Arguments:
<table border=0 width="100%">
<tr valign="top"><td>A</td><td>vector of size <I>npars</I>; returns the coefficients</td></tr>
<tr valign="top"><td>Covar</td><td>matrix of dimensions [npars, npars]; returns the covariances of the coefficients</td></tr>
<tr valign="top"><td>AStatus</td><td>vector of size <I>npars</I>; decides which parameters are treated as free or as fixed</td></tr>
<tr valign="top"><td>npars</td><td>total number of parameters</td></tr>
<tr valign="top"><td>X,&nbsp;Y,&nbsp;InvVar</td><td>vectors of size <I>sizex</I>, holding the input data</td></tr>
<tr valign="top"><td>funcs</td><td>user-defined model function</td></tr>
</table>&nbsp;<BR>
Your model function may actually contain more parameters than you wish to treat as adjustable. This is why you have to provide the vector <I>AStatus</I>, which contains the necessary information about which parameters are to be held fixed at their input values (AStatus[i] = 0) and which are free (AStatus[i] = 1). Any fixed parameters must be initialized in A prior to calling <I>VF_linfit</I>. <I>npars</I> denotes the total number of parameters in A (not only the free parameters!). 
<P>The model function <I>funcs</I>  must calculate the individual f<sub>i</sub>(x)  for any argument <I>x</I> and store the f<sub>i</sub>(x) in a vector <I>BasFuncs</I> of size <I>npars</I>. In C/C++, it has to be defined as<BR>
<font face="courier new">void MyFunc( fVector BasFuncs, float x, unsigned nfuncs)
<BR>{
<BR>&nbsp;&nbsp;BasFuncs[0] = f0( x );
<BR>&nbsp;&nbsp;BasFuncs[1] = f1( x);
<BR>&nbsp;&nbsp;. . .
<BR>}</font><BR>
and shall be passed to <I>VF_linfit</I> by calling<BR>
<font face="courier new">VF_linfit( A, AStatus, npars, X, Y, sizex, MyFunc );</font><BR>
In Pascal/Delphi, the model function has to be defined as<BR>
<font face="courier new">procedure MyFunc( BasFuncs:fVector; x:Single; nfuncs:UInt );
<BR>begin
<BR>&nbsp;&nbsp;VF_Pelement( BasFuncs, 0 )^ := f0( x );
<BR>&nbsp;&nbsp;VF_Pelement( BasFuncs, 1 )^ := f1( x );
<BR>&nbsp;&nbsp;. . .
<BR>end;</font><BR>
and shall be passed to <I>VF_linfit</I> by calling<BR>
<font face="courier new">VF_linfit( A, AStatus, npars, X, Y, sizex, @MyFunc );</font><BR>
Note the address-of operator in front of &quot;MyFunc.&quot;. In Turbo Pascal, the model function <B>must</B> be compiled with the Force-Far-Calls option {$F+}.
<P>The functions f0( x ) etc. <B>must not</B> contain the parameters <I>a<sub>i</sub></I>.
<BR>In the weighted variant, <I>VF_linfitwW</I>, the vector <I>InvVar</I> has to contain the inverse of the variances of the individual X-Y data points, and the matrix <I>Covar</I> will be filled with the covariances of the parameters <I>a<sub>i</sub></I> on output: MCovar<sub>i,j</sub> = covariance( <I>a<sub>i</sub></I>, <I>a<sub>j</sub></I> ).<P>Internally, <I>VF_linfit</I> employs a Singular Value Decomposition algorithm to obtain a solution even for (near-)singular linear systems. Thereby, coefficients <I>a<sub>i</sub></I> whose significance is lower than a threshold, <I>Thresh</I>, are
set to 0 instead of infinity. This threshold can be modified by calling <I><a href="#setLinfitNeglect">VF_setLinfitNeglect</a></I>. The current threshold can be retrieved by <I><a href="#getLinfitNeglect">VF_getLinfitNeglect</a></I>.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Mlinfit">MF_linfit</a>,&nbsp;&nbsp; <a href="#nonlinfit">VF_nonlinfit</a>,&nbsp;&nbsp; <a href="#chap13">Kap.&nbsp;13</a>,&nbsp;&nbsp;FITDEMO*.*</td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Mlinfit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_linfit</b></font>
</td><td width="33%"><font size="+1"><b>MD_linfit</b></font></td>
<td><font size="+1"><b>ME_linfit</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_linfitwW</b></font></td>
<td width="33%"><font size="+1"><b>MD_linfitwW</b></font></td>
<td><font size="+1"><b>ME_linfitwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Data-fitting to models z=f(x, y) linear in the parameters</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_linfit( fVector A, iVector AStatus, unsigned npars, fVector X, fVector Y, fMatrix MZ, unsigned htZ, unsigned lenZ,<BR>
void (*funcs)(fVector BasFuncs, float x, float y, unsigned nfuncs));<P>
void MF_linfitwW( fVector A, fMatrix Covar, iVector AStatus, unsigned npars, fVector X, fVector Y, fMatrix MZ, fMatrix MInvVar, unsigned htZ, unsigned lenZ,<BR>
void (*funcs)(fVector BasFuncs, float x, float y, unsigned nfuncs));</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_linfit( A:fVector; AStatus:iVector; npars:UInt; X, Y:fVector; MZ:fMatrix; htZ, lenZ:UInt; funcs:Pointer );<P>
procedure MF_linfitwW( A:fVector; Covar:fMatrix; AStatus:iVector; npars:UInt; X, Y:fVector; MZ, MInvVar:fMatrix; htZ, lenZ:UInt; funcs:Pointer );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The input data X, Y, MZ (and MInvVar) are used to evaluate the parameters <I>a<sub>i</sub></I> of a general linear function,<BR>
<font face="courier new"> z = a<sub>0</sub>f<sub>0</sub>(x, y) + a<sub>1</sub>f<sub>1</sub>(x, y) + a<sub>2</sub>f<sub>2</sub>(x, y)...</font><BR>
The parameters <I>a<sub>i</sub></I> are returned in the vector A. 
<P>Arguments:
<table border=0 width="100%">
<tr valign="top"><td>A</td><td>vector of size <I>npars</I>; returns the coefficients</td></tr>
<tr valign="top"><td>Covar</td><td>matrix of dimensions [npars, npars]; returns the covariances of the coefficients</td></tr>
<tr valign="top"><td>AStatus</td><td>vector of size <I>npars</I>; decides which parameters are treated as free or as fixed</td></tr>
<tr valign="top"><td>npars</td><td>total number of parameters</td></tr>
<tr valign="top"><td>X,&nbsp;Y</td><td>vectors of size <I>lenZ</I> and <I>htZ</I>, respectively, spanning the x-y coordinate system of the matrix MZ</td></tr>
<tr valign="top"><td>MZ,&nbsp;MInvVar</td><td>matrices of dimensions [htZ, lenZ], holding the input data and, in the weighted variant, the inverse of their variances</td></tr>
<tr valign="top"><td>funcs</td><td>user-defined model function</td></tr>
</table>&nbsp;<BR>
Your model function may actually contain more parameters than you wish to treat as adjustable. This is why you have to provide the vector <I>AStatus</I>, which contains the necessary information about which parameters are to be held fixed at their input values (AStatus[i] = 0) and which are free (AStatus[i] = 1). Any fixed parameters must be initialized in A prior to calling <I>MF_linfit</I>. <I>npars</I> denotes the total number of parameters in A (not only the free parameters!). 
<P>You must provide a model function &quot;funcs&quot; which, for any pair of arguments <I>x, y</I>, must calculate the individual f<sub>i</sub>(x, y) and store them in a vector <I>BasFuncs</I> of size <I>npars</I>. In C/C++, it has to be defined as<BR>
<font face="courier new">void MyFunc( fVector BasFuncs, float x, float y, unsigned nfuncs);
<BR>{
<BR>&nbsp;&nbsp;BasFuncs[0] = f0( x, y );
<BR>&nbsp;&nbsp;BasFuncs[1] = f1( x, y);
<BR>&nbsp;&nbsp;. . .
<BR>}</font><BR>
and shall be passed to <I>MF_linfit</I> by calling<BR>
<font face="courier new">MF_linfit( A, AStatus, npars, X, Y, MZ, htZ, lenZ, MyFunc );</font><BR>
In Pascal/Delphi, the model function has to be defined as<BR>
<font face="courier new">procedure MyFunc( BasFuncs:fVector; x, y:Single; nfuncs:UInt );
<BR>begin
<BR>&nbsp;&nbsp;VF_Pelement( BasFuncs, 0 )^ := f0( x, y );
<BR>&nbsp;&nbsp;VF_Pelement( BasFuncs, 1 )^ := f1( x, y );
<BR>&nbsp;&nbsp;. . .
<BR>end;</font><BR>
and shall be passed to <I>MF_linfit</I> by calling<BR>
<font face="courier new">MF_linfit( A, AStatus, npars, X, Y, MZ, htZ, lenZ, @MyFunc );</font><BR>
Note the address-of operator in front of &quot;MyFunc.&quot;. In Turbo Pascal, the model function <B>must</B> be compiled with the Force-Far-Calls option {$F+}.
<P>The functions f0( x, y ) etc. <B>must not</B> contain the parameters <I>a<sub>i</sub></I>.
<BR>In the weighted variant, <I>MF_linfitwW</I>, the matirx <I>MInvVar</I> has to contain the inverse of the variances of the individual X-Y-Z data points, and the matrix <I>MCovar</I> will be filled with the covariances of the parameters <I>a<sub>i</sub></I> on output: MCovar<sub>i,j</sub> = covariance( <I>a<sub>i</sub></I>, <I>a<sub>j</sub></I> ).
<P>Internally, <I>MF_linfit</I> employs a Singular Value Decomposition algorithm to obtain a solution even for (near-)singular linear systems. Thereby, coefficients <I>a<sub>i</sub></I> whose significance is lower than a threshold, <I>Thresh</I>, are
set to 0 instead of infinity. This threshold can be modified by calling <I><a href="#setLinfitNeglect">VF_setLinfitNeglect</a></I>. The current threshold can be retrieved by <I><a href="#getLinfitNeglect">VF_getLinfitNeglect</a></I>.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#linfit">VF_linfit</a>,&nbsp;&nbsp; <a href="#Mnonlinfit">MF_nonlinfit</a>,&nbsp;&nbsp; <a href="#chap13">Kap.&nbsp;13</a>,&nbsp;&nbsp;FITDEMO*.*</td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="LUdecompose"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_LUdecompose</b></font>
</td><td width="33%"><font size="+1"><b>MD_LUdecompose</b></font></td>
<td><font size="+1"><b>ME_LUdecompose</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_LUdecompose</b></font></td>
<td width="33%"><font size="+1"><b>MCD_LUdecompose</b></font></td>
<td><font size="+1"><b>MCE_LUdecompose</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>LU decomposition</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
int MF_LUdecompose( fMatrix MLU, uiVector Ind, fMatrix MA, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_LUdecompose( MLU:fMatrix; Ind:uVector; MA:fMatrix; len:UInt ):Integer;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA is decomposed into a product MA = L * U, where L is lower-triangular with the diagonal elements equal to 1, and U is upper-triangular. As the combined number of non-trivial elements of L and U just fit into a matrix of the same dimensions as MA, the result is stored in a single matrix MLU rather than in to distinct matrices L and U. Actually, it is not the &quot;true&quot; matrices L and U which are combined into MLU, but rather a row-wise permutation, whose indices are output in the vector <I>Ind</I>. The return value indicates if the number of permuations was even (+1) or uneven (-1).
<P>MA may or may not be overwritten by MLU. To check if <I>MF_LUdecompose</I> was successful, call <I><a href="#LUDresult">MF_LUDresult</a></I>, whose return value will be FALSE (0), if the MA could be decomposed, and TRUE (1) for singular MA.
<P>There are applications where it makes sense to make near-singular matrices decomposable by &quot;pivot editing&quot;: If, in the partial pivoting process employed in the decomposition and inversion, no diagonal element larger than the threshold is available, the scaling of the matrix is done with the threshold value rather than with the tiny diagonal element. That way, divisions by (near-)zero are avoided. This pivot editing can be chosen through a call to <I><a href="#LUDsetEdit">MF_LUDsetEdit</a></I>. By default, pivot editing is switched off.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>In the case of a singular matrix, MLU will be undefined, and an internal flag is set, but no error message is generated. To check if an error occurred, you must call <I><a href="#LUDresult">MF_LUDresult</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>+1 or -1, indicating even or uneven number of row permutations</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap10">Kap.&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="LUdet"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_LUdet</b></font>
</td><td width="33%"><font size="+1"><b>MD_LUdet</b></font></td>
<td><font size="+1"><b>ME_LUdet</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_LUdet</b></font></td>
<td width="33%"><font size="+1"><b>MCD_LUdet</b></font></td>
<td><font size="+1"><b>MCE_LUdet</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>determinant of an LU decomposed matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float MF_LUdet( fMatrix MLU, unsigned len, int permut );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_LUdet( MLU:fMatrix; len:UInt; permut:Integer ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><I>MF_LUdet</I> calculates the determinant of matrix already decomposed into LU form, and return it as a scalar. The argument <I>permut</I> must be +1 or -1, as given by the return value of <I><a href="#LUdecompose">MF_LUdecompose</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>determinant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#det">MF_det</a>,&nbsp;&nbsp; <a href="#chap10">Kap.&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="LUDgetEdit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_LUDgetEdit</b></font>
</td><td width="33%"><font size="+1"><b>MD_LUDgetEdit</b></font></td>
<td><font size="+1"><b>ME_LUDgetEdit</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_LUDgetEdit</b></font></td>
<td width="33%"><font size="+1"><b>MCD_LUDgetEdit</b></font></td>
<td><font size="+1"><b>MCE_LUDgetEdit</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>retrieve pivot-editing threshold for LU decomposition</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float MF_LUDgetEdit( void );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_LUDgetEdit: Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>retrieve the current pivot-editing threshold for <I><a href="#LUdecompose">MF_LUdecompose</a></I>, &nbsp;&nbsp;<I><a href="#inv">MF_inv</a></I>, and <I><a href="#solve">MF_solve</a></I>. It can be modified using <I><a href="#LUDsetEdit">MF_LUDsetEdit</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap10">Kap.&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="LUDresult"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_LUDresult</b></font>
</td><td width="33%"><font size="+1"><b>MD_LUDresult</b></font></td>
<td><font size="+1"><b>ME_LUDresult</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_LUDresult</b></font></td>
<td width="33%"><font size="+1"><b>MCD_LUDresult</b></font></td>
<td><font size="+1"><b>MCE_LUDresult</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>check if the last operation utilizing LU decomposition worked error-free</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
int MF_LUDresult( void );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_LUDresult: IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>After a call to <I><a href="#LUdecompose">MF_LUdecompose</a></I> or any of the functions internally relying on LU decomposition (like <I><a href="inv">MF_inv</a></I>,&nbsp;&nbsp; <I><a href="#solve">MF_solve</a></I>), the result should be checked by <I>MF_LUDresult</I>. If LU decomposition was successful, <I>MF_LUDresult</I> returns FALSE (0); if MA was (nearly) singular, TRUE (1) is returned.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>see above</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap10">Kap.&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="LUDsetEdit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_LUDsetEdit</b></font>
</td><td width="33%"><font size="+1"><b>MD_LUDsetEdit</b></font></td>
<td><font size="+1"><b>ME_LUDsetEdit</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_LUDsetEdit</b></font></td>
<td width="33%"><font size="+1"><b>MCD_LUDsetEdit</b></font></td>
<td><font size="+1"><b>MCE_LUDsetEdit</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>set pivot-editing threshold for LU decomposition</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_LUDsetEdit( float Thresh );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_LUDsetEdit( Thresh:Single ); </font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>set the pivot-editing threshold for <I><a href="#LUdecompose">MF_LUdecompose</a></I>, &nbsp;&nbsp;<I><a href="#inv">MF_inv</a></I>, and <I><a href="#solve">MF_solve</a></I>. To read the current threshold, use <I><a href="#LUDgetEdit">MF_LUDgetEdit</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap10">Kap.&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="LUimprove"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_LUimprove</b></font>
</td><td width="33%"><font size="+1"><b>MD_LUimprove</b></font></td>
<td><font size="+1"><b>ME_LUimprove</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_LUimprove</b></font></td>
<td width="33%"><font size="+1"><b>MCD_LUimprove</b></font></td>
<td><font size="+1"><b>MCE_LUimprove</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>iterative improvement of the solution of a linear system solved by LU decomposition</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_LUimprove( fVector X, fVector B, fMatrix MA, fMatrix MLU, uiVector Ind, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_LUimprove( X, B:fVector; MA, MLU:fMatrix; Ind:uVector; len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Especially for large matrices, accumulated round-off error in LU decomposition may become quite noticable. This round-off error will translate into inaccurate results of <I><a href="#LUsolve">MF_LUsolve</a></I>. If the input matrix was not overwritten by the out put matrix in the initial call to <I><a href="#LUdecompose">MF_LUdecompose</a></I>, you may call <I>MF_LUimprove</I> after <I>MF_LUsolve</I> to improve the accuracy by iteration. <I>MF_LUimprove</I> needs the output vector X of <I>MF_LUsolve</I>, the right-hand-side vector <I>B</I> of the linear system, and both the original matrix MA and its raw LU-decomposed form MLU along with its permutation indices, <I>Ind</I>, as arguments.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap10">Kap.&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="LUinv"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_LUinv</b></font>
</td><td width="33%"><font size="+1"><b>MD_LUinv</b></font></td>
<td><font size="+1"><b>ME_LUinv</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_LUinv</b></font></td>
<td width="33%"><font size="+1"><b>MCD_LUinv</b></font></td>
<td><font size="+1"><b>MCE_LUinv</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>invert a matrix already decomposed into LU form</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_LUinv( fMatrix MInv, fMatrix MLU, uiVector Ind, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_LUinv( MInv, MLU:fMatrix; Ind:uVector; len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><I>MF_LUinv</I> inverts a matrix already decomposed into LU form. Along with the matrix MLU, its permutation indices are needed in the vector <I>Ind</I> as output by <I><a href="#LUdecompose">MF_LUdecompose</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap10">Kap.&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="LUsolve"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_LUsolve</b></font>
</td><td width="33%"><font size="+1"><b>MD_LUsolve</b></font></td>
<td><font size="+1"><b>ME_LUsolve</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_LUsolve</b></font></td>
<td width="33%"><font size="+1"><b>MCD_LUsolve</b></font></td>
<td><font size="+1"><b>MCE_LUsolve</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>solve a linear system MA * X = B, where MA has already been decomposed into LU form</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_LUsolve( fVector X, fMatrix MLU, fVector B, uiVector Ind, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_LUsolve( X:fVector; MLU:fMatrix; B:fVector; Ind:uVector;
len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The linear system MA * X = B is solved for the vector X. Instead of MA itself, this function expects the LU decomposed form of MA as the input matrix MLU, along with its row-permutation indices in the vector <I>Ind</I> as output by <I><a href="#LUdecompose">MF_LUdecompose</a></I>. 
<BR>If the original matrix MA is still available, it is recommended to &quot;fine-polish&quot; the result by calling <I><a href="#LUimprove">MF_LUimprove</a></I>. In comparison to the LU decomposition and back-substitution already performed, this iterative improvement takes very little time, but it can lead to an appreaciable improvement of the solution and often even save solutions which otherwise would be ruined by round-off error.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="">Kap.&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="matrix"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_matrix</b></font>
</td><td width="33%"><font size="+1"><b>MD_matrix</b></font></td>
<td><font size="+1"><b>ME_matrix</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_matrix</b></font></td>
<td width="33%"><font size="+1"><b>MCD_matrix</b></font></td>
<td><font size="+1"><b>MCE_matrix</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Memory allocation for a matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
fMatrix MF_matrix( unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_matrix( ht, len:UInt ): fMatrix;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Based on memory model and environment, the most appropriate allocation procedure is chosen by these functions. Failure to allocate memory always leads to an error message and a subsequent program abort (similar to the error handling of the &quot;new&quot; operator). To release the memory thus allocated, <I><a href="#free">M_free</a></I>,&nbsp;&nbsp;<I><a href="#nfree">M_nfree</a></I>, or <I><a href="FUNCREF.HTM#freeAll">V_freeAll</a></I> should be used (<I>M_nfree</I> only in C/C++).
<BR>Note: the declaration of a matrix (e.g., as fMatrix) reserves only a name, but no memory!
<BR>See <a href="HANDBOOK.HTM#chap4_1">Kap.&nbsp;4.1</a> if you are interested in details of the implementation.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If there is not enough memory available, or if size is zero, an error message &quot;Not enough memory&quot; is displayed and the program aborted.
<BR>16-bit models:
<BR>If more than 64 kB of memory are requested, an error message &quot;Vector &gt; 64 kB not possible&quot; is displayed and the program aborted (except in the model HUGE). If any of the two matrix dimensions exceeds the 64 kB limit, an error message &quot;Invalid matrix dimension(s)&quot; is displayed and the program aborted, even in the model HUGE.
<BR>32-bit:
<BR>If more than 4 GB of memory are requested, an error message &quot;Vector &gt; 4 GB not possible&quot; is displayed and the program aborted. If already a single matrix dimensions exceeds this limit, an error message &quot;Invalid matrix dimension(s)&quot; is displayed and the program aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td><U>C/C++:</U> Pointer to the array of row pointers
<BR><U>Pascal/Delphi:</U> Pointer to the allocated memory</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#matrix0">MF_matrix0</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#vector">VF_vector</a>,&nbsp;&nbsp; <a href="#chap2">Kap.&nbsp;2</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="matrix0"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_matrix0</b></font>
</td><td width="33%"><font size="+1"><b>MD_matrix0</b></font></td>
<td><font size="+1"><b>ME_matrix0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_matrix0</b></font></td>
<td width="33%"><font size="+1"><b>MCD_matrix0</b></font></td>
<td><font size="+1"><b>MCE_matrix0</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>allocate memory for a matrix and initialize all elements with 0</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
fMatrix MF_matrix0( unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_matrix0( ht, len:UInt ): fMatrix;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The functions of this family are almost identical to those of the <I><a href="#matrix">MF_matrix</a></I> family; in addition to allocating memory, they initialize all elements with 0. (Calls to <I>MF_matrix</I> and <I>MF_matrix0</I> may be mixed; they and the vector allocation functions, <I><a href="FUNCREF.HTM#vector">VF_vector</a></I> etc. use the same tables to keep track of the handles and pointers). For further information, see <I><a href="#matrix">MF_matrix</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If there is not enough memory available, or if size is zero, an error message &quot;Not enough memory&quot; is displayed and the program aborted.
<BR>16-bit models:
<BR>If more than 64 kB of memory are requested, an error message &quot;Vector &gt; 64 kB not possible&quot; is displayed and the program aborted (except in the model HUGE). If any of the two matrix dimensions exceeds the 64 kB limit, an error message &quot;Invalid matrix dimension(s)&quot; is displayed and the program aborted, even in the model HUGE.
<BR>32-bit:
<BR>If more than 4 GB of memory are requested, an error message &quot;Vector &gt; 4 GB not possible&quot; is displayed and the program aborted. If already a single matrix dimensions exceeds this limit, an error message &quot;Invalid matrix dimension(s)&quot; is displayed and the program aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td><U>C/C++:</U> Pointer to the array of row pointers
<BR><U>Pascal/Delphi:</U> Pointer to the allocated memory</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#matrix">MF_matrix</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#vector0">VF_vector0</a>,&nbsp;&nbsp; <a href="#chap2">Kap.&nbsp;2</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="MatrixTo2DArray"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_MatrixTo2DArray</b></font>
</td><td width="33%"><font size="+1"><b>MD_MatrixTo2DArray</b></font></td>
<td><font size="+1"><b>ME_MatrixTo2DArray</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_MatrixTo2DArray</b></font></td>
<td width="33%"><font size="+1"><b>MCD_MatrixTo2DArray</b></font></td>
<td><font size="+1"><b>MCE_MatrixTo2DArray</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>convert <I>OptiVec</I> matrix into 2D-array of Delphi 4 or higher</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td>N.A.</td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses VecLib, MFstd;<BR>
type  fArray  = array of Single;<BR>
type  f2DArray  = array of fArray;<BR>
procedure    MF_MatrixTo2DArray( DelphiArr:f2DArray; MF:fMatrix; ht,len:UInt);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function is necessary only for Delphi 4 or higher. (Previous versions of Borland Pascal/Delphi did not support dynamically allocated matrices.) It converts <I>OptiVec</I> matrices into two-dimensional Delphi arrays. Note that, unlike static Pascal/Delphi matrices, the dynamic matrices of Delphi 4+ cannot directly be passed to <I>OptiVec</I> functions, but have to be converted first by calling <I><a href="#2DArrayToMatrix">MF_2DArrayToMatrix</a></I>. If you ever need an <I>OptiVec</I> matrix back into Delphi format, this is done by the present function.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#2DArrayToMatrix">MF_2DArrayToMatrix</a>,&nbsp;&nbsp; <a href="#chap1_4">Kap.&nbsp;1.4</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="mulC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_mulC</b></font>
</td><td width="33%"><font size="+1"><b>MD_mulC</b></font></td>
<td><font size="+1"><b>ME_mulC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_mulC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_mulC</b></font></td>
<td><font size="+1"><b>MCE_mulC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_mulReC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_mulReC</b></font></td>
<td><font size="+1"><b>MCE_mulReC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply all matrix element by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_mulC( fMatrix MB, fMatrix MA, unsigned ht, unsigned len, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_mulC( MB, MA:fMatrix; ht, len:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MB<sub>ij</sub> = MA<sub>ij</sub> + C</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#mulV">MF_mulV</a>,&nbsp;&nbsp; <a href="#mulM">MF_mulM</a>,&nbsp;&nbsp; <a href="#chap9">Kap.&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="VmulM"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_mulM</b></font>
</td><td width="33%"><font size="+1"><b>VD_mulM</b></font></td>
<td><font size="+1"><b>VE_mulM</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply a row vector by a matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void VF_mulM( fVector Y, fVector X, fMatrix MA, unsigned htA, unsigned lenA );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure VF_mulM( Y, X:fVector; MA:fMatrix; htA, lenA:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y = X * MA;
<BR>the dimensions of X and Y are implicitly given by the matrix dimensions: sizX = htA, sizY = lenA.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#mulV">MF_mulV</a>,&nbsp;&nbsp; <a href="#mulM">MF_mulM</a>,&nbsp;&nbsp; <a href="#chap9">Kap.&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="mulM"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_mulM</b></font>
</td><td width="33%"><font size="+1"><b>MD_mulM</b></font></td>
<td><font size="+1"><b>ME_mulM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_mulM</b></font></td>
<td width="33%"><font size="+1"><b>MCD_mulM</b></font></td>
<td><font size="+1"><b>MCE_mulM</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>matrix multiplication</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_mulM( fMatrix MC, fMatrix MA, fMatrix MB, unsigned htA, unsigned lenA, unsigned lenB );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_mulM( MC, MA, MB:fMatrix; htA, lenA, lenB:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MC = MA * MB
<BR>htA, lenA, and lenB must be specified; the other dimensions are implicitly given as: htB = lenA, lenC = lenB, htC = htA.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#mulMT">MF_mulMT</a>,&nbsp;&nbsp; <a href="#TmulM">MF_TmulM</a>,&nbsp;&nbsp; <a href="#VmulM">VF_mulM</a>,&nbsp;&nbsp; <a href="#chap9">Kap.&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="dia_mulM"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MFdia_mulM</b></font>
</td><td width="33%"><font size="+1"><b>MDdia_mulM</b></font></td>
<td><font size="+1"><b>MEdia_mulM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCFdia_mulM</b></font></td>
<td width="33%"><font size="+1"><b>MCDdia_mulM</b></font></td>
<td><font size="+1"><b>MCEdia_mulM</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiplication of a diagonal matrix and a general matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MFdia_mulM( fMatrix MC, fVector MADia, fMatrix MB, unsigned lenA, unsigned lenB );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MFdia_mulM( MC:fMatrix; MADia: fVector; MB:fMatrix; lenA, lenB:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MC = MADia * MB
<BR>The vector MAdia represents the diagonal matrix MA. (A matrix is called diagonal, it it has non-zero elements only on the diagonal). lenA, and lenB must be specified; htB is equal to lenA.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#dia_mulMT">MFdia_mulMT</a>,&nbsp;&nbsp; <a href="#chap9">Kap.&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="mulMdia"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_mulMdia</b></font>
</td><td width="33%"><font size="+1"><b>MD_mulMdia</b></font></td>
<td><font size="+1"><b>ME_mulMdia</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_mulMdia</b></font></td>
<td width="33%"><font size="+1"><b>MCD_mulMdia</b></font></td>
<td><font size="+1"><b>MCE_mulMdia</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply a general matrix by a diagonal matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_mulMdia( fMatrix MC, fMatrix MA, fVector MBDia, unsigned htA, unsigned lenA );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_mulMdia( MC, MA:fMatrix; MBDia:fVector; htA, lenA:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MC = MA * MBDia.
<BR>htA and lenA must be specified; sizB = lenA.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#dia_mulM">MFdia_mulM</a>,&nbsp;&nbsp; <a href="#TmulMdia">MF_TmulMdia</a>,&nbsp;&nbsp; <a href="#chap9">Kap.&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="mulMH"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_mulMH</b></font></td>
<td width="33%"><font size="+1"><b>MCD_mulMH</b></font></td>
<td><font size="+1"><b>MCE_mulMH</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply one complex matrix by the hermitian conjugate of another</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MCFstd.h&gt;<BR>
void MCF_mulMH( cfMatrix MC, cfMatrix MA, cfMatrix MB, unsigned htA, unsigned lenA, unsigned htB );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MCFstd;<BR>
procedure MCF_mulMH( MC, MA, MB:cfMatrix; htA, lenA, htB:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MC = MA * MB<sup>T *</sup>.
<BR>htA, lenA, and htB must be specified; the other dimensions are implicitly given as: lenB = lenA, lenC = htB, htC = htA.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#hermconj">MCF_hermconj</a>,&nbsp;&nbsp; <td><a href="#mulMT">MF_mulMT</a>,&nbsp;&nbsp; <a href="#HmulM">MCF_HmulM</a>,&nbsp;&nbsp; <a href="#chap9">Kap.&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="mulMT"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_mulMT</b></font>
</td><td width="33%"><font size="+1"><b>MD_mulMT</b></font></td>
<td><font size="+1"><b>ME_mulMT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_mulMT</b></font></td>
<td width="33%"><font size="+1"><b>MCD_mulMT</b></font></td>
<td><font size="+1"><b>MCE_mulMT</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply one matrix by the transpose of another</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_mulMT( fMatrix MC, fMatrix MA, fMatrix MB, unsigned htA, unsigned lenA, unsigned htB );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_mulMT( MC, MA, MB:fMatrix; htA, lenA, htB:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MC = MA * MB<sup>T</sup>.
<BR>htA, lenA, and htB must be specified; the other dimensions are implicitly given as: lenB = lenA, lenC = htB, htC = htA.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#mulM">MF_mulM</a>,&nbsp;&nbsp; <a href="#TmulM">MF_TmulM</a>,&nbsp;&nbsp; <a href="#VmulMT">VF_mulMT</a>,&nbsp;&nbsp; <a href="#chap9">Kap.&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="dia_mulMT"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MFdia_mulMT</b></font>
</td><td width="33%"><font size="+1"><b>MDdia_mulMT</b></font></td>
<td><font size="+1"><b>MEdia_mulMT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCFdia_mulMT</b></font></td>
<td width="33%"><font size="+1"><b>MCDdia_mulMT</b></font></td>
<td><font size="+1"><b>MCEdia_mulMT</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply a diagonal matrix by the transpose of a general matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MFdia_mulMT( fMatrix MC, fVector MADia, fMatrix MB, unsigned htB, unsigned lenB );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MFdia_mulMT( MC:fMatrix; MADia: fVector; MB:fMatrix; htB, lenB:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MC = MADia * MB<sup>T</sup>
<BR>htB and lenB must be specified; sizA equals lenB.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#dia_mulM">MFdia_mulM</a>,&nbsp;&nbsp; <a href="#chap9">Kap.&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="VmulMT"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_mulMT</b></font>
</td><td width="33%"><font size="+1"><b>VD_mulMT</b></font></td>
<td><font size="+1"><b>VE_mulMT</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply a row vector by the transpose of a matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void VF_mulMT( fVector Y, fVector X, fMatrix MA, unsigned htA, unsigned lenA );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure VF_mulMT( Y, X:fVector; MA:fMatrix; htA, lenA:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y = X * MA<sup>T</sup>
<BR>The dimensions htA and lenA refer to the original (rather than the intermediate transposed) matrix MA; the dimensions of X and Y are implicitly given by the matrix dimensions: sizX = lenA, sizY = htA.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#VmulM">VF_mulM</a>,&nbsp;&nbsp; <a href="#mulV">MF_mulV</a>,&nbsp;&nbsp; <a href="#chap9">Kap.&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="multiLinfit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_multiLinfit</b></font>
</td><td width="33%"><font size="+1"><b>VD_multiLinfit</b></font></td>
<td><font size="+1"><b>VE_multiLinfit</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_multiLinfitwW</b></font></td>
<td width="33%"><font size="+1"><b>VD_multiLinfitwW</b></font></td>
<td><font size="+1"><b>VE_multiLinfitwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>fit multiple X-Y data sets to a common model function, linear in its parameters</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void VF_multiLinfit( fVector A, iVector AStatus, unsigned npars, VF_EXPERIMENT *ListOfExperiments, unsigned nexperiments,<BR>
void (*funcs)(fVector BasFuncs, float x,unsigned nfuncs, unsigned iexperiment) );<P>
void VF_multiLinfitwW( fVector A, fMatrix Covar, iVector AStatus, unsigned npars, VF_EXPERIMENT *ListOfExperiments, unsigned nexperiments,<BR>
void (*funcs)(fVector BasFuncs, float x, unsigned nfuncs, unsigned iexperiment) );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure VF_multiLinfit( A:fVector; AStatus:iVector; nParameters:UInt; ListOfExperiments: PVF_EXPERIMENT; nexperiments:UInt; funcs: Pointer );<P>
procedure VF_multiLinfitwW( A:fVector; Covar:fMatrix; AStatus:iVector; nParameters:UInt; ListOfExperiments:PVF_EXPERIMENT; nexperiments:UInt; funcs:Pointer );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The input data, contained in <I>ListOfExperiments</I>, are used to evaluate the parameters <I>a<sub>i</sub></I> of a general linear function,<BR>
<font face="courier new"> y = a<sub>0</sub>f<sub>0</sub>(x) + a<sub>1</sub>f<sub>1</sub>(x) + a<sub>2</sub>f<sub>2</sub>(x)...</font><BR>
The parameters <I>a<sub>i</sub></I> are returned in the vector A. 
<P>Arguments:
<table border=0 width="100%">
<tr valign="top"><td>A</td><td>vector of size <I>npars</I>; returns the coefficients</td></tr>
<tr valign="top"><td>Covar</td><td>matrix of dimensions [npars, npars]; returns the covariances of the coefficients</td></tr>
<tr valign="top"><td>AStatus</td><td>vector of size <I>npars</I>; decides which parameters are treated as free or as fixed</td></tr>
<tr valign="top"><td>npars</td><td>total number of parameters</td></tr>
<tr valign="top"><td>ListOfExperiments</td><td>input data, see <I><a href="#chap13_4EXPERIMENT">chap. 13.4</a></I></td></tr>
<tr valign="top"><td>nexperiments</td><td>number of data sets in <I>ListOfExperiments</I></td></tr>
<tr valign="top"><td>funcs</td><td>user-defined model function</td></tr>
</table>&nbsp;<BR>Your model function may actually contain more parameters than you wish to treat as adjustable. This is why you have to provide an additional vector, AStatus, which contains the necessary information about which parameters are to be held fixed at their input values (AStatus[i] = 0) and which are free (AStatus[i] = 1). Any fixed parameters must be initialized in A prior to calling <I>VF_multiLinfit</I>. The argument <I>npars</I> denotes the total number of parameters in A (not only the free parameters!). 
<P>The input data must be combined into sets of the type <I><a href="#chap13_4EXPERIMENT">VF_EXPERIMENT</a></I>. Assuming you have two sets of X-Y data, contained in the vectors X1, Y1 (and, for <I>VF_multiLinfitwW</I>, InvVar1) of size1 elements, and X2, Y2 (and InvVar2) of size2 elements, you have to construct a list of experiments as in the following example:
</td></tr><tr valign="top"><td>Constructing list of experiments in C/C++</td><td>
<font face="courier new">VF_EXPERIMENT ExpList[2];
<BR>ExpList[0].X = X1;&nbsp;&nbsp;ExpList[0].Y = Y1;&nbsp;&nbsp;ExpList[0].size = size1;
<BR>ExpList[1].X = X2;&nbsp;&nbsp;ExpList[1].Y = Y2;&nbsp;&nbsp;ExpList[1].size = size2;
<BR>/* for the weighted variant, set additionally: */
<BR>ExpList[0].InvVar = InvVar1;&nbsp;&nbsp;ExpList[0].WeightOfExperiment = wt1;
<BR>ExpList[1].InvVar = InvVar2;&nbsp;&nbsp;ExpList[1].WeightOfExperiment = wt2;
<BR>&nbsp;</font>
</td></tr><tr valign="top"><td>Constructing list of experiments in Pascal/Delphi</td><td>
<font face="courier new"><B>var</B> ExpList: array[0..1] of VF_EXPERIMENT;
<BR>begin
<BR>&nbsp;&nbsp;...
<BR>&nbsp;&nbsp;ExpList[0].X := X1;&nbsp;&nbsp;ExpList[0].Y := Y1;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[0].size := size1;
<BR>&nbsp;&nbsp;ExpList[1].X := X2;&nbsp;&nbsp;ExpList[1].Y := Y2;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[1].size := size2;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(* for the weighted variant, set additionally: *)
<BR>&nbsp;&nbsp;ExpList[0].InvVar := InvVar1;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[0].WeightOfExperiment := wt1;
<BR>&nbsp;&nbsp;ExpList[1].InvVar := InvVar2;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[1].WeightOfExperiment := wt2;
<BR>&nbsp;&nbsp;... 
<BR>end;</font>
<P>&nbsp;
</td></tr><tr valign="top"><td>Both C/C++ and Pascal/Delphi</td><td>
You must provide a model function &quot;funcs&quot; which, for any argument <I>x</I>, must calculate the individual basis functions f<sub>i</sub>(x) and store them in a vector <I>BasFuncs</I>. The model function has to be defined as<BR>&nbsp;
</td></tr><tr valign="top"><td>Model function for C/C++</td><td>
<font face="courier new">void MyFunc( fVector BasFuncs, float x, unsigned nfuncs, unsigned iexperiment )
<BR>{
<BR>&nbsp;&nbsp;BasFuncs[0] = f0( x );
<BR>&nbsp;&nbsp;BasFuncs[1] = f1( x);
<BR>&nbsp;&nbsp;...
<BR>}</font><BR>
and shall be passed to <I>VF_multiLinfit</I> by calling<BR>
<font face="courier new">VF_multiLinfit( A, AStatus, npars, ExpList, 2, MyFunc );</font><BR>&nbsp;
</td></tr><tr valign="top"><td>Model function for Pascal/Delphi</td><td>
<font face="courier new">procedure MyFunc( BasFuncs:fVector; x:Single; nfuncs, iexperiment:UInt );
<BR>begin
<BR>&nbsp;&nbsp;VF_Pelement( BasFuncs, 0 )^ := f0( x );
<BR>&nbsp;&nbsp;VF_Pelement( BasFuncs, 1 )^ := f1( x );
<BR>&nbsp;&nbsp;...
<BR>end;</font><BR>
This model function shall be passed to <I>VF_multiLinfit</I> by calling<BR>
<font face="courier new">VF_multiLinfit( A, AStatus, npars, @ExpList, 2, @MyFunc );</font><BR>
Note the address-of operators in front of &quot;ExpList&quot; (static Pascal array passed to <I>OptiVec</I> function) and &quot;MyFunc.&quot; (pointer to the function MyFunc). In Turbo Pascal, the model function <B>must</B> be compiled with the Force-Far-Calls option {$F+}.
</td></tr><tr valign="top"><td>Both C/C++ and Pascal/Delphi</td><td>
<P>The argument <I>iexperiment</I> with which <I>MyFunc</I> shall be called by <I>VF_multiLinfit</I> allows to distinguish between parameters that are common to all experiments and others that belong to individual experiments. For example, each experiment's Y values might be shifted by a constant C. In this case, <I>A</I> has to contain as many shifts C as there are experiments. In MyFunc, you would have to code this as (in C/C++; you will easily translate this into Pascal/Delphi):
<BR><font face="courier new">&nbsp;&nbsp;if( iexperiment == 0 ) { BasFuncs[2] = 1; BasFuncs[3] = 0; }
<BR>&nbsp;&nbsp;else {BasFuncs[2] = 0; BasFuncs[3] = 1; }</font>
<P>The functions f0( x ) etc. <B>must not</B> contain the parameters <I>a<sub>i</sub></I>. In the weighted variant, the matrix <I>MCovar</I> will be filled with the covariances of the parameters <I>a<sub>i</sub></I> on output: MCovar<sub>i,j</sub> = covariance( <I>a<sub>i</sub></I>, <I>a<sub>j</sub></I> ).<P>Internally, <I>VF_multiLinfit</I> employs a Singular Value Decomposition algorithm to obtain a solution even for (near-)singular linear systems. Thereby, coefficients <I>a<sub>i</sub></I> whose significance is lower than a threshold, <I>Thresh</I>, are set to 0 instead of infinity. This threshold can be modified by calling <I><a href="#setLinfitNeglect">VF_setLinfitNeglect</a></I>. The current threshold can be retrieved by <I><a href="#getLinfitNeglect">VF_getLinfitNeglect</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Mlinfit">MF_linfit</a>,&nbsp;&nbsp; <a href="#nonlinfit">VF_nonlinfit</a>,&nbsp;&nbsp; <a href="#chap13">Kap.&nbsp;13</a>,&nbsp;&nbsp;FITDEMO*.*</td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="MmultiLinfit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_multiLinfit</b></font>
</td><td width="33%"><font size="+1"><b>MD_multiLinfit</b></font></td>
<td><font size="+1"><b>ME_multiLinfit</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_multiLinfitwW</b></font></td>
<td width="33%"><font size="+1"><b>MD_multiLinfitwW</b></font></td>
<td><font size="+1"><b>ME_multiLinfitwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>fit multiple X-Y-Z data sets to a common model function, linear in its parameters</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_multiLinfit( fVector A, iVector AStatus, unsigned npars, MF_EXPERIMENT *ListOfExperiments, unsigned nexperiments,<BR>
void (*funcs)(fVector BasFuncs, float x, float y, unsigned nfuncs, unsigned iexperiment) );<P>
void MF_multiLinfitwW( fVector A, fMatrix Covar, iVector AStatus, unsigned npars, MF_EXPERIMENT *ListOfExperiments, unsigned nexperiments,<BR>
void (*funcs)(fVector BasFuncs, float x, float y, unsigned nfuncs, unsigned iexperiment) );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_multiLinfit( A:fVector; AStatus:iVector; nParameters:UInt; ListOfExperiments: PMF_EXPERIMENT; nexperiments:UInt; funcs: Pointer );<BR>
procedure MF_multiLinfitwW( A:fVector; Covar:fMatrix; AStatus:iVector; nParameters:UInt; ListOfExperiments: PMF_EXPERIMENT; nexperiments:UInt; funcs: Pointer );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The input data, contained in <I>ListOfExperiments</I>, are used to evaluate the parameters <I>a<sub>i</sub></I> of a general linear function,<BR>
<font face="courier new"> z = a<sub>0</sub>f<sub>0</sub>(x,y) + a<sub>1</sub>f<sub>1</sub>(x,y) + a<sub>2</sub>f<sub>2</sub>(x,y)...</font><BR>
The parameters <I>a<sub>i</sub></I> are returned in the vector A. 
<P>Arguments:
<table border=0 width="100%">
<tr valign="top"><td>A</td><td>vector of size <I>npars</I>; returns the coefficients</td></tr>
<tr valign="top"><td>Covar</td><td>matrix of dimensions [npars, npars]; returns the covariances of the coefficients</td></tr>
<tr valign="top"><td>AStatus</td><td>vector of size <I>npars</I>; decides which parameters are treated as free or as fixed</td></tr>
<tr valign="top"><td>npars</td><td>total number of parameters</td></tr>
<tr valign="top"><td>ListOfExperiments</td><td>input data, see <I><a href="#chap13_4EXPERIMENT">chap. 13.4</a></I></td></tr>
<tr valign="top"><td>nexperiments</td><td>number of data sets in <I>ListOfExperiments</I></td></tr>
<tr valign="top"><td>funcs</td><td>user-defined model function</td></tr>
</table>&nbsp;<BR>
Your model function may actually contain more parameters than you wish to treat as adjustable. This is why you have to provide an additional vector, AStatus, which contains the necessary information about which parameters are to be held fixed at their input values (AStatus[i] = 0) and which are free (AStatus[i] = 1). Any fixed parameters must be initialized in A prior to calling <I>MF_multiLinfit</I>. The argument <I>npars</I> denotes the total number of parameters in A (not only the free parameters!). 
<P>The input data must be combined into sets of the type <I><a href="#chap13_4EXPERIMENT">MF_EXPERIMENT</a></I>. Let us assume you have two sets of X-Y-Z data, each with the vectors X and Y for the independent variables, the matrix MZ for the z=f(x,y) values and, for <I>MF_multiLinfitwW</I>, the weights of all points in MInvVar. The matrix dimensions are htZ (equal to sizeY) and lenZ (equal to sizeX). Now you have to construct a list of experiments as in the following example:
</td></tr><tr valign="top"><td>Constructing list of experiments in C/C++</td><td>
<font face="courier new">MF_EXPERIMENT ExpList[2];
<BR>ExpList[0].X = X1;&nbsp;&nbsp;ExpList[0].Y = Y1;&nbsp;&nbsp;
<BR>ExpList[0].MZ = MZ1; 
<BR>ExpList[0].htZ = htZ1;&nbsp;&nbsp;ExpList[0].lenZ = lenZ1;
<BR>ExpList[1].X = X1;&nbsp;&nbsp;ExpList[1].Y = Y2;&nbsp;&nbsp;
<BR>ExpList[1].MZ = MZ2; 
<BR>ExpList[1].htZ = htZ2;&nbsp;&nbsp;ExpList[1].lenZ = lenZ2;
<BR>/* for the weighted variant, set additionally: */
<BR>ExpList[0].MInvVar = MInvVar1;&nbsp;&nbsp;
<BR>ExpList[0].WeightOfExperiment = wt1;
<BR>ExpList[1].MInvVar = MInvVar2;&nbsp;&nbsp;
<BR>ExpList[1].WeightOfExperiment = wt2;
<BR>&nbsp;</font>
</td></tr><tr valign="top"><td>Constructing list of experiments in Pascal/Delphi</td><td>
<font face="courier new"><B>var</B> ExpList: array[0..1] of MF_EXPERIMENT;
<BR>begin
<BR>&nbsp;&nbsp;...
<BR>&nbsp;&nbsp;ExpList[0].X := X1;&nbsp;&nbsp;ExpList[0].Y := Y1;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[0].MZ := MZ1;
<BR>&nbsp;&nbsp;ExpList[0].htZ := htZ1;&nbsp;&nbsp;ExpList[0].lenZ := lenZ1; 
<BR>&nbsp;&nbsp;ExpList[1].X := X2;&nbsp;&nbsp;ExpList[1].Y := Y2;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[1].MZ := MZ2;
<BR>&nbsp;&nbsp;ExpList[1].htZ := htZ2;&nbsp;&nbsp;ExpList[1].lenZ := lenZ2;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;(* for the weighted variant, set additionally: *)
<BR>&nbsp;&nbsp;ExpList[0].MInvVar := MInvVar1;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[0].WeightOfExperiment := wt1;
<BR>&nbsp;&nbsp;ExpList[1].MInvVar := MInvVar2;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[1].WeightOfExperiment := wt2;
<BR>&nbsp;&nbsp;... 
<BR>end;</font>
<P>&nbsp;
</td></tr><tr valign="top"><td>Both C/C++ and Pascal/Delphi</td><td>
You must provide a model function &quot;funcs&quot; which, for any argument <I>x</I>, must calculate the individual basis functions f<sub>i</sub>(x,y) and store them in a vector <I>BasFuncs</I>. The model function has to be defined as<BR>&nbsp;
</td></tr><tr valign="top"><td>Model function for C/C++</td><td>
<font face="courier new">void MyFunc( fVector BasFuncs, float x, float y, unsigned nfuncs, unsigned iexperiment )
<BR>{
<BR>&nbsp;&nbsp;BasFuncs[0] = f0( x, y );
<BR>&nbsp;&nbsp;BasFuncs[1] = f1( x, y );
<BR>&nbsp;&nbsp;...
<BR>}</font><BR>
and shall be passed to <I>MF_multiLinfit</I> by calling<BR>
<font face="courier new">MF_multiLinfit( A, AStatus, npars, ExpList, 2, MyFunc );</font><BR>&nbsp;
</td></tr><tr valign="top"><td>Model function for Pascal/Delphi</td><td>
<font face="courier new">procedure MyFunc( BasFuncs:fVector; x, y:Single; nfuncs, iexperiment:UInt );
<BR>begin
<BR>&nbsp;&nbsp;VF_Pelement( BasFuncs, 0 )^ := f0( x, y );
<BR>&nbsp;&nbsp;VF_Pelement( BasFuncs, 1 )^ := f1( x, y );
<BR>&nbsp;&nbsp;...
<BR>end;</font><BR>
This model function shall be passed to <I>MF_multiLinfit</I> by calling<BR>
<font face="courier new">MF_multiLinfit( A, AStatus, npars, @ExpList, 2, @MyFunc );</font><BR>
Note the address-of operators in front of &quot;ExpList&quot; (static Pascal array passed to <I>OptiVec</I> function) and &quot;MyFunc.&quot; (pointer to the function MyFunc). In Turbo Pascal, the model function <B>must</B> be compiled with the Force-Far-Calls option {$F+}.
</td></tr><tr valign="top"><td>Both C/C++ and Pascal/Delphi</td><td>
<P>The argument <I>iexperiment</I> with which <I>MyFunc</I> shall be called by <I>MF_multiLinfit</I> allows to distinguish between parameters that are common to all experiments and others that belong to individual experiments. For example, each experiment's MZ values might be shifted by a constant C. In this case, <I>A</I> has to contain as many shifts C<sub>i</sub> as there are experiments. In MyFunc, you would have to code this as (in C/C++; you will easily translate this into Pascal/Delphi yourself):
<BR><font face="courier new">&nbsp;&nbsp;if( iexperiment == 0 ) { BasFuncs[2] = 1; BasFuncs[3] = 0; }
<BR>&nbsp;&nbsp;else {BasFuncs[2] = 0; BasFuncs[3] = 1; }</font>
<P>The functions f0( x,y ) etc. <B>must not</B> contain the parameters <I>a<sub>i</sub></I>. In the weighted variant, the matrix <I>MCovar</I> will be filled with the covariances of the parameters <I>a<sub>i</sub></I> on output: MCovar<sub>i,j</sub> = covariance( <I>a<sub>i</sub></I>, <I>a<sub>j</sub></I> ). 
<P>Internally, <I>MF_multiLinfit</I> employs a Singular Value Decomposition algorithm to obtain a solution even for (near-)singular linear systems. Thereby, coefficients <I>a<sub>i</sub></I> whose significance is lower than a threshold, <I>Thresh</I>, are set to 0 instead of infinity. This threshold can be modified by calling <I><a href="#setLinfitNeglect">VF_setLinfitNeglect</a></I>. The current threshold can be retrieved by <I><a href="#getLinfitNeglect">VF_getLinfitNeglect</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Mlinfit">MF_linfit</a>,&nbsp;&nbsp; <a href="#Mnonlinfit">MF_nonlinfit</a>,&nbsp;&nbsp; <a href="#MmultiNonlinfit">MF_multiNonlinfit</a>,&nbsp;&nbsp; <a href="#chap13">Kap.&nbsp;13</a>,&nbsp;&nbsp;FITDEMO*.*</td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="multiNonlinfit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_multiNonlinfit</b></font>
</td><td width="33%"><font size="+1"><b>VD_multiNonlinfit</b></font></td>
<td><font size="+1"><b>VE_multiNonlinfit</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_multiNonlinfitwW</b></font></td>
<td width="33%"><font size="+1"><b>VD_multiNonlinfitwW</b></font></td>
<td><font size="+1"><b>VE_multiNonlinfitwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>fit multiple X-Y data sets to a common model function, possibly non-linear in its parameters</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float VF_multiNonlinfit( fVector A, iVector AStatus, unsigned npars, VF_EXPERIMENT *ListOfExperiments, unsigned nexperiments,<BR>
void (*modelfunc)(fVector YModel, fVector XModel, ui size, unsigned iexperiment),<BR>
void (*derivatives)(fVector dYdAi,fVector X, ui size, unsigned ipar, unsigned iexperiment) );<P>
float VF_multiNonlinfitwW( fVector A, fMatrix Covar, iVector AStatus, unsigned npars, VF_EXPERIMENT *ListOfExperiments, unsigned nexperiments,<BR>
void (*modelfunc)(fVector YModel, fVector X, ui size, unsigned iexperiment),<BR>
void (*derivatives)(fVector dYdAi, fVector X, ui size, unsigned ipar, unsigned iexperiment) );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses VFmnlfit;<BR>
function VF_multiNonlinfit( A: fVector; AStatus: iVector; nParameters: UInt; ListOfExperiments: PVF_EXPERIMENT; nexperiments: UInt; ModelFunc, Derivatives: Pointer ): Single;<P>
function VF_multiNonlinfitwW( A: fVector; Covar: fMatrix; AStatus: iVector; nParameters: UInt; ListOfExperiments: PVF_EXPERIMENT; nexperiments: UInt; ModelFunc, Derivatives: Pointer ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The input data, contained in <I>ListOfExperiments</I>, are used to evaluate the parameter array <I>A</I> with <I>npars</I> elements <I>a<sub>i</sub></I> of an arbitrary model function y = f(x). 
<P>Arguments:
<table border=0 width="100%">
<tr valign="top"><td>A</td><td>vector of size <I>npars</I>; returns the coefficients</td></tr>
<tr valign="top"><td>Covar</td><td>matrix of dimensions [npars, npars]; returns the covariances of the coefficients</td></tr>
<tr valign="top"><td>AStatus</td><td>vector of size <I>npars</I>; decides which parameters are treated as free or as fixed</td></tr>
<tr valign="top"><td>npars</td><td>total number of parameters</td></tr>
<tr valign="top"><td>ListOfExperiments</td><td>input data, see <I><a href="#chap13_4EXPERIMENT">chap. 13.4</a></I></td></tr>
<tr valign="top"><td>nexperiments</td><td>number of data sets in <I>ListOfExperiments</I></td></tr>
<tr valign="top"><td>modelfunc</td><td>user-defined model function</td></tr>
<tr valign="top"><td>derivatives</td><td>user-defined function, calculating the partial derivatives with respect to all parameters</td></tr>
</table>&nbsp;<BR>
The model function (and, consequently, the vector <I>A</I> as well) may actually contain more parameters than you wish to treat as adjustable. This is why you have to provide an additional vector, <I>AStatus</I>, which contains the necessary information about which parameters are to be held fixed at their input values (AStatus[i] = 0) and which are free (AStatus[i] = 1). All parameters must be initialized in <I>A</I> prior to calling <I>VF_multiNonlinfit</I>. The better your initial guess of the parameters, the faster <I>VF_multiNonlinfit</I> shall converge. The argument <I>npars</I> denotes the total number of parameters in <I>A</I> (not only the free parameters!). 
<P>The input data must be combined into sets of the type <I><a href="#chap13_4EXPERIMENT">VF_EXPERIMENT</a></I>. Assuming you have two sets of X-Y data, contained in the vectors X1, Y1 (and, for <I>VF_multiLinfitwW</I>, InvVar1) of size1 elements, and X2, Y2 (and InvVar2) of size2 elements, you have to construct a list of experiments as in the following example:
</td></tr><tr valign="top"><td>Constructing list of experiments in C/C++</td><td>
<font face="courier new">VF_EXPERIMENT ExpList[2];
<BR>ExpList[0].X = X1;&nbsp;&nbsp;ExpList[0].Y = Y1;&nbsp;&nbsp;ExpList[0].size = size1;
<BR>ExpList[1].X = X2;&nbsp;&nbsp;ExpList[1].Y = Y2;&nbsp;&nbsp;ExpList[1].size = size2;
<BR>/* for the weighted variant, set additionally: */
<BR>ExpList[0].InvVar = InvVar1;&nbsp;&nbsp;ExpList[0].WeightOfExperiment = wt1;
<BR>ExpList[1].InvVar = InvVar2;&nbsp;&nbsp;ExpList[1].WeightOfExperiment = wt2;
<BR>&nbsp;</font>
</td></tr><tr valign="top"><td>Constructing list of experiments in Pascal/Delphi</td><td>
<font face="courier new"><B>var</B> ExpList: array[0..1] of VF_EXPERIMENT;
<BR>begin
<BR>&nbsp;&nbsp;...
<BR>&nbsp;&nbsp;ExpList[0].X := X1;&nbsp;&nbsp;ExpList[0].Y := Y1;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[0].size := size1;
<BR>&nbsp;&nbsp;ExpList[1].X := X2;&nbsp;&nbsp;ExpList[1].Y := Y2;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[1].size := size2;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;/* for the weighted variant, set additionally: */
<BR>&nbsp;&nbsp;ExpList[0].InvVar := InvVar1;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[0].WeightOfExperiment := wt1;
<BR>&nbsp;&nbsp;ExpList[1].InvVar := InvVar2;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[1].WeightOfExperiment := wt2;
<BR>&nbsp;&nbsp;... 
<BR>end;</font>
<BR>&nbsp;
</td></tr><tr valign="top"><td>Both C/C++ and Pascal/Delphi</td><td>
You must provide a model function &quot;modelfunc&quot; which, for a given vector of x-values, must calculate the corresponding &quot;theoretical&quot; y-values. In C/C++, it has to be defined as<BR>&nbsp;
</td></tr><tr valign="top"><td>Model function for C/C++</td><td>
<font face="courier new">void _cdecl MyFunc( fVector Y, fVector X, ui size, unsigned iexperiment )
<BR>{
<BR>&nbsp;&nbsp;for (ui i=0; i&lt;size; i++ )
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Y[i] = f( X[i] ); 
<BR>}<BR>
f( X[i] ) </font>is any arbitrary function, which may be as complicated as you like and your application needs. The only condition is that it have no singularities, at least within the parameter space specified by upper and lower boundaries (see <a href="#chap13_3NONLINFITOPTIONS">NONLINFITOPTIONS</a>).
<P>The argument <I>iexperiment</I> with which <I>MyFunc</I> shall be called by <I>VF_multiNonlinfit</I> allows to distinguish between parameters that are common to all experiments and others that belong to individual experiments. For example, each experiment's Y values might be scaled by an individual constant C. In this case, <I>A</I> has to contain as many scales C as there are experiments. In MyFunc, you would have to code this as something like:
<BR><font face="courier new">&nbsp;&nbsp;if( iexperiment == 0 ) Y[i] *= A[5];&nbsp;&nbsp;else Y[i] *= A[6];</font>
<P>In addition to the model function, <I>VF_multiNonlinfit</I> needs the partial derivatives of Y with respect to all parameters A[ipar], according to your model. If you know them analytically, you should write a function MyDerivs. If you happen to know only some, but not all of the partial derivatives, you may rely on <I><a href="#multiNonlinfit_">VF_multiNonlinfit_autoDeriv</a></I> to calculate the unknown derivatives numerically.
</td></tr><tr valign="top"><td>Partial derivatives coded for C/C++</td><td>
<font face="courier new">void _cdecl MyDerivs( fVector dYdAi, fVector X, ui size, unsigned ipar, unsigned iexperiment )
<BR>{
<BR>&nbsp;&nbsp;ui i;
<BR>&nbsp;&nbsp;switch( ipar )
<BR>&nbsp;&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;case 0: for(i=0; i&lt;size; i++ ) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dYdAi[i] = part_derv_of_Y_w_resp_to_A<sub>0</sub>( X[i] );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;case 1: for(i=0; i&lt;size; i++ ) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dYdAi[i] = part_derv_of_Y_w_resp_to_A<sub>1</sub>( X[i] );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;default: /* for all derivatives we don't know: */
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#multiNonlinfit_">VF_multiNonlinfit_autoDeriv</a>( 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dYdAi, X, size, ipar, iexperiment );
<BR>&nbsp;&nbsp;}
<BR>}</font><BR>
Again, the argument <I>iexperiment</I> allows you to treat &quot;private&quot; parameters of the individual experiments differently from the shared parameters.<BR>
A call to <I>VF_multiNonlinfit</I> will look like:<BR>
<font face="courier new">VF_multiNonlinfit( A, AStatus, npars, ExpList, 2, MyFunc, MyDerivs );</font><BR>
In case you do not know any of the partial derivatives, do not define MyDerivs, but call <I>VF_multiNonlinfit</I> with <I>derivaties</I> = NULL:<BR>
<font face="courier new">VF_multiNonlinfit( A, AStatus, npars, ExpList, 2, MyFunc, NULL );</font><BR>&nbsp;
</td></tr><tr valign="top"><td>Model function for Pascal/Delphi</td><td>
In Pascal/Delphi, the model function has to be defined as<BR>
<font face="courier new">procedure MyFunc( Y, X:fVector; size, iexperiment:UInt );
<BR>var i:UInt;
<BR>begin
<BR>&nbsp;&nbsp;for i:=0 to size-1 do
<BR>&nbsp;&nbsp;&nbsp;&nbsp;VF_Pelement( Y, i )^ := f( VF_element( X, i ) );
<BR>end;<BR>
f( X[i] ) </font>is any arbitrary function, which may be as complicated as you like and your application needs. The only condition is that it have no singularities, at least within the parameter space specified by upper and lower boundaries (see <a href="#chap13_3">Kap.&nbsp;13.3</a>).
<P>The argument <I>iexperiment</I> with which <I>MyFunc</I> shall be called by <I>VF_multiNonlinfit</I> allows to distinguish between parameters that are common to all experiments and others that belong to individual experiments. For example, each experiment's Y values might be scaled by an individual constant C. In this case, <I>A</I> has to contain as many scales C as there are experiments. In MyFunc, you would have to code this as something like:
<BR><font face="courier new">&nbsp;&nbsp;if iexperiment = 0 then
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VF_Pelement(Y,i)^ := VF_element(Y,i) * VF_element(A,5)
<BR>&nbsp;&nbsp;else VF_Pelement(Y,i)^ := VF_element(Y,i) * VF_element(A,6);</font>
<P>In addition to the model function, <I>VF_multiNonlinfit</I> needs the partial derivatives of Y with respect to all parameters A[ipar], according to your model. If you know them analytically, you should write a function MyDerivs. If you happen to know only some, but not all of the partial derivatives, you may rely on <I><a href="#multiNonlinfit_">VF_multiNonlinfit_autoDeriv</a></I> to calculate the unknown derivatives numerically.
</td></tr><tr valign="top"><td>Partial derivatives coded for Pascal/Delphi</td><td>
<font face="courier new">procedure MyDerivs( dYdAi, X:fVector; size, ipar, iexperiment:UInt );
<BR>var i:UInt;
<BR>begin
<BR>&nbsp;&nbsp;case ipar of
<BR>&nbsp;&nbsp;&nbsp;&nbsp;0: begin
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i:=0 to size-1 do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VF_Pelement( dYdAi, i )^ :=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part_derv_of_Y_w_resp_to_A<sub>0</sub>(VF_element( X, i )); end;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;1: begin
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i:=0 to size-1 do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VF_Pelement( dYdAi, i )^ :=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part_derv_of_Y_w_resp_to_A<sub>0</sub>(VF_element( X, i )); end;
<BR>&nbsp;&nbsp;else (* for all derivatives we don't know: *)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#multiNonlinfit_">VF_multiNonlinfit_autoDeriv</a>( 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dYdAi, X, size, ipar, iexperiment );
<BR>&nbsp;&nbsp;end;
<BR>end;</font><BR>
Again, the argument <I>iexperiment</I> allows you to treat &quot;private&quot; parameters of the individual experiments differently from the shared parameters.<BR>
A call to <I>VF_multiNonlinfit</I> will look like:<BR>
<font face="courier new">VF_multiNonlinfit( A, AStatus, npars, @ExpList, 2, @MyFunc, @MyDerivs );</font><BR>
Note the address-of operator in front of &quot;ExpList&quot;, &quot;MyFunc.&quot;, and &quot;MyDerivs&quot;. In Turbo Pascal, both MyFunc and MyDerivs <B>must</B> be compiled with the Force-Far-Calls option {$F+}. In case you do not know any of the partial derivatives, do not define MyDerivs, but call <I>VF_multiNonlinfit</I> with <I>derivaties</I> = <B>nil</B>:<BR>
<font face="courier new">VF_multiNonlinfit( A, AStatus, npars, @ExpList, 2, @MyFunc, nil );</font><BR>
<BR>In the weighted variant, <I>VF_multiNonlinfitwW</I>, the vector <I>ExpList[i].InvVar</I> of each experiment has to contain the inverse of the variances of the individual X-Y data points, and the matrix <I>MCovar</I> will be filled with the covariances of the parameters <I>a<sub>i</sub></I> on output: MCovar<sub>i,j</sub> = covariance( <I>a<sub>i</sub></I>, <I>a<sub>j</sub></I> ).<BR>&nbsp;
</td></tr><tr valign="top"><td>Both C/C++ and Pascal/Delphi:</td><td>
For the many different options controlling nonlinear data-fitting functions, please consult <a href="#chap13_3">Kap.&nbsp;13.3</a>. Helper functions for breaking off excessively long fitting runs and for the monitoring of these often very time-consuming procedures are summarized in <a href="#chap13_5">Kap.&nbsp;13.5</a> and, in the special case of <I>VF_multiNonlinfit</I>, <a href="#multiNonlinfit_">described here</a>.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Multi-threading restrictions</td><td>In order to allow the monitoring functions to access intermediate results, these had to be made global. Therefore, only one instance of a given nonlinear fitting function can be active at a time. If the same function would run in two or more parallel threads, they would overwrite each other's intermediate results. Additionally, in the Delphi version, <I>VF_nonlinfit</I> and <I>VF_multiNonlinfitwW</I> cannot run simultaneously either. The same is true on the <I>VD_</I> and on the <I>VE_</I> level. It is, however, possible, to run <I>VF_multiNonlinfit</I> and <I>VD_multiNonlinfit</I> in parallel.
<P>These functions may not be called while the FPU is set to reduced accuracy, or else they might hang in an infinite loop. See <I><a href="FUNCREF.HTM#setFPAccuracy">V_setFPAccuracy</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>in case of success: goodness-of-fit parameter <font face="symbol">c</font><sup>2</sup> (chi-square);<BR>in case of failure: -1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#setNonlinfitOptions">VF_setNonlinfitOptions</a>,&nbsp;&nbsp; <a href="#MmultiNonlinfit">MF_multiNonlinfit</a>,&nbsp;&nbsp; <a href="#linfit">VF_linfit</a>,&nbsp;&nbsp; <a href="#chap13">Kap.&nbsp;13</a>,&nbsp;&nbsp;FITDEMO*.*</td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="multiNonlinfit_"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_multiNonlinfit_...</b></font>
</td><td width="33%"><font size="+1"><b>VD_multiNonlinfit_...</b></font></td>
<td><font size="+1"><b>VE_multiNonlinfit_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_multiNonlinfitwW_...</b></font></td>
<td width="33%"><font size="+1"><b>VD_multiNonlinfitwW_...</b></font></td>
<td><font size="+1"><b>VE_multiNonlinfitwW_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._autoDeriv</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getChi2</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getChi2Detail</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getBestValues</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getTestRun</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getTestPar</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getTestDir</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._stop</B></font></td><td></TD></tr></table>
</td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>helper functions for <I><a href="#multiNonlinfit">VF_multiNonlinfit</a></I> and <I><a href="#multiNonlinfit">VF_multiNonlinfitwW</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void VF_multiNonlinfit_autoDeriv( fVector dYdAi, fVector X, ui size, unsigned ipar, unsigned iexperiment );<BR>
float VF_multiNonlinfit_getChi2( void );<BR>
void VF_multiNonlinfit_getChi2Detail( fVector Chi2Detail );
void VF_multiNonlinfit_getBestValues( fVector ABest );<BR>
int VF_multiNonlinfit_getTestDir( void );<BR>
unsigned VF_multiNonlinfit_getTestPar( void );<BR>
unsigned VF_multiNonlinfit_getTestRun( void );<BR>
void VF_multiNonlinfit_stop( void );</font><BR>
&nbsp;&nbsp;(identical syntax for the <I>VF_multiNonlinfitwW_...</I> functions)</td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses VFmnlfit;<BR>
procedure VF_multiNonlinfit_autoDeriv( dYdAi, X:fVector; size, ipar, iex:UInt );<BR>
function VF_multiNonlinfit_getChi2: Single;<BR>
procedure VF_multiNonlinfit_getChi2Detail( Chi2Detail:fVector );<BR>
procedure VF_multiNonlinfit_getBestValues( BestValues: fVector );<BR>
function VF_multiNonlinfit_getTestDir: Integer;<BR>
function VF_multiNonlinfit_getTestPar: UInt;<BR>
function VF_multiNonlinfit_getTestRun: UInt;<BR>
procedure VF_multiNonlinfit_stop;</font><BR>
&nbsp;&nbsp;(identical syntax for the <I>VF_multiNonlinfitwW_...</I> functions)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><I>VF_multiNonlinfit_autoDeriv</I> performs a numerical differentiation of a user-provided y=f(x) model function with respect to the parameter <I>a<sub>ipar</sub></I> of the model. This function can be called only from within a function passed as the argument &quot;derivatives&quot; to <a href="#multiNonlinfit">VF_multiNonlinfit</a>. The model function that is differentiated by <I>VF_multiNonlinfit_autoDeriv</I> is the one passed in the same call to <a href="#multiNonlinfit">VF_multiNonlinfit</a> (see that function for details!).<P>
The following functions allow to monitor the progress of a nonlinear fitting operation. They can either be called from within the provided model function or, for multi-thread applications, from a second thread running in parallel to the thread containing the fitting function.<BR>
<I>VF_multiNonlinfit_getChi2</I> returns the best figure-of-merit (<font face="symbol">c</font><sup>2</sup> or, for robust fits, |<font face="symbol">c</font>|) obtained so far. If you call this function before <I>VF_multiNonlinfit</I> has had the chance to calculate <font face="symbol">c</font><sup>2</sup>, <I>VF_multiNonlinfit_getChi2</I> returns -1.0.<P>
<I>VF_multiNonlinfit_getChi2Detail</I> fills the user-supplied vector <I>Chi2Detail</I> with the individual figures-of-merit (<font face="symbol">c</font><sup>2</sup><sub>iex</sub> or, for robust fits, |<font face="symbol">c</font><sub>iex</sub>|) for all experiments. The sum over these individual <font face="symbol">c</font><sup>2</sup><sub>iex</sub> or |<font face="symbol">c</font><sub>iex</sub>| values is the best <font face="symbol">c</font><sup>2</sup> (or |<font face="symbol">c</font>|) obtained so far, as returned by <I>VF_multiNonlinfit_getChi2</I>.<P>
<I>VF_multiNonlinfit_getBestValues</I> stores the best parameters <I>a<sub>i</sub></I> obtained so far into the user-supplied vector <I>ABest</I>.<P>
<I>VF_multiNonlinfit_getTestDir</I> returns the test direction (+1 for upwards, -1 for downwards) during &quot;breakout&quot; attempts from possible <U>local</U> optima which would otherwise prevent the routine from finally reaching the <U>global</U> optimum (level-of-method greater than 3 specified by <I><a href="#setNonlinfitOptions">VF_setNonlinfitOptions</a></I>).<P>
<I>VF_multiNonlinfit_getTestPar</I> returns the index of the parameter currently under &quot;breakout&quot; investigation.<P>
<I>VF_multiNonlinfit_getTestRun</I> returns the index of the current &quot;breakout&quot; test run. For each fitted parameter, one test run is performed. The order in which the parameters are checked is determined internally in such a way as to test the most sensitive parameters first.<P>
<I>VF_multiNonlinfit_stop</I> makes <I>VF_multiNonlinfit</I> finish its current Levenberg-Marquardt or Downhill-Simplex cycle, update the output parameters and return. Thereby, long fitting sessions (especially tedious &quot;break-out&quot; attempts) may be broke off without the loss of any data.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap13">Kap.&nbsp;13</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="MmultiNonlinfit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_multiNonlinfit</b></font>
</td><td width="33%"><font size="+1"><b>MD_multiNonlinfit</b></font></td>
<td><font size="+1"><b>ME_multiNonlinfit</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_multiNonlinfitwW</b></font></td>
<td width="33%"><font size="+1"><b>MD_multiNonlinfitwW</b></font></td>
<td><font size="+1"><b>ME_multiNonlinfitwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>fit multiple X-Y-Z data sets to a common model function, possibly non-linear in its parameters</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float MF_multiNonlinfit( fVector A, iVector AStatus, unsigned npars, MF_EXPERIMENT _VFAR *ListOfExperiments, unsigned nexperiments,<BR>
void (*modelfunc)(fMatrix MZModel, unsigned htZ, unsigned lenZ, fVector X, fVector Y, unsigned iexperiment),<BR>
void (*derivatives)(fMatrix dZdAi, unsigned htZ, unsigned lenZ, fVector X, fVector Y, unsigned ipar, unsigned iexperiment) );<P>
float MF_multiNonlinfitwW( fVector A, fMatrix Covar, iVector AStatus, unsigned npars, MF_EXPERIMENT *ListOfExperiments, unsigned nexperiments,<BR>
void (*modelfunc)(fMatrix MZModel, unsigned htZ, unsigned lenZ, fVector X, fVector Y, unsigned iexperiment ),<BR>
void (*derivatives)(fMatrix dZdAi, unsigned htZ, unsigned lenZ, fVector X, fVector Y, unsigned ipar, unsigned iexperiment) );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFmnlfit;<BR>
function MF_multiNonlinfit( A: fVector; AStatus: iVector; nParameters: UInt; ListOfExperiments: PMF_EXPERIMENT; nexperiments: UInt; ModelFunc, Derivatives: Pointer ): Single;<P>
function MF_multiNonlinfitwW( A: fVector; Covar: fMatrix; AStatus: iVector; nParameters: UInt; ListOfExperiments: PMF_EXPERIMENT; nexperiments: UInt; ModelFunc, Derivatives: Pointer ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The input data, contained in <I>ListOfExperiments</I>, are used to evaluate the parameter array <I>A</I> with <I>npars</I> elements <I>a<sub>i</sub></I> of an arbitrary model function z = f(x, y). 
<P>Arguments:
<table border=0 width="100%">
<tr valign="top"><td>A</td><td>vector of size <I>npars</I>; returns the coefficients</td></tr>
<tr valign="top"><td>Covar</td><td>matrix of dimensions [npars, npars]; returns the covariances of the coefficients</td></tr>
<tr valign="top"><td>AStatus</td><td>vector of size <I>npars</I>; decides which parameters are treated as free or as fixed</td></tr>
<tr valign="top"><td>npars</td><td>total number of parameters</td></tr>
<tr valign="top"><td>ListOfExperiments</td><td>input data, see <I><a href="#chap13_4EXPERIMENT">chap. 13.4</a></I></td></tr>
<tr valign="top"><td>nexperiments</td><td>number of data sets in <I>ListOfExperiments</I></td></tr>
<tr valign="top"><td>modelfunc</td><td>user-defined model function</td></tr>
<tr valign="top"><td>derivatives</td><td>user-defined function, calculating the partial derivatives with respect to all parameters</td></tr>
</table>&nbsp;<BR>
The model function (and, consequently, the vector <I>A</I> as well) may actually contain more parameters than you wish to treat as adjustable. This is why you have to provide an additional vector, <I>AStatus</I>, which contains the necessary information about which parameters are to be held fixed at their input values (AStatus[i] = 0) and which are free (AStatus[i] = 1). All parameters must be initialized in <I>A</I> prior to calling <I>MF_multiNonlinfit</I>. The better your initial guess of the parameters, the faster <I>MF_multiNonlinfit</I> shall converge. The argument <I>npars</I> denotes the total number of parameters in <I>A</I> (not only the free parameters!). 
<P>The input data must be combined into sets of the type <I><a href="#chap13_4EXPERIMENT">MF_EXPERIMENT</a></I>. Let us assume you have two sets of X-Y-Z data, each with the vectors X and Y for the independent variables, the matrix MZ for the z=f(x,y) values and, for <I>MF_multiLinfitwW</I>, the weights of all points in MInvVar. The matrix dimensions are htZ (equal to sizeY) and lenZ (equal to sizeX). Now you have to construct a list of experiments as in the following example:
</td></tr><tr valign="top"><td>Constructing list of experiments in C/C++</td><td>
<font face="courier new">MF_EXPERIMENT ExpList[2];
<BR>ExpList[0].X = X1;&nbsp;&nbsp;ExpList[0].Y = Y1;&nbsp;&nbsp;
<BR>ExpList[0].MZ = MZ1; 
<BR>ExpList[0].htZ = htZ1;&nbsp;&nbsp;ExpList[0].lenZ = lenZ1;
<BR>ExpList[1].X = X1;&nbsp;&nbsp;ExpList[1].Y = Y2;&nbsp;&nbsp;
<BR>ExpList[1].MZ = MZ2; 
<BR>ExpList[1].htZ = htZ2;&nbsp;&nbsp;ExpList[1].lenZ = lenZ2;
<BR>/* for the weighted variant, set additionally: */
<BR>ExpList[0].MInvVar = MInvVar1;&nbsp;&nbsp;
<BR>ExpList[0].WeightOfExperiment = wt1;
<BR>ExpList[1].MInvVar = MInvVar2;&nbsp;&nbsp;
<BR>ExpList[1].WeightOfExperiment = wt2;
<BR>&nbsp;</font>
</td></tr><tr valign="top"><td>Constructing list of experiments in Pascal/Delphi</td><td>
<font face="courier new"><B>var</B> ExpList: array[0..1] of MF_EXPERIMENT;
<BR>begin
<BR>&nbsp;&nbsp;...
<BR>&nbsp;&nbsp;ExpList[0].X := X1;&nbsp;&nbsp;ExpList[0].Y := Y1;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[0].MZ := MZ1;
<BR>&nbsp;&nbsp;ExpList[0].htZ := htZ1;&nbsp;&nbsp;ExpList[0].lenZ := lenZ1; 
<BR>&nbsp;&nbsp;ExpList[1].X := X2;&nbsp;&nbsp;ExpList[1].Y := Y2;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[1].MZ := MZ2;
<BR>&nbsp;&nbsp;ExpList[1].htZ := htZ2;&nbsp;&nbsp;ExpList[1].lenZ := lenZ2;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;/* for the weighted variant, set additionally: */
<BR>&nbsp;&nbsp;ExpList[0].MInvVar := MInvVar1;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[0].WeightOfExperiment := wt1;
<BR>&nbsp;&nbsp;ExpList[1].MInvVar := MInvVar2;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;ExpList[1].WeightOfExperiment := wt2;
<BR>&nbsp;&nbsp;... 
<BR>end;</font>
<P>&nbsp;
</td></tr><tr valign="top"><td>Both C/C++ and Pascal/Delphi</td><td>
You must provide a model function &quot;modelfunc&quot; which, for a given pair of X, Y vectors, must calculate the corresponding &quot;theoretical&quot; z-values. In C/C++, it has to be defined as<BR>&nbsp;
</td></tr><tr valign="top"><td>Model function for C/C++</td><td>
<font face="courier new">void _cdecl MyFunc( fMatrix MZ, unsigned htZ, unsigned lenZ, fVector X, fVector Y, unsigned iexperiment )
<BR>{
<BR>&nbsp;&nbsp;for (ui i=0; i&lt;htZ; i++ )
<BR>&nbsp;&nbsp;&nbsp;&nbsp;for (ui j=0; j&lt;lenZ; j++ )
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MZ[i][j] = f( X[j], Y[i] ); 
<BR>}<BR>
f( X[j], Y[i] ) </font>is any arbitrary function, which may be as complicated as you like and your application needs. The only condition is that it have no singularities, at least within the parameter space specified by upper and lower boundaries (see <a href="#chap13_3NONLINFITOPTIONS">NONLINFITOPTIONS</a>).
<P>The argument <I>iexperiment</I> with which <I>MyFunc</I> shall be called by <I>MF_multiNonlinfit</I> allows to distinguish between parameters that are common to all experiments and others that belong to individual experiments. For example, each experiment's MZ values might be scaled by an individual constant C. In this case, <I>A</I> has to contain as many scales C as there are experiments. In MyFunc, you would have to code this as something like:
<BR><font face="courier new">&nbsp;&nbsp;if( iexperiment == 0 ) MZ[i][j] *= A[5];&nbsp;&nbsp;else MZ[i][j] *= A[6];</font>
<P>In addition to the model function, <I>MF_multiNonlinfit</I> needs the partial derivatives of MZ with respect to all parameters A[ipar], according to your model. If you know them analytically, you should write a function MyDerivs. If you happen to know only some, but not all of the partial derivatives, you may rely on <I><a href="#multiNonlinfit_">MF_multiNonlinfit_autoDeriv</a></I> to calculate the unknown derivatives numerically.
</td></tr><tr valign="top"><td>Partial derivatives coded for C/C++</td><td>
<font face="courier new">void _cdecl MyDerivs( fMatrix dZdAi, unsigned htZ, unsigned lenZ, fVector X, fVector Y, unsigned ipar, unsigned iexperiment )
<BR>{
<BR>&nbsp;&nbsp;ui i;
<BR>&nbsp;&nbsp;switch( ipar )
<BR>&nbsp;&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;case 0: 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;for(i=0; i&lt;htZ; i++ ) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for( j=0; j&lt;lenZ; j++ )
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dZdAi[i][j] = part_derv_MZ_w_resp_to_A<sub>0</sub>( X[j], Y[i] );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;case 1: 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;for(i=0; i&lt;htZ; i++ ) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for( j=0; j&lt;lenZ; j++ )
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dZdAi[i][j] = part_derv_MZ_w_resp_to_A<sub>1</sub>( X[j], Y[i] );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;default: /* for all derivatives we don't know: */
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Mnonlinfit_">MF_multiNonlinfit_autoDeriv</a>( dZdAi, htZ, lenZ, X, Y, ipar, iexperiment );
<BR>&nbsp;&nbsp;}
<BR>}</font><BR>
Again, the argument <I>iexperiment</I> allows you to treat &quot;private&quot; parameters of the individual experiments differently from the shared parameters.<BR>
A call to <I>MF_multiNonlinfit</I> will look like:<BR>
<font face="courier new">MF_multiNonlinfit( A, AStatus, npars, ExpList, 2, MyFunc, MyDerivs );</font><BR>
In case you do not know any of the partial derivatives, do not define MyDerivs, but call <I>MF_multiNonlinfit</I> with <I>derivaties</I> = NULL:<BR>
<font face="courier new">MF_multiNonlinfit( A, AStatus, npars, ExpList, 2, MyFunc, NULL );</font><BR>&nbsp;
</td></tr><tr valign="top"><td>Model function for Pascal/Delphi</td><td>
In Pascal/Delphi, the model function has to be defined as<BR>
<font face="courier new">procedure MyFunc( MZ:fMatrix; htZ, lenZ:UInt; X, Y:fVector; iexperiment:UInt );
<BR>var i, j:UInt;
<BR>begin
<BR>&nbsp;&nbsp;for i:=0 to htZ-1 do
<BR>&nbsp;&nbsp;&nbsp;&nbsp;for j:=0 to lenZ-1 do
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MF_Pelement( MZ, htZ, lenZ, i, j )^ := 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f( VF_element( X, j ), VF_element( Y, i ) );
<BR>end;<BR>
f( X<sub>j</sub>, Y<sub>i</sub> ) </font>is any arbitrary function, which may be as complicated as you like and your application needs. The only condition is that it have no singularities, at least within the parameter space specified by upper and lower boundaries (see <a href="#chap13_3NONLINFITOPTIONS">NONLINFITOPTIONS</a>).
<P>The argument <I>iexperiment</I> with which <I>MyFunc</I> shall be called by <I>MF_multiNonlinfit</I> allows to distinguish between parameters that are common to all experiments and others that belong to individual experiments. For example, each experiment's MZ values might be scaled by an individual constant C. In this case, <I>A</I> has to contain as many scales C as there are experiments. In MyFunc, you would have to code this as something like:
<BR><font face="courier new">&nbsp;&nbsp;if iexperiment = 0 then
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MF_Pelement(MZ, htZ, lenZ, i, j)^ :=
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MF_element(MZ, htZ, lenZ, i, j) * VF_element(A,5)
<BR>&nbsp;&nbsp;else MF_Pelement(MZ, htZ, lenZ, i, j)^ :=
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MF_element(MZ, htZ, lenZ, i, j) * VF_element(A,6);</font>
<P>In addition to the model function, <I>MF_multiNonlinfit</I> needs the partial derivatives of MZ with respect to all parameters A[ipar], according to your model. If you know them analytically, you should write a function MyDerivs. If you happen to know only some, but not all of the partial derivatives, you may rely on <I><a href="#multiNonlinfit_">MF_multiNonlinfit_autoDeriv</a></I> to calculate the unknown derivatives numerically.
</td></tr><tr valign="top"><td>Partial derivatives coded for Pascal/Delphi</td><td>
<font face="courier new">procedure MyDerivs( dZdAi:fMatrix; htZ, lenZ:UInt; X, Y:fVector; ipar, iexperiment:UInt );
<BR>var i, j:UInt;
<BR>begin
<BR>&nbsp;&nbsp;case ipar of
<BR>&nbsp;&nbsp;&nbsp;&nbsp;0: begin
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i:=0 to htZ-1 do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for j:=0 to lenZ-1 do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MF_Pelement( dZdAi, htZ, lenZ, i, j )^ :=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part_derv_MZ_w_resp_to_A<sub>0</sub>(VF_element( X, j ), VF_element( Y, i )); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;1: begin
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i:=0 to htZ-1 do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for j:=0 to lenZ-1 do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MF_Pelement( dZdAi, htZ, lenZ, i, j )^ :=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part_derv_MZ_w_resp_to_A<sub>1</sub>(VF_element( X, j ), VF_element( Y, i )); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;
<BR>&nbsp;&nbsp;else (* for all derivatives we don't know: *)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Mnonlinfit_">MF_multiNonlinfit_autoDeriv</a>( dZdAi, htZ, lenZ, X, Y, ipar );
<BR>&nbsp;&nbsp;end;
<BR>end;</font><BR>
Again, the argument <I>iexperiment</I> allows you to treat &quot;private&quot; parameters of the individual experiments differently from the shared parameters.<BR>
A call to <I>MF_multiNonlinfit</I> will look like:<BR>
<font face="courier new">MF_multiNonlinfit( A, AStatus, npars, @ExpList, 2, @MyFunc, @MyDerivs );</font><BR>
Note the address-of operator in front of &quot;ExpList&quot;, &quot;MyFunc.&quot;, and &quot;MyDerivs&quot;. In Turbo Pascal, both MyFunc and MyDerivs <B>must</B> be compiled with the Force-Far-Calls option {$F+}. In case you do not know any of the partial derivatives, do not define MyDerivs, but call <I>MF_multiNonlinfit</I> with <I>derivaties</I> = <B>nil</B>:<BR>
<font face="courier new">MF_multiNonlinfit( A, AStatus, npars, @ExpList, 2, @MyFunc, nil );</font><BR>
<BR>In the weighted variant, <I>MF_multiNonlinfitwW</I>, the matrix <I>ExpList[i].MInvVar</I> of each experiment has to contain the inverse of the variances of the individual X-Y-Z data points, and the matrix <I>MCovar</I> will be filled with the covariances of the parameters <I>a<sub>i</sub></I> on output: MCovar<sub>i,j</sub> = covariance( <I>a<sub>i</sub></I>, <I>a<sub>j</sub></I> ).<BR>&nbsp;
</td></tr><tr valign="top"><td>Both C/C++ and Pascal/Delphi:</td><td>
For the many different options controlling nonlinear data-fitting functions, please consult <a href="#chap13_3">Kap.&nbsp;13.3</a>. Helper functions for breaking off excessively long fitting runs and for the monitoring of these often very time-consuming procedures are summarized in <a href="#chap13_5">Kap.&nbsp;13.5</a> and, in the special case of <I>MF_multiNonlinfit</I>, <a href="#multiNonlinfit_">described here</a>.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Multi-threading restrictions</td><td>In order to allow the monitoring functions to access intermediate results, these had to be made global. Therefore, only one instance of a given nonlinear fitting function can be active at a time. If the same function would run in two or more parallel threads, they would overwrite each other's intermediate results. Additionally, in the Delphi version, <I>MF_multiNonlinfit</I> and <I>MF_multiNonlinfitwW</I> cannot run simultaneously either. The same is true on the <I>VD_</I> and on the <I>VE_</I> level. It is, however, possible, to run <I>MF_multiNonlinfit</I> and <I>MD_multiNonlinfit</I> in parallel.
<P>These functions may not be called while the FPU is set to reduced accuracy, or else they might hang in an infinite loop. See <I><a href="FUNCREF.HTM#setFPAccuracy">V_setFPAccuracy</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>in case of success: goodness-of-fit parameter <font face="symbol">c</font><sup>2</sup> (chi-square);<BR>in case of failure: -1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#setNonlinfitOptions">VF_setNonlinfitOptions</a>,&nbsp;&nbsp; <a href="#multiNonlinfit">VF_multiNonlinfit</a>,&nbsp;&nbsp; <a href="#Mlinfit">MF_linfit</a>,&nbsp;&nbsp; <a href="#chap13">Kap.&nbsp;13</a>,&nbsp;&nbsp;FITDEMO*.*</td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="MmultiNonlinfit_"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_multiNonlinfit_...</b></font>
</td><td width="33%"><font size="+1"><b>MD_multiNonlinfit_...</b></font></td>
<td><font size="+1"><b>ME_multiNonlinfit_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_multiNonlinfitwW_...</b></font></td>
<td width="33%"><font size="+1"><b>MD_multiNonlinfitwW_...</b></font></td>
<td><font size="+1"><b>ME_multiNonlinfitwW_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._autoDeriv</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getChi2</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getChi2Detail</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getBestValues</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getTestRun</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getTestPar</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getTestDir</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._stop</B></font></td><td></TD></tr></table>
</td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>helper functions for <I><a href="#MmultiNonlinfit">MF_multiNonlinfit</a></I> and <I><a href="#MmultiNonlinfit">MF_multiNonlinfitwW</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_multiNonlinfit_autoDeriv( fMatrix dZdAi, unsigned htZ, unsigned lenZ, fVector X, fVector Y, unsigned ipar, unsigned iex );<BR>
float MF_multiNonlinfit_getChi2( void );<BR>
void MF_multiNonlinfit_getChi2Detail( fVector Chi2Detail );
void MF_multiNonlinfit_getBestValues( fVector ABest );<BR>
int MF_multiNonlinfit_getTestDir( void );<BR>
unsigned MF_multiNonlinfit_getTestPar( void );<BR>
unsigned MF_multiNonlinfit_getTestRun( void );<BR>
void MF_multiNonlinfit_stop( void );</font><BR>
&nbsp;&nbsp;(identical syntax for the <I>MF_nonlinfitwW_...</I> functions)</td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFmnlfit;<BR>
procedure MF_multiNonlinfit_autoDeriv( dZdAi:fMatrix; htZ, lenZ:UInt; X, Y:fVector; ipar, iex: UInt );
function MF_multiNonlinfit_getChi2: Single;
procedure MF_multiNonlinfit_getChi2Detail( Chi2Detail:fVector );
procedure MF_multiNonlinfit_getBestValues( BestValues: fVector );
function MF_multiNonlinfit_getTestDir: Integer;
function MF_multiNonlinfit_getTestPar: UInt;
function MF_multiNonlinfit_getTestRun: UInt;
procedure MF_multiNonlinfit_stop;</font><BR>
&nbsp;&nbsp;(identical syntax for the <I>MF_multiNonlinfitwW_...</I> functions)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><I>MF_multiNonlinfit_autoDeriv</I> performs a numerical differentiation of a user-provided z=f(x,y) model function with respect to the parameter <I>a<sub>ipar</sub></I> of the model. This function can be called only from within a function passed as the argument &quot;derivatives&quot; to <a href="#MmultiNonlinfit">MF_multiNonlinfit</a>. The model function that is differentiated by <I>MF_multiNonlinfit_autoDeriv</I> is the one passed in the same call to <a href="#multiNonlinfit">MF_multiNonlinfit</a> (see that function for details!).<P>
The following functions allow to monitor the progress of a nonlinear fitting operation. They can either be called from within the provided model function or, for multi-thread applications, from a second thread running in parallel to the thread containing the fitting function.<BR>
<I>MF_multiNonlinfit_getChi2</I> returns the best figure-of-merit (<font face="symbol">c</font><sup>2</sup> or, for robust fits, |<font face="symbol">c</font>|) obtained so far. If you call this function before <I>MF_multiNonlinfit</I> has had the chance to calculate <font face="symbol">c</font><sup>2</sup>, <I>MF_multiNonlinfit_getChi2</I> returns -1.0.<P>
<I>MF_multiNonlinfit_getChi2Detail</I> fills the user-supplied vector <I>Chi2Detail</I> with the individual figures-of-merit (<font face="symbol">c</font><sup>2</sup><sub>iex</sub> or, for robust fits, |<font face="symbol">c</font><sub>iex</sub>|) for all experiments. The sum over these individual <font face="symbol">c</font><sup>2</sup><sub>iex</sub> or |<font face="symbol">c</font><sub>iex</sub>| values is the best <font face="symbol">c</font><sup>2</sup> (or |<font face="symbol">c</font>|) obtained so far, as returned by <I>MF_multiNonlinfit_getChi2</I>.<P>
<I>MF_multiNonlinfit_getBestValues</I> stores the best parameters <I>a<sub>i</sub></I> obtained so far into the user-supplied vector <I>ABest</I>.<P>
<I>MF_multiNonlinfit_getTestDir</I> returns the test direction (+1 for upwards, -1 for downwards) during &quot;breakout&quot; attempts from possible <U>local</U> optima which would otherwise prevent the routine from finally reaching the <U>global</U> optimum (level-of-method greater than 3 specified by <I><a href="#setNonlinfitOptions">VF_setNonlinfitOptions</a></I>).<P>
<I>MF_multiNonlinfit_getTestPar</I> returns the index of the parameter currently under &quot;breakout&quot; investigation.<P>
<I>MF_multiNonlinfit_getTestRun</I> returns the index of the current &quot;breakout&quot; test run. For each fitted parameter, one test run is performed. The order in which the parameters are checked is determined internally in such a way as to test the most sensitive parameters first.<P>
<I>MF_multiNonlinfit_stop</I> makes <I>MF_multiNonlinfit</I> finish its current Levenberg-Marquardt or Downhill-Simplex cycle, update the output parameters and return. Thereby, long fitting sessions (especially tedious &quot;break-out&quot; attempts) may be broke off without the loss of any data.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap13">Kap.&nbsp;13</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="mulV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_mulV</b></font>
</td><td width="33%"><font size="+1"><b>MD_mulV</b></font></td>
<td><font size="+1"><b>ME_mulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_mulV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_mulV</b></font></td>
<td><font size="+1"><b>MCE_mulV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply a matrix by a column vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_mulV( fVector Y, fMatrix MA, fVector X, unsigned htA, unsigned lenA );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_mulV( Y:fVector; MA:fMatrix; X:fVector; htA, lenA:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y = MA * X
<BR>the dimensions of X and Y are implicitly given by the matrix dimensions: sizX = lenA, sizY = htA.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#TmulV">MF_TmulV</a>,&nbsp;&nbsp; <a href="#VmulM">VF_mulM</a>,&nbsp;&nbsp; <a href="#chap9">Kap.&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="neg"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_neg</b></font>
</td><td width="33%"><font size="+1"><b>MD_neg</b></font></td>
<td><font size="+1"><b>ME_neg</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_neg</b></font></td>
<td width="33%"><font size="+1"><b>MCD_neg</b></font></td>
<td><font size="+1"><b>MCE_neg</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>negation</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_neg( fMatrix MB, fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_neg( MB, MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MBi<sub>,j</sub> = -MA<sub>i,j</sub></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#conj">MCF_conj</a>,&nbsp;&nbsp; <a href="#chap3">Kap.&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="nfree"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="90%"><font size="+1"><b>M_nfree</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>de-allocate a certain number of matrices (C/C++ only)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void M_nfree( unsigned numfree, ... );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td>This function does not exist</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The parameter <I>numfree</I> &quot;tells&quot; the function how many matrices it has to free. These matrices follow in the parameter list after <I>numfree</I>. De-allocation of matrices not allocated by one of the functions of the <I><a href="#matrix">MF_matrix</a></I> or <I><a href="#matrix0">MF_matrix0</a></I> family is not possible.
<BR>Pascal/Delphi: since a variable number of parameters is not supported in Pascal language, this function is missing.
</td></tr><tr valign="TOP">
<td>Example C/C++</td><td><font face="courier new">M_nfree( 3, MX, MY, MZ );</font></td></tr></table></td></tr><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><I><a href="#free">M_free</a></I>,&nbsp;&nbsp;<I><a href="FUNCREF.HTM#freeAll">V_freeAll</a></I>,&nbsp;&nbsp;<a href="#chap2">Kap.&nbsp;2</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="nonlinfit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_nonlinfit</b></font>
</td><td width="33%"><font size="+1"><b>VD_nonlinfit</b></font></td>
<td><font size="+1"><b>VE_nonlinfit</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_nonlinfitwW</b></font></td>
<td width="33%"><font size="+1"><b>VD_nonlinfitwW</b></font></td>
<td><font size="+1"><b>VE_nonlinfitwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>fit y=f(x) data to a model-function which may be nonlinear in its parameters</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float VF_nonlinfit( fVector A, iVector AStatus, unsigned npars, fVector X, fVector Y, ui sizex,<BR>
void (*modelfunc)(fVector YModel, fVector XModel, ui size),<BR>
void (*derivatives)(fVector dYdAi, fVector X, ui size, unsigned iPar) );<P>
float VF_nonlinfitwW( fVector A, fMatrix Covar, iVector AStatus, unsigned npars, fVector X, fVector Y, fVector InvVar, ui sizex,<BR>
void (*modelfunc)(fVector YModel, fVector X, ui size),<BR>
void (*derivatives)(fVector dYdAi, fVector X, ui size, unsigned i) );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses VFnlfit;<BR>
function VF_nonlinfit( A: fVector; AStatus: iVector; nParameters: UInt; X, Y: fVector; sizex: UInt; ModelFunc, Derivatives: Pointer ): Single;<P>
function VF_nonlinfitwW( A: fVector; Covar: fMatrix; AStatus: iVector; nParameters: UInt; X, Y, InvVar:fVector; sizex: UInt; ModelFunc, Derivatives: Pointer ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The input data X, Y (and InvVar) are used to evaluate the parameter array <I>A</I> with <I>npars</I> elements <I>a<sub>i</sub></I> of an arbitrary model function y = f(x). 
<P>Arguments:
<table border=0 width="100%">
<tr valign="top"><td>A</td><td>vector of size <I>npars</I>; returns the coefficients</td></tr>
<tr valign="top"><td>Covar</td><td>matrix of dimensions [npars, npars]; returns the covariances of the coefficients</td></tr>
<tr valign="top"><td>AStatus</td><td>vector of size <I>npars</I>; decides which parameters are treated as free or as fixed</td></tr>
<tr valign="top"><td>npars</td><td>total number of parameters</td></tr>
<tr valign="top"><td>X,&nbsp;Y,&nbsp;InvVar</td><td>vectors of size <I>sizex</I>, holding the input data</td></tr>
<tr valign="top"><td>modelfunc</td><td>user-defined model function</td></tr>
<tr valign="top"><td>derivatives</td><td>user-defined function, calculating the partial derivatives with respect to all parameters</td></tr>
</table>&nbsp;<BR>
The model function (and, consequently, the vector <I>A</I> as well) may actually contain more parameters than you wish to treat as adjustable. This is why you have to provide an additional vector, AStatus, which contains the necessary information about which parameters are to be held fixed at their input values (AStatus[i] = 0) and which are free (AStatus[i] = 1). All parameters must be initialized in <I>A</I> prior to calling <I>VF_nonlinfit</I>. The better your initial guess of the parameters, the faster <I>VF_nonlinfit</I> shall converge. The argument <I>npars</I> denotes the total number of parameters in <I>A</I> (not only the free parameters!). 
<P>You must provide a model function &quot;modelfunc&quot; which, for a given vector of x-values, must calculate the corresponding &quot;theoretical&quot; y-values. In C/C++, it has to be defined as<BR>
</td></tr><tr valign="top"><td>Model function for C/C++</td><td>
<font face="courier new">void _cdecl MyFunc( fVector Y, fVector X, ui size )
<BR>{
<BR>&nbsp;&nbsp;for (ui i=0; i&lt;size; i++ )
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Y[i] = f( X[i] ); 
<BR>}<BR>
f( X[i] ) </font>is any arbitrary function, which may be as complicated as you like and your application needs. The only condition is that it have no singularities, at least within the parameter space specified by upper and lower boundaries (see <a href="#chap13_3NONLINFITOPTIONS">NONLINFITOPTIONS</a>).
<BR>In addition to the model function, <I>VF_nonlinfit</I> needs the partial derivatives of Y with respect to all parameters A[ipar], according to your model. If you know them analytically, you should write a function MyDerivs. If you happen to know only some, but not all of the partial derivatives, you may rely on <I><a href="#nonlinfit_">VF_nonlinfit_autoDeriv</a></I> to calculate the unknown derivatives numerically.
</td></tr><tr valign="top"><td>Partial derivatives coded for C/C++</td><td>
<font face="courier new">void _cdecl MyDerivs( fVector dYdAi, fVector X, ui size, unsigned ipar )
<BR>{
<BR>&nbsp;&nbsp;ui i;
<BR>&nbsp;&nbsp;switch( ipar )
<BR>&nbsp;&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;case 0: for(i=0; i&lt;size; i++ ) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dYdAi[i] = part_derv_of_Y_w_resp_to_A<sub>0</sub>( X[i] );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;case 1: for(i=0; i&lt;size; i++ ) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dYdAi[i] = part_derv_of_Y_w_resp_to_A<sub>1</sub>( X[i] );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;default: /* for all derivatives we don't know: */
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#nonlinfit_">VF_nonlinfit_autoDeriv</a>( dYdAi, X, size, ipar);
<BR>&nbsp;&nbsp;}
<BR>}</font><BR>
A call to <I>VF_nonlinfit</I> will look like:<BR>
<font face="courier new">VF_nonlinfit( A, AStatus, npars, X, Y, sizex, MyFunc, MyDerivs );</font><BR>
In case you do not know any of the partial derivatives, do not define MyDerivs, but call <I>VF_nonlinfit</I> with <I>derivaties</I> = NULL:<BR>
<font face="courier new">VF_nonlinfit( A, AStatus, npars, X, Y, sizex, MyFunc, NULL );</font><BR>&nbsp;
</td></tr><tr valign="top"><td>Model function for Pascal/Delphi</td><td>
In Pascal/Delphi, the model function has to be defined as<BR>
<font face="courier new">procedure MyFunc( Y, X:fVector; size:UInt );
<BR>var i:UInt;
<BR>begin
<BR>&nbsp;&nbsp;for i:=0 to size-1 do
<BR>&nbsp;&nbsp;&nbsp;&nbsp;VF_Pelement( Y, i )^ := f( VF_element( X, i ) );
<BR>end;<BR>
f( X[i] ) </font>is any arbitrary function, which may be as complicated as you like and your application needs. The only condition is that it have no singularities, at least within the parameter space specified by upper and lower boundaries (see <a href="#chap13_3NONLINFITOPTIONS">NONLINFITOPTIONS</a>).
<BR>In addition to the model function, <I>VF_nonlinfit</I> needs the partial derivatives of Y with respect to all parameters A[ipar], according to your model. If you know them analytically, you should write a function MyDerivs. If you happen to know only some, but not all of the partial derivatives, you may rely on <I><a href="#nonlinfit_">VF_nonlinfit_autoDeriv</a></I> to calculate the unknown derivatives numerically.
</td></tr><tr valign="top"><td>Partial derivatives coded for Pascal/Delphi</td><td>
<font face="courier new">procedure MyDerivs( dYdAi, X:fVector; size, ipar:UInt );
<BR>var i:UInt;
<BR>begin
<BR>&nbsp;&nbsp;case ipar of
<BR>&nbsp;&nbsp;&nbsp;&nbsp;0: begin
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i:=0 to size-1 do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VF_Pelement( dYdAi, i )^ :=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part_derv_of_Y_w_resp_to_A<sub>0</sub>(VF_element( X, i )); end;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;1: begin
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i:=0 to size-1 do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VF_Pelement( dYdAi, i )^ :=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part_derv_of_Y_w_resp_to_A<sub>0</sub>(VF_element( X, i )); end;
<BR>&nbsp;&nbsp;else (* for all derivatives we don't know: *)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#nonlinfit_">VF_nonlinfit_autoDeriv</a>( dYdAi, X, size, ipar );
<BR>&nbsp;&nbsp;end;
<BR>end;</font><BR>
A call to <I>VF_nonlinfit</I> will look like:<BR>
<font face="courier new">VF_nonlinfit( A, AStatus, npars, X, Y, sizex, @MyFunc, @MyDerivs );</font><BR>
Note the address-of operator in front of &quot;MyFunc.&quot; and &quot;MyDerivs&quot;. In Turbo Pascal, both MyFunc and MyDerivs <B>must</B> be compiled with the Force-Far-Calls option {$F+}. In case you do not know any of the partial derivatives, do not define MyDerivs, but call <I>VF_nonlinfit</I> with <I>derivaties</I> = <B>nil</B>:<BR>
<font face="courier new">VF_nonlinfit( A, AStatus, npars, X, Y, sizex, @MyFunc, nil );</font><BR>
<BR>In the weighted variant, <I>VF_nonlinfitwW</I>, the vector <I>InvVar</I> has to contain the inverse of the variances of the individual X-Y data points, and the matrix <I>MCovar</I> will be filled with the covariances of the parameters <I>a<sub>i</sub></I> on output: MCovar<sub>i,j</sub> = covariance( <I>a<sub>i</sub></I>, <I>a<sub>j</sub></I> ).<BR>&nbsp;
</td></tr><tr valign="top"><td>Both C/C++ and Pascal/Delphi:</td><td>
For the many different options controlling nonlinear data-fitting functions, please consult <a href="#chap13_3">Kap.&nbsp;13.3</a>. Helper functions for breaking off excessively long fitting runs and for the monitoring of these often very time-consuming procedures are summarized in <a href="#chap13_5">Kap.&nbsp;13.5</a> and, in the special case of <I>VF_nonlinfit</I>, <a href="#nonlinfit_">described here</a>.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Multi-threading restrictions</td><td>In order to allow the monitoring functions to access intermediate results, these had to be made global. Therefore, only one instance of a given nonlinear fitting function can be active at a time. If the same function would run in two or more parallel threads, they would overwrite each other's intermediate results. Additionally, in the Delphi version, <I>VF_nonlinfit</I> and <I>VF_nonlinfitwW</I> cannot run simultaneously either. The same is true on the <I>VD_</I> and on the <I>VE_</I> level. It is, however, possible, to run <I>VF_nonlinfit</I> and <I>VD_nonlinfit</I> in parallel.
<P>These functions may not be called while the FPU is set to reduced accuracy, or else they might hang in an infinite loop. See <I><a href="FUNCREF.HTM#setFPAccuracy">V_setFPAccuracy</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>in case of success: goodness-of-fit parameter <font face="symbol">c</font><sup>2</sup> (chi-square);<BR>in case of failure: -1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#setNonlinfitOptions">VF_setNonlinfitOptions</a>,&nbsp;&nbsp; <a href="#Mnonlinfit">MF_nonlinfit</a>,&nbsp;&nbsp; <a href="#multiNonlinfit">VF_multiNonlinfit</a>,&nbsp;&nbsp; <a href="#linfit">VF_linfit</a>,&nbsp;&nbsp; <a href="#chap13">Kap.&nbsp;13</a>,&nbsp;&nbsp;FITDEMO*.*</td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="nonlinfit_"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_nonlinfit_...</b></font>
</td><td width="33%"><font size="+1"><b>VD_nonlinfit_...</b></font></td>
<td><font size="+1"><b>VE_nonlinfit_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_nonlinfitwW_...</b></font></td>
<td width="33%"><font size="+1"><b>VD_nonlinfitwW_...</b></font></td>
<td><font size="+1"><b>VE_nonlinfitwW_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._autoDeriv</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getChi2</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getBestValues</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getTestRun</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getTestPar</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getTestDir</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._stop</B></font></td><td></TD></tr></table>
</td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>helper functions for <I><a href="#nonlinfit">VF_nonlinfit</a></I> and <I><a href="#nonlinfit">VF_nonlinfitwW</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void VF_nonlinfit_autoDeriv( fVector dYdAi, fVector X, ui size, unsigned ipar );<BR>
float VF_nonlinfit_getChi2( void );<BR>
void VF_nonlinfit_getBestValues( fVector ABest );<BR>
int VF_nonlinfit_getTestDir( void );<BR>
unsigned VF_nonlinfit_getTestPar( void );<BR>
unsigned VF_nonlinfit_getTestRun( void );<BR>
void VF_nonlinfit_stop( void );</font><BR>
&nbsp;&nbsp;(identical syntax for the <I>VF_nonlinfitwW_...</I> functions)</td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses VFnlfit;<BR>
procedure VF_nonlinfit_autoDeriv( dYdAi, X: fVector; size, ipar:UInt );<BR>
function VF_nonlinfit_getChi2: Single;<BR>
procedure VF_nonlinfit_getBestValues( BestValues: fVector );<BR>
function VF_nonlinfit_getTestDir: Integer;<BR>
function VF_nonlinfit_getTestPar: UInt;<BR>
function VF_nonlinfit_getTestRun: UInt;<BR>
procedure VF_nonlinfit_stop;</font><BR>
&nbsp;&nbsp;(identical syntax for the <I>VF_nonlinfitwW_...</I> functions)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><I>VF_nonlinfit_autoDeriv</I> performs a numerical differentiation of a user-provided y=f(x) model function with respect to the parameter <I>a<sub>ipar</sub></I> of the model. This function can be called only from within a function passed as the argument &quot;derivatives&quot; to <a href="#nonlinfit">VF_nonlinfit</a>. The model function that is differentiated by <I>VF_nonlinfit_autoDeriv</I> is the one passed in the same call to <a href="#nonlinfit">VF_nonlinfit</a> (see that function for details!).<P>
The following functions allow to monitor the progress of a nonlinear fitting operation. They can either be called from within the provided model function or, for multi-thread applications, from a second thread running in parallel to the thread containing the fitting function.<BR>
<I>VF_nonlinfit_getChi2</I> returns the best figure-of-merit (<font face="symbol">c</font><sup>2</sup> or, for robust fits, |<font face="symbol">c</font>|) obtained so far. If you call this function before <I>VF_nonlinfit</I> has had the chance to calculate <font face="symbol">c</font><sup>2</sup>, <I>VF_nonlinfit_getChi2</I> returns -1.0.<P>
<I>VF_nonlinfit_getBestValues</I> stores the best parameters <I>a<sub>i</sub></I> obtained so far into the user-supplied vector <I>ABest</I>.<P>
<I>VF_nonlinfit_getTestDir</I> returns the test direction (+1 for upwards, -1 for downwards) during &quot;breakout&quot; attempts from possible <U>local</U> optima which would otherwise prevent the routine from finally reaching the <U>global</U> optimum (level-of-method greater than 3 specified by <I><a href="#setNonlinfitOptions">VF_setNonlinfitOptions</a></I>).<P>
<I>VF_nonlinfit_getTestPar</I> returns the index of the parameter currently under &quot;breakout&quot; investigation.<P>
<I>VF_nonlinfit_getTestRun</I> returns the index of the current &quot;breakout&quot; test run. For each fitted parameter, one test run is performed. The order in which the parameters are checked is determined internally in such a way as to test the most sensitive parameters first.<P>
<I>VF_nonlinfit_stop</I> makes <I>VF_nonlinfit</I> finish its current Levenberg-Marquardt or Downhill-Simplex cycle, update the output parameters and return. Thereby, long fitting sessions (especially tedious &quot;break-out&quot; attempts) may be broke off without the loss of any data.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap13">Kap.&nbsp;13</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Mnonlinfit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_nonlinfit</b></font>
</td><td width="33%"><font size="+1"><b>MD_nonlinfit</b></font></td>
<td><font size="+1"><b>ME_nonlinfit</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_nonlinfitwW</b></font></td>
<td width="33%"><font size="+1"><b>MD_nonlinfitwW</b></font></td>
<td><font size="+1"><b>ME_nonlinfitwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>fit z=f(x,y) data to a model-function which may be nonlinear in its parameters</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float MF_nonlinfit( fVector A, iVector AStatus, unsigned npars, fVector X, fVector Y, fMatrix MZ, unsigned htZ, unsigned lenZ,<BR>
void (*modelfunc)(fMatrix MZModel, unsigned htZ, unsigned lenZ, fVector X, fVector Y ),<BR>
void (*derivatives)(fMatrix dZdAi, unsigned htZ, unsigned lenZ, fVector X, fVector Y, unsigned ipar) );<P>
float MF_nonlinfitwW( fVector A, fMatrix Covar, iVector AStatus, unsigned npars, fVector X, fVector Y, fMatrix MZ, fMatrix MInvVar, unsigned htZ, unsigned lenZ,<BR>
void (*modelfunc)(fMatrix MZModel, unsigned htZ, unsigned lenZ, fVector X, fVector Y ),<BR>
void (*derivatives)(fMatrix dZdAi, unsigned htZ, unsigned lenZ, fVector X, fVector Y, unsigned ipar) );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFnlfit;<BR>
function MF_nonlinfit( A: fVector; AStatus: iVector; nParameters: UInt; X, Y: fVector; MZ: fMatrix; htZ, lenZ: UInt; ModelFunc, Derivatives: Pointer ): Single;<P>
function MF_nonlinfitwW( A: fVector; Covar: fMatrix; AStatus: iVector; nParameters: UInt; X, Y: fVector; MZ, MInvVar: fMatrix; htZ, lenZ: UInt; ModelFunc, Derivatives: Pointer ): Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The input data X, Y, MZ (and MInvVar) are used to evaluate the parameter array <I>A</I> with <I>npars</I> elements <I>a<sub>i</sub></I> of an arbitrary model function z = f(x,y). 
<P>Arguments:
<table border=0 width="100%">
<tr valign="top"><td>A</td><td>vector of size <I>npars</I>; returns the coefficients</td></tr>
<tr valign="top"><td>Covar</td><td>matrix of dimensions [npars, npars]; returns the covariances of the coefficients</td></tr>
<tr valign="top"><td>AStatus</td><td>vector of size <I>npars</I>; decides which parameters are treated as free or as fixed</td></tr>
<tr valign="top"><td>npars</td><td>total number of parameters</td></tr>
<tr valign="top"><td>X,&nbsp;Y</td><td>vectors of size <I>lenZ</I> and <I>htZ</I>, respectively, spanning the x-y coordinate system of the matrix MZ</td></tr>
<tr valign="top"><td>MZ,&nbsp;MInvVar</td><td>matrices of dimensions [htZ, lenZ], holding the input data and, in the weighted variant, the inverse of their variances</td></tr>
<tr valign="top"><td>modelfunc</td><td>user-defined model function</td></tr>
<tr valign="top"><td>derivatives</td><td>user-defined function, calculating the partial derivatives with respect to all parameters</td></tr>
</table>&nbsp;<BR>
The model function (and, consequently, the vector <I>A</I> as well) may actually contain more parameters than you wish to treat as adjustable. This is why you have to provide an additional vector, <I>AStatus</I>, which contains the necessary information about which parameters are to be held fixed at their input values (AStatus[i] = 0) and which are free (AStatus[i] = 1). All parameters must be initialized in <I>A</I> prior to calling <I>MF_nonlinfit</I>. The better your initial guess of the parameters, the faster <I>MF_nonlinfit</I> shall converge. The argument <I>npars</I> denotes the total number of parameters in <I>A</I> (not only the free parameters!). 
<P>You must provide a model function &quot;modelfunc&quot; which, for given vectors of x and y values, must calculate the corresponding &quot;theoretical&quot; z values. In C/C++, it has to be defined as<BR>
</td></tr><tr valign="top"><td>Model function for C/C++</td><td>
<font face="courier new">void _cdecl MyFunc( fMatrix MZ, unsigned htZ, unsigned lenZ, fVector X, fVector Y )
<BR>{
<BR>&nbsp;&nbsp;for (ui i=0; i&lt;htZ; i++ )
<BR>&nbsp;&nbsp;&nbsp;&nbsp;for (ui j=0; j&lt;lenZ; j++ )
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MZ[i][j] = f( X[j], Y[i] ); 
<BR>}<BR>
f( X[j], Y[i] ) </font>is any arbitrary function, which may be as complicated as you like and your application needs. The only condition is that it have no singularities, at least within the parameter space specified by upper and lower boundaries (see <a href="#chap13_3NONLINFITOPTIONS">NONLINFITOPTIONS</a>).
<BR>In addition to the model function, <I>MF_nonlinfit</I> needs the partial derivatives of MZ with respect to all parameters A[ipar], according to your model. If you know them analytically, you should write a function MyDerivs. If you happen to know only some, but not all of the partial derivatives, you may rely on <I><a href="#Mnonlinfit_">MF_nonlinfit_autoDeriv</a></I> to calculate the unknown derivatives numerically.
</td></tr><tr valign="top"><td>Partial derivatives coded for C/C++</td><td>
<font face="courier new">void _cdecl MyDerivs( fMatrix dZdAi, unsigned htZ, unsigned lenZ, fVector X, fVector Y, unsigned ipar )
<BR>{
<BR>&nbsp;&nbsp;ui i;
<BR>&nbsp;&nbsp;switch( ipar )
<BR>&nbsp;&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;case 0: 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;for(i=0; i&lt;htZ; i++ ) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for( j=0; j&lt;lenZ; j++ )
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dZdAi[i][j] = part_derv_MZ_w_resp_to_A<sub>0</sub>( X[j], Y[i] );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;case 1: 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;for(i=0; i&lt;htZ; i++ ) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for( j=0; j&lt;lenZ; j++ )
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dZdAi[i][j] = part_derv_MZ_w_resp_to_A<sub>1</sub>( X[j], Y[i] );
<BR>&nbsp;&nbsp;&nbsp;&nbsp;break;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;default: /* for all derivatives we don't know: */
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Mnonlinfit_">MF_nonlinfit_autoDeriv</a>( dZdAi, htZ, lenZ, X, Y, ipar);
<BR>&nbsp;&nbsp;}
<BR>}</font><BR>
A call to <I>MF_nonlinfit</I> will look like:<BR>
<font face="courier new">MF_nonlinfit( A, AStatus, npars, X, Y, MZ, htZ, lenZ, MyFunc, MyDerivs );</font><BR>
In case you do not know any of the partial derivatives, do not define MyDerivs, but call <I>MF_nonlinfit</I> with <I>derivaties</I> = NULL:<BR>
<font face="courier new">MF_nonlinfit( A, AStatus, npars, X, Y, MZ, htZ, lenZ, MyFunc, NULL );</font><BR>&nbsp;
</td></tr><tr valign="top"><td>Model function for Pascal/Delphi</td><td>
In Pascal/Delphi, the model function has to be defined as<BR>
<font face="courier new">procedure MyFunc( MZ:fMatrix; htZ, lenZ:UInt; X, Y:fVector );
<BR>var i, j:UInt;
<BR>begin
<BR>&nbsp;&nbsp;for i:=0 to htZ-1 do
<BR>&nbsp;&nbsp;&nbsp;&nbsp;for j:=0 to lenZ-1 do
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MF_Pelement( MZ, htZ, lenZ, i, j )^ := 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f( VF_element( X, j ), VF_element( Y, i ) );
<BR>end;<BR>
f( X<sub>j</sub>, Y<sub>i</sub> ) </font>is any arbitrary function, which may be as complicated as you like and your application needs. The only condition is that it have no singularities, at least within the parameter space specified by upper and lower boundaries (see <a href="#chap13_3NONLINFITOPTIONS">NONLINFITOPTIONS</a>).
<BR>In addition to the model function, <I>MF_nonlinfit</I> needs the partial derivatives of MZ with respect to all parameters A[ipar], according to your model. If you know them analytically, you should write a function MyDerivs. If you happen to know only some, but not all of the partial derivatives, you may rely on <I><a href="#Mnonlinfit_">MF_nonlinfit_autoDeriv</a></I> to calculate the unknown derivatives numerically.
</td></tr><tr valign="top"><td>Partial derivatives coded for Pascal/Delphi</td><td>
<font face="courier new">procedure MyDerivs( dZdAi:fMatrix; htZ, lenZ:UInt; X, Y:fVector; ipar:UInt );
<BR>var i, j:UInt;
<BR>begin
<BR>&nbsp;&nbsp;case ipar of
<BR>&nbsp;&nbsp;&nbsp;&nbsp;0: begin
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i:=0 to htZ-1 do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for j:=0 to lenZ-1 do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MF_Pelement( dZdAi, htZ, lenZ, i, j )^ :=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part_derv_MZ_w_resp_to_A<sub>0</sub>(VF_element( X, j ), VF_element( Y, i )); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;1: begin
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i:=0 to htZ-1 do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for j:=0 to lenZ-1 do 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MF_Pelement( dZdAi, htZ, lenZ, i, j )^ :=<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;part_derv_MZ_w_resp_to_A<sub>1</sub>(VF_element( X, j ), VF_element( Y, i )); 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end;
<BR>&nbsp;&nbsp;else (* for all derivatives we don't know: *)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Mnonlinfit_">MF_nonlinfit_autoDeriv</a>( dZdAi, htZ, lenZ, X, Y, ipar );
<BR>&nbsp;&nbsp;end;
<BR>end;</font><BR>
A call to <I>MF_nonlinfit</I> will look like:<BR>
<font face="courier new">MF_nonlinfit( A, AStatus, npars, MZ, htZ, lenZ, X, Y, @MyFunc, @MyDerivs );</font><BR>
Note the address-of operator in front of &quot;MyFunc.&quot; and &quot;MyDerivs&quot;. In Turbo Pascal, both MyFunc and MyDerivs <B>must</B> be compiled with the Force-Far-Calls option {$F+}. In case you do not know any of the partial derivatives, do not define MyDerivs, but call <I>MF_nonlinfit</I> with <I>derivaties</I> = <B>nil</B>:<BR>
<font face="courier new">MF_nonlinfit( A, AStatus, npars, MZ, htZ, lenZ, X, Y, @MyFunc, nil );</font><BR>
<BR>In the weighted variant, <I>MF_nonlinfitwW</I>, the matrix <I>MInvVar</I> has to contain the inverse of the variances of the individual X-Y-Z data points, and the matrix <I>MCovar</I> will be filled with the covariances of the parameters <I>a<sub>i</sub></I> on output: MCovar<sub>i,j</sub> = covariance( <I>a<sub>i</sub></I>, <I>a<sub>j</sub></I> ).<BR>&nbsp;
</td></tr><tr valign="top"><td>Both C/C++ and Pascal/Delphi:</td><td>
For the many different options controlling nonlinear data-fitting functions, please consult <a href="#chap13_3">Kap.&nbsp;13.3</a>. Helper functions for breaking off excessively long fitting runs and for the monitoring of these often very time-consuming procedures are summarized in <a href="#chap13_5">Kap.&nbsp;13.5</a> and, in the special case of <I>MF_nonlinfit</I>, <a href="#Mnonlinfit_">described here</a>.
</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Multi-threading restrictions</td><td>In order to allow the monitoring functions to access intermediate results, these had to be made global. Therefore, only one instance of a given nonlinear fitting function can be active at a time. If the same function would run in two or more parallel threads, they would overwrite each other's intermediate results. Additionally, in the Delphi version, <I>MF_nonlinfit</I> and <I>MF_nonlinfitwW</I> cannot run simultaneously either. The same is true on the <I>VD_</I> and on the <I>VE_</I> level. It is, however, possible, to run <I>MF_nonlinfit</I> and <I>MD_nonlinfit</I> in parallel.
<P>These functions may not be called while the FPU is set to reduced accuracy, or else they might hang in an infinite loop. See <I><a href="FUNCREF.HTM#setFPAccuracy">V_setFPAccuracy</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>in case of success: goodness-of-fit parameter <font face="symbol">c</font><sup>2</sup> (chi-square);<BR>in case of failure: -1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#setNonlinfitOptions">VF_setNonlinfitOptions</a>,&nbsp;&nbsp; <a href="#nonlinfit">VF_nonlinfit</a>,&nbsp;&nbsp; <a href="#MmultiNonlinfit">MF_multiNonlinfit</a>,&nbsp;&nbsp; <a href="#linfit">MF_linfit</a>,&nbsp;&nbsp; <a href="#chap13">Kap.&nbsp;13</a>,&nbsp;&nbsp;FITDEMO*.*</td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Mnonlinfit_"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_nonlinfit_...</b></font>
</td><td width="33%"><font size="+1"><b>MD_nonlinfit_...</b></font></td>
<td><font size="+1"><b>ME_nonlinfit_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_nonlinfitwW_...</b></font></td>
<td width="33%"><font size="+1"><b>MD_nonlinfitwW_...</b></font></td>
<td><font size="+1"><b>ME_nonlinfitwW_...</b></font></td></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._autoDeriv</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getChi2</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getBestValues</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getTestRun</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getTestPar</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._getTestDir</B></font></td><td></TD></tr></table>
<table width="100%"><tr valign="TOP"><td width="33%"></TD>
<td width="33%"><font size="+1"><B>..._stop</B></font></td><td></TD></tr></table>
</td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>helper functions for <I><a href="#Mnonlinfit">MF_nonlinfit</a></I> and <I><a href="#Mnonlinfit">MF_nonlinfitwW</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_nonlinfit_autoDeriv( fMatrix dZdAi, unsigned htZ, unsigned lenZ, fVector X, fVector Y, unsigned ipar );<BR>
float MF_nonlinfit_getChi2( void );<BR>
void MF_nonlinfit_getBestValues( fVector ABest );<BR>
unsigned MF_nonlinfit_getTestRun( void );<BR>
unsigned MF_nonlinfit_getTestPar( void );<BR>
int MF_nonlinfit_getTestDir( void );<BR>
void MF_nonlinfit_stop( void );</font><BR>
&nbsp;&nbsp;(identical syntax for the <I>MF_nonlinfitwW_...</I> functions)</td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFnlfit;<BR>
procedure MF_nonlinfit_autoDeriv( dZdAi:fMatrix; htZ, lenZ:UInt; X, Y:fVector; ipar: UInt );
function MF_nonlinfit_getChi2: Single;
procedure MF_nonlinfit_getBestValues( BestValues: fVector );
function MF_nonlinfit_getTestRun: UInt;
function MF_nonlinfit_getTestPar: UInt;
function MF_nonlinfit_getTestDir: Integer;
procedure MF_nonlinfit_stop;</font><BR>
&nbsp;&nbsp;(identical syntax for the <I>MF_nonlinfitwW_...</I> functions)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><I>MF_nonlinfit_autoDeriv</I> performs a numerical differentiation of a user-provided z=f(x,y) model function with respect to the parameter <I>a<sub>ipar</sub></I> of the model. This function can be called only from within a function passed as the argument &quot;derivatives&quot; to <a href="#Mnonlinfit">MF_nonlinfit</a>. The model function that is differentiated by <I>MF_nonlinfit_autoDeriv</I> is the one passed in the same call to <a href="#nonlinfit">MF_nonlinfit</a> (see that function for details!).<P>
The following functions allow to monitor the progress of a nonlinear fitting operation. They can either be called from within the provided model function or, for multi-thread applications, from a second thread running in parallel to the thread containing the fitting function.<BR>
<I>MF_nonlinfit_getChi2</I> returns the best figure-of-merit (<font face="symbol">c</font><sup>2</sup> or, for robust fits, |<font face="symbol">c</font>|) obtained so far. If you call this function before <I>MF_nonlinfit</I> has had the chance to calculate <font face="symbol">c</font><sup>2</sup>, <I>MF_nonlinfit_getChi2</I> returns -1.0.<P>
<I>MF_nonlinfit_getBestValues</I> stores the best parameters <I>a<sub>i</sub></I> obtained so far into the user-supplied vector <I>ABest</I>.<P>
<I>MF_nonlinfit_getTestDir</I> returns the test direction (+1 for upwards, -1 for downwards) during &quot;breakout&quot; attempts from possible <U>local</U> optima which would otherwise prevent the routine from finally reaching the <U>global</U> optimum (level-of-method greater than 3 specified by <I><a href="#setNonlinfitOptions">VF_setNonlinfitOptions</a></I>).<P>
<I>MF_nonlinfit_getTestPar</I> returns the index of the parameter currently under &quot;breakout&quot; investigation.<P>
<I>MF_nonlinfit_getTestRun</I> returns the index of the current &quot;breakout&quot; test run. For each fitted parameter, one test run is performed. The order in which the parameters are checked is determined internally in such a way as to test the most sensitive parameters first.<P>
<I>MF_nonlinfit_stop</I> makes <I>MF_nonlinfit</I> finish its current Levenberg-Marquardt or Downhill-Simplex cycle, update the output parameters and return. Thereby, long fitting sessions (especially tedious &quot;break-out&quot; attempts) may be broke off without the loss of any data.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap13">Kap.&nbsp;13</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="outerprod"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_outerprod</b></font>
</td><td width="33%"><font size="+1"><b>MD_outerprod</b></font></td>
<td><font size="+1"><b>ME_outerprod</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_outerprod</b></font></td>
<td width="33%"><font size="+1"><b>MCD_outerprod</b></font></td>
<td><font size="+1"><b>MCE_outerprod</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>formation of a matrix by the &quot;outer product&quot; of two vectors</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_outerprod( fMatrix MA, fVector X, fVector Y, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_outerprod( MA:fMatrix; X, Y:fVector; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,j</sub> = X<sub>i</sub> * Y<sub>j</sub></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#VmulM">VF_mulM</a>,&nbsp;&nbsp; <a href="#chap3">Kap.&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Parzen"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Parzen</b></font>
</td><td width="33%"><font size="+1"><b>MD_Parzen</b></font></td>
<td><font size="+1"><b>ME_Parzen</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>two-dimensional Parzen window for spatial frequency analysis</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Parzen( fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Parzen( MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,j</sub> = (1 - |(i - 0.5*(ht - 1)) / 0.5*(ht + 1)|) * (1 - |(j - 0.5*(len - 1)) / 0.5*(len + 1)|)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Hanning">MF_Hanning</a>,&nbsp;&nbsp; <a href="#Welch">MF_Welch</a>,&nbsp;&nbsp; <a href="#spectrum">MF_spectrum</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Pelement"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Pelement</b></font>
</td><td width="33%"><font size="+1"><b>MD_Pelement</b></font></td>
<td><font size="+1"><b>ME_Pelement</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Pelement</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Pelement</b></font></td>
<td><font size="+1"><b>MCE_Pelement</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>get pointer to a matrix element</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float * MF_Pelement( fMatrix X, unsigned ht, unsigned len, unsigned m, unsigned n );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_Pelement( MA:fMatrix; ht, len, m, n:UInt ): PSingle;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A pointer to the element MA<sub>m,n</sub> is returned.
<BR>This function is needed to access elements of dynamically allocated matrices, for which older versions of Borland C++ had a pointer arithmetics bug, and Pascal/Delphi - unlike C - does not provide an own mechanism at all. Writing a matrix element through this function, use the dereferenced-pointer syntax:</td></tr><tr valign="TOP">
<td>C/C++</td><td><font face="courier new">*MF_Pelement( MA, ht, len, m, n ) = 3.5;</font></td></tr><tr valign="TOP">
<td>Pascal/Delphi</td><td><font face="courier new">MF_Pelement( MA, ht, len, m, n )^ := 3.5;</font>
<P>Read-only access to matrix elements is provided by the related function, <I><a href="#element">MF_element</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>pointer to the matrix element MA<sub>m,n</sub></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#element">MF_element</a>,&nbsp;&nbsp; <a href="#chap2">Kap.&nbsp;2</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="polyfit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_polyfit</b></font>
</td><td width="33%"><font size="+1"><b>VD_polyfit</b></font></td>
<td><font size="+1"><b>VE_polyfit</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_polyfitwW</b></font></td>
<td width="33%"><font size="+1"><b>VD_polyfitwW</b></font></td>
<td><font size="+1"><b>VE_polyfitwW</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>fitting of one X-Y data set to a polynomial</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void VF_polyfit( fVector A, unsigned deg, fVector X, fVector Y, ui sizex );<BR>
void VF_polyfitwW( fVector A, fMatrix Covar, unsigned deg, fVector X, fVector Y, fVector InvVar, ui sizex );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure VF_polyfit( A:fVector; deg:UInt; X, Y:fVector; sizex:UInt );<BR>
procedure VF_polyfitwW( A:fVector; Covar:fMatrix; deg:UInt; X, Y, InvVar:fVector; sizex:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The input data are used to determine the coefficients <I>a<sub>i</sub></I> of a polynomial<BR>
<font face="courier new">P<sub>i</sub> = a<sub>0</sub> + a<sub>1</sub>X<sub>i</sub> + a<sub>2</sub>X<sub>i</sub><sup>2</sup> ... a<sub>n</sub>X<sub>i</sub><sup>n</sup></font><BR>
so as to minimize the deviation between the &quot;theoretical&quot; P<sub>i</sub> values, calculated by the polynomial, and the actual Y<sub>i</sub> values. To be more precise, the figure-of-merit chi-square,<BR>
<font face="courier new"><font face="symbol">c</font><sup>2</sup> = sum( 1/<font face="symbol">s</font><sub>i</sub><sup>2</sup> * (P<sub>i</sub> - Y<sub>i</sub>)<sup>2</sup> )</font><BR>
is minimized. In the weighted variant, <I>VF_polyfitwW</I>, 1/<font face="symbol">s</font><sub>i</sub><sup>2</sup> has to be provided as the vector <I>InvVar</I>. In the non-weighted variant, all <font face="symbol">s</font><sub>i</sub> are assumed as 1.0.
<P>Arguments:
<table border=0 width="100%">
<tr valign="top"><td>A</td><td>vector of size deg+1; returns the coefficients</td></tr>
<tr valign="top"><td>Covar</td><td>matrix of dimensions [deg+1, deg+1]; returns the covariances of the coefficients</td></tr>
<tr valign="top"><td>deg</td><td>the degree of the fitting polynomial</td></tr>
<tr valign="top"><td>X,&nbsp;Y,&nbsp;InvVar</td><td>vectors of size sizex, holding the input data</td></tr>
</table></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="FUNCREF.HTM#linregress">VF_linregress</a>,&nbsp;&nbsp; <a href="#linfit">VF_linfit</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#chi2">VF_chi2</a>,&nbsp;&nbsp; <a href="#chap13">Kap.&nbsp;13</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="print"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_print</b></font>
</td><td width="33%"><font size="+1"><b>MD_print</b></font></td>
<td><font size="+1"><b>ME_print</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_print</b></font></td>
<td width="33%"><font size="+1"><b>MCD_print</b></font></td>
<td><font size="+1"><b>MCE_print</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>print a matrix in ASCII format to <I>stdout</I>, assuming a linewidth of 80 characters (DOS and 16-bit Windows with EasyWin only)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_print( fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_print( MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The matrix MA is written to stream. Each line corresponds to one row of the matrix. The lines are numbered. The linewidth is assumed to be 80 characters. If this linewidth is too small to write all columns, rows are cut off.
<BR>Cartesian complex numbers are printed in braces, with the real and imaginary parts separated by a komma: {Re, Im}.
<P>In contrast to <I><a href="#write">MF_write</a></I>, it is not possible to override the automatic choice of the format used for printing. The number of digits per element is determined by the available space, which depends in turn on the parameter len.
<P>In contrast to <I><a href="#cprint">MF_cprint</a></I>, no paging is performed.
<BR>This family of functions is available under Windows only in connection with EasyWin, and should not be used within TurboVision programs.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="FUNCREF.HTM#print">VF_print</a>,&nbsp;&nbsp; <a href="#cprint">MF_cprint</a>,&nbsp;&nbsp; <a href="#fprint">MF_fprint</a>,&nbsp;&nbsp; <a href="#chap14">Kap.&nbsp;14</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="read"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_read</b></font>
</td><td width="33%"><font size="+1"><b>MD_read</b></font></td>
<td><font size="+1"><b>ME_read</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_read</b></font></td>
<td width="33%"><font size="+1"><b>MCD_read</b></font></td>
<td><font size="+1"><b>MCE_read</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>read a matrix in ASCII format from a stream</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_read( fMatrix X, unsigned ht, unsigned len, FILE *stream );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
{Delphi version:}<BR>
&nbsp;&nbsp;procedure MF_read( MA:fMatrix; ht, len:UInt; var Stream:TextFile );<BR>
{Turbo Pascal version:}<BR>
&nbsp;&nbsp;procedure MF_read( MA:fMatrix; ht, len:UInt; var Stream:Text );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The matrix MA of ht*len elements is read in ASCII format from <I>stream</I>. Normally, this function will be used to import matrices from a program which cannot store numbers in machine format. It can also be used to retrieve matrices previously stored by <I><a href="#write">MF_write</a></I>. For storing and retrieving intermediate results, however, the function pair <I><a href="#store">MF_store</a></I> / <I><a href="#recall">MF_recall</a></I> is to be preferred over <I><a href="#write">MF_write</a></I> / <I>MF_read</I> (see <I><a href="#write">MF_write</a></I>).
<P><u>Cartesian complex versions:</u>
<BR>Real und imaginary parts may, but need not, be enclosed in braces { } or brackets ( ). However, you must be consequent: Either all or no element may be written with braces or brackets.
<BR>A komma may (but need not) separate the two parts. The imaginary part must always be explicitly specified, even if it is zero.
<BR>Examples for legal formats are:
<BR>0.3 0.5&nbsp;&nbsp;&nbsp;&nbsp;(neither braces nor separating komma)
<BR>0.3, 0.5&nbsp;&nbsp;&nbsp;&nbsp;(no braces; separating komma)
<BR>{0.3 0.5}&nbsp;&nbsp;&nbsp;&nbsp;(braces; no separating komma)
<BR>(0.3, 0.5)&nbsp;&nbsp;&nbsp;&nbsp;(brackets and separating komma)
</td></tr><tr valign="TOP">
<td>C/C++ specific:</td><td> The entries to be read must be separated by whitespace (' ', '\n', or '\t'). Additionally, one (!) &quot;non-whitespace&quot; character is tolerated after each entry, if it follows directly after the last digit. After it, there must be one or more whitespace characters.
</td></tr><tr valign="TOP">
<td>Pascal/Delphi specific:</td><td> The entries to be read must be separated by whitespace (' ', #13, or #9).
<P>Whereas the C/C++ version of these functions follows the conventions of the C functions <i>strtod</i>, <i>strtol</i>, etc., the Pascal/Delphi version has to follow the rules applying to the Pascal/Delphi function <i>Read</i>. This makes the Pascal/Delphi version much less flexible than the C version:
<BR>- no separation characters allowed other than ' ' and #9,
<BR>- no automatic truncation of overflowing numbers</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td><u>C/C++:</u>
<BR>Overflowing numbers are silently truncated to &#177;HUGE_VAL.
<BR><u>Pascal/Delphi:</u>
<BR>Overflowing numbers or numbers otherwise not conforming to the format requirements lead to an I/O error.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#write">MF_write</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#nread">VF_nread</a>,&nbsp;&nbsp; <a href="#store">MF_store</a>,&nbsp;&nbsp; <a href="#recall">MF_recall</a>,&nbsp;&nbsp; <a href="#chap14">Kap.&nbsp;14</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="recall"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_recall</b></font>
</td><td width="33%"><font size="+1"><b>MD_recall</b></font></td>
<td><font size="+1"><b>ME_recall</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_recall</b></font></td>
<td width="33%"><font size="+1"><b>MCD_recall</b></font></td>
<td><font size="+1"><b>MCE_recall</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Read a matrix in binary format from a stream</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_recall( fMatrix MA, unsigned ht, unsigned len, FILE *stream);</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_recall( MA:fMatrix; ht, len:UInt; var Stream:FILE );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The matrix MA of ht*len elements is read from stream in binary format. Normally, these functions are used to retrieve data stored by the respective function of the <I><a href="#store">MF_store</a></I> family.
<P>In C/C++, matrices are stored by rows, where as Pascal/Delphi and Fortran work with matrices stored by columns. This means that you will get the transpose of a matrix stored by a C/C++ program, if you read it with a Pascal/Delphi program, and <I>vice versa</I>. In this case, simply call<BR>
<font face="courier new">MF_transpose( MA, MA, ht, len );</font>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#store">MF_store</a>,&nbsp;&nbsp; <a href="#chap14">Kap.&nbsp;14</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_addC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_addC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_addC</b></font></td>
<td><font size="+1"><b>ME_Row_addC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_addC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_addC</b></font></td>
<td><font size="+1"><b>MCE_Row_addC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>add a constant to all elements of one row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_addC( fMatrix MA, unsigned ht, unsigned len, unsigned iRow, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_addC( MA:fMatrix; ht, len, iRow:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> += C,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_addC">MF_Col_addC</a>,&nbsp;&nbsp; <a href="#Dia_addC">MF_Dia_addC</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_addV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_addV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_addV</b></font></td>
<td><font size="+1"><b>ME_Row_addV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_addV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_addV</b></font></td>
<td><font size="+1"><b>MCE_Row_addV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise addition of one row and a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_addV( fMatrix MA, unsigned ht, unsigned len, unsigned iRow, fVector X );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_addV( MA:fMatrix; ht, len, iRow:UInt; X:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> += X<sub>i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_addV">MF_Col_addV</a>,&nbsp;&nbsp; <a href="#Dia_addV">MF_Dia_addV</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_delete"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_delete</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_delete</b></font></td>
<td><font size="+1"><b>ME_Row_delete</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_delete</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_delete</b></font></td>
<td><font size="+1"><b>MCE_Row_delete</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>delete one row from a matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_delete( fMatrix MB, fMatrix MA, unsigned htA, unsigned lenA, unsigned iRow );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_delete( MB, MA:fMatrix; htA, lenA, iRow:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MB<sub>i,j</sub> = MA<sub>i,j</sub>,&nbsp;&nbsp;i=0,...,iRow-1,&nbsp;&nbsp;j=0,...,len-1<BR>
MB<sub>i,j</sub> = MA<sub>i+1,j</sub>,&nbsp;&nbsp;i=iRow,...,htA-2,&nbsp;&nbsp;j=0,...,lenA-1<BR>
The parameters htA and lenA refer to the <U>input</U> matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Row_insert">MF_Row_insert</a>,&nbsp;&nbsp; <a href="#Col_delete">MF_Col_delete</a>,&nbsp;&nbsp; <a href="#chap5">Kap.&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_divC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_divC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_divC</b></font></td>
<td><font size="+1"><b>ME_Row_divC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_divC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_divC</b></font></td>
<td><font size="+1"><b>MCE_Row_divC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>divide all elements of one row by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_divC( fMatrix MA, unsigned ht, unsigned len, unsigned iRow, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_divC( MA:fMatrix; ht, len, iRow:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> /= C,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_divC">MF_Col_divC</a>,&nbsp;&nbsp; <a href="#Dia_divC">MF_Dia_divC</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_divrC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_divrC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_divrC</b></font></td>
<td><font size="+1"><b>ME_Row_divrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_divrC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_divrC</b></font></td>
<td><font size="+1"><b>MCE_Row_divrC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>reverse division: divide a constant by all elements of one row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_divrC( fMatrix MA, unsigned ht, unsigned len, unsigned iRow, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_divrC( MA:fMatrix; ht, len, iRow:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> = C / MA<sub>iRow,i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_divrC">MF_Col_divrC</a>,&nbsp;&nbsp; <a href="#Dia_divrC">MF_Dia_divrC</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_divrV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_divrV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_divrV</b></font></td>
<td><font size="+1"><b>ME_Row_divrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_divrV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_divrV</b></font></td>
<td><font size="+1"><b>MCE_Row_divrV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise reverse division: divide a vector by one row of a matrix, storing the result back into the row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_divrV( fMatrix MA, unsigned ht, unsigned len, unsigned iRow, fVector X );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_divrV( MA:fMatrix; ht, len, iRow:UInt; X:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> = X<sub>i</sub> / MA<sub>iRow,i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_divrV">MF_Col_divrV</a>,&nbsp;&nbsp; <a href="#Dia_divrV">MF_Dia_divrV</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_divV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_divV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_divV</b></font></td>
<td><font size="+1"><b>ME_Row_divV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_divV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_divV</b></font></td>
<td><font size="+1"><b>MCE_Row_divV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise division of one row of a matrix by a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_divV( fMatrix MA, unsigned ht, unsigned len, unsigned iRow, fVector X );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_divV( MA:fMatrix; ht, len, iRow:UInt; X:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> /= X<sub>i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_divV">MF_Col_divV</a>,&nbsp;&nbsp; <a href="#Dia_divV">MF_Dia_divV</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_equ0"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_equ0</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_equ0</b></font></td>
<td><font size="+1"><b>ME_Row_equ0</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_equ0</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_equ0</b></font></td>
<td><font size="+1"><b>MCE_Row_equ0</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>initialize all elements of one row with zero</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_equ0( fMatrix MA, unsigned ht, unsigned len, unsigned iRow );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_equ0( MA:fMatrix; ht, len, iRow:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> = 0,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_equ0">MF_Col_equ0</a>,&nbsp;&nbsp; <a href="#Dia_equ0">MF_Dia_equ0</a>,&nbsp;&nbsp; <a href="#Row_equC">MF_Row_equC</a>,&nbsp;&nbsp; <a href="#chap3">Kap.&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_equC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_equC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_equC</b></font></td>
<td><font size="+1"><b>ME_Row_equC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_equC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_equC</b></font></td>
<td><font size="+1"><b>MCE_Row_equC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>initialize all elements of one row with a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_equC( fMatrix MA, unsigned ht, unsigned len, unsigned iRow, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_equC( MA:fMatrix; ht, len, iRow:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> = C,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_equC">MF_Col_equC</a>,&nbsp;&nbsp; <a href="#Dia_equC">MF_Dia_equC</a>,&nbsp;&nbsp; <a href="#Row_equ0">MF_Row_equ0</a>,&nbsp;&nbsp; <a href="#chap3">Kap.&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_equV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_equV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_equV</b></font></td>
<td><font size="+1"><b>ME_Row_equV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_equV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_equV</b></font></td>
<td><font size="+1"><b>MCE_Row_equV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>copy a vector into one row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_equV( fMatrix MA, unsigned ht, unsigned len, unsigned iRow, fVector X );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_equV( MA:fMatrix; ht, len, iRow:UInt; X:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> = X<sub>i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_equV">MF_Col_equV</a>,&nbsp;&nbsp; <a href="#Dia_equV">MF_Dia_equV</a>,&nbsp;&nbsp; <a href="#Row_equC">MF_Row_equC</a>,&nbsp;&nbsp; <a href="#chap3">Kap.&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_extract"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_extract</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_extract</b></font></td>
<td><font size="+1"><b>ME_Row_extract</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_extract</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_extract</b></font></td>
<td><font size="+1"><b>MCE_Row_extract</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>copy one row into a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_extract( fVector Y, fMatrix MA, unsigned ht, unsigned len, unsigned iRow );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_extract( Y:fVector; MA:fMatrix; ht, len, iRow:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>X<sub>i</sub> = MA<sub>iRow,i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Row_equV">MF_Row_equV</a>,&nbsp;&nbsp; <a href="#Row_insert">MF_Row_insert</a>&nbsp;&nbsp;<a href="#chap5">Kap.&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_insert"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_insert</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_insert</b></font></td>
<td><font size="+1"><b>ME_Row_insert</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_insert</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_insert</b></font></td>
<td><font size="+1"><b>MCE_Row_insert</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>augment a matrix by insertion of one row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_insert( fMatrix MB, fMatrix MA, unsigned htB, unsigned lenB, unsigned iRow, fVector X );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_insert( MB, MA:fMatrix; htB, lenB, iRow:UInt; X:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MB<sub>i,j</sub> = MA<sub>i,j</sub>,&nbsp;&nbsp;i=0,...,iRow-1,&nbsp;&nbsp;j=0,...,len-1<BR>
MB<sub>iRow,j</sub> = X<sub>j</sub>,&nbsp;&nbsp;j=0,...,lenB-1<BR>
MB<sub>i,j</sub> = MA<sub>i-1,j</sub>,&nbsp;&nbsp;i=iRow,...,htB-1,&nbsp;&nbsp;j=0,...,lenB-1<BR>
The parameters htB and lenB refer to the <U>output</U> matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Row_delete">MF_Row_delete</a>,&nbsp;&nbsp; <a href="#chap5">Kap.&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_mulC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_mulC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_mulC</b></font></td>
<td><font size="+1"><b>ME_Row_mulC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_mulC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_mulC</b></font></td>
<td><font size="+1"><b>MCE_Row_mulC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply all elements of one row by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_mulC( fMatrix MA, unsigned ht, unsigned len, unsigned iRow, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_mulC( MA:fMatrix; ht, len, iRow:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> *= C,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_mulC">MF_Col_mulC</a>,&nbsp;&nbsp; <a href="#Dia_mulC">MF_Dia_mulC</a>,&nbsp;&nbsp; <a href="#Row_mulV">MF_Row_mulV</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_mulV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_mulV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_mulV</b></font></td>
<td><font size="+1"><b>ME_Row_mulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_mulV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_mulV</b></font></td>
<td><font size="+1"><b>MCE_Row_mulV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise multiplication of one row and a vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_mulV( fMatrix MA, unsigned ht, unsigned len, unsigned iRow, fVector X );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_mulV( MA:fMatrix; ht, len, iRow:UInt; X:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> *= X<sub>i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_mulV">MF_Col_mulV</a>,&nbsp;&nbsp; <a href="#Dia_mulV">MF_Dia_mulV</a>,&nbsp;&nbsp; <a href="#Row_divV">MF_Row_divV</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_subC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_subC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_subC</b></font></td>
<td><font size="+1"><b>ME_Row_subC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_subC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_subC</b></font></td>
<td><font size="+1"><b>MCE_Row_subC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>subtract a constant from all elements of one row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_subC( fMatrix MA, unsigned ht, unsigned len, unsigned iRow, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_subC( MA:fMatrix; ht, len, iRow:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> -= C,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Col_subC">MF_Col_subC</a>,&nbsp;&nbsp; <a href="#Dia_subC">MF_Dia_subC</a>,&nbsp;&nbsp; <a href="#Row_subV">MF_Row_subV</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_subrC"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_subrC</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_subrC</b></font></td>
<td><font size="+1"><b>ME_Row_subrC</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_subrC</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_subrC</b></font></td>
<td><font size="+1"><b>MCE_Row_subrC</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>reverse subtraction: a constant minus one row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_subrC( fMatrix MA, unsigned ht, unsigned len, unsigned iRow, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_subrC( MA:fMatrix; ht, len, iRow:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> = C - MA<sub>iRow,i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Row_subC">MF_Row_subC</a>,&nbsp;&nbsp; <a href="#Col_subrC">MF_Col_subrC</a>,&nbsp;&nbsp; <a href="#Dia_subrC">MF_Dia_subrC</a>,&nbsp;&nbsp; <a href="#Row_subV">MF_Row_subV</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_subrV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_subrV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_subrV</b></font></td>
<td><font size="+1"><b>ME_Row_subrV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_subrV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_subrV</b></font></td>
<td><font size="+1"><b>MCE_Row_subrV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise reverse subtraction: subtract one row from a vector, storing the result back into the row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_subrV( fMatrix MA, unsigned ht, unsigned len, unsigned iRow, fVector X );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_subrV( MA:fMatrix; ht, len, iRow:UInt; X:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> = X<sub>i</sub> - MA<sub>iRow,i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Row_subV">MF_Row_subV</a>,&nbsp;&nbsp; <a href="#Col_subrV">MF_Col_subrV</a>,&nbsp;&nbsp; <a href="#Dia_subrV">MF_Dia_subrV</a>,&nbsp;&nbsp; <a href="#Row_addV">MF_Row_addV</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Row_subV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Row_subV</b></font>
</td><td width="33%"><font size="+1"><b>MD_Row_subV</b></font></td>
<td><font size="+1"><b>ME_Row_subV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Row_subV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Row_subV</b></font></td>
<td><font size="+1"><b>MCE_Row_subV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise subtraction of a vector from one row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Row_subV( fMatrix MA, unsigned ht, unsigned len, unsigned iRow, fVector X );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Row_subV( MA:fMatrix; ht, len, iRow:UInt; X:fVector );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>iRow,i</sub> -= X<sub>i</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Row_subC">MF_Row_subC</a>,&nbsp;&nbsp; <a href="#Col_subV">MF_Col_subV</a>,&nbsp;&nbsp; <a href="#Dia_subV">MF_Dia_subV</a>,&nbsp;&nbsp; <a href="#Row_subrV">MF_Row_subrV</a>,&nbsp;&nbsp; <a href="#chap6">Kap.&nbsp;6</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_absmax"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_absmax</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_absmax</b></font></td>
<td><font size="+1"><b>ME_Rows_absmax</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_absmax</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_absmax</b></font></td>
<td><font size="+1"><b>MCE_Rows_absmax</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>store the absolute maxima of all individual rows in a column vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_absmax( fVector Y, fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_absmax( Y:fVector; MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The maximum absolute value of each row <I>i</I> is stored as the element Y<sub>i</sub> for i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_max">MF_Rows_max</a>,&nbsp;&nbsp; <a href="#Rows_absmin">MF_Rows_absmin</a>,&nbsp;&nbsp; <a href="#Cols_absmax">MF_Cols_absmax</a>,&nbsp;&nbsp; <a href="#Dia_absmax">MF_Dia_absmax</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_absmin"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_absmin</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_absmin</b></font></td>
<td><font size="+1"><b>ME_Rows_absmin</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_absmin</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_absmin</b></font></td>
<td><font size="+1"><b>MCE_Rows_absmin</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>store the absolute minima of all individual rows in a column vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_absmin( fVector Y, fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_absmin( Y:fVector; MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The minimum absolute value of each row <I>i</I> is stored as the element Y<sub>i</sub> for i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_min">MF_Rows_min</a>,&nbsp;&nbsp; <a href="#Rows_absmax">MF_Rows_absmax</a>,&nbsp;&nbsp; <a href="#Cols_absmin">MF_Cols_absmin</a>,&nbsp;&nbsp; <a href="#Dia_absmin">MF_Dia_absmin</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_add"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_add</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_add</b></font></td>
<td><font size="+1"><b>ME_Rows_add</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_add</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_add</b></font></td>
<td><font size="+1"><b>MCE_Rows_add</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>make one row the sum of itself and another row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_add( fMatrix MA, unsigned ht, unsigned len, unsigned destRow, unsigned sourceRow );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_add( MA:fMatrix; ht, len, destRow, sourceRow:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>destRow, j</sub> += MA<sub>sourceRow, j</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_sub">MF_Rows_sub</a>,&nbsp;&nbsp; <a href="#Rows_Cadd">MF_Rows_Cadd</a>,&nbsp;&nbsp; <a href="#Rows_lincomb">MF_Rows_lincomb</a>,&nbsp;&nbsp; <a href="#chap8">Kap.&nbsp;8</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_Cadd"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_Cadd</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_Cadd</b></font></td>
<td><font size="+1"><b>ME_Rows_Cadd</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_Cadd</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_Cadd</b></font></td>
<td><font size="+1"><b>MCE_Rows_Cadd</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>make one row the sum of itself and another row, scaled by a constant</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_Cadd( fMatrix MA, unsigned ht, unsigned len, unsigned destRow, unsigned sourceRow, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_Cadd( MA:fMatrix; ht, len, destRow, sourceRow:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>destRow, j</sub> += C * MA<sub>sourceRow, j</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_add">MF_Rows_add</a>,&nbsp;&nbsp; <a href="#Rows_lincomb">MF_Rows_lincomb</a>,&nbsp;&nbsp; <a href="#chap8">Kap.&nbsp;8</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_exchange"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_exchange</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_exchange</b></font></td>
<td><font size="+1"><b>ME_Rows_exchange</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_exchange</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_exchange</b></font></td>
<td><font size="+1"><b>MCE_Rows_exchange</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>exchange two rows</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_exchange( fMatrix MA, unsigned ht, unsigned len, unsigned i1, unsigned i2 );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_exchange( MA:fMatrix; ht, len, i1, i2:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The elements of the rows i1 and i2 are exchanged.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Cols_exchange">MF_Cols_exchange</a>,&nbsp;&nbsp; <a href="#chap 8">Kap.&nbsp;8</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_lincomb"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_lincomb</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_lincomb</b></font></td>
<td><font size="+1"><b>ME_Rows_lincomb</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_lincomb</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_lincomb</b></font></td>
<td><font size="+1"><b>MCE_Rows_lincomb</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>linear combination of two rows</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_lincomb( fMatrix MA, unsigned ht, unsigned len, unsigned destRow, float destC, unsigned srceRow, float srceC );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_lincomb( MA:fMatrix; ht, len:UInt; destRow:UInt; destC:Single;
srceRow:Uint; srceC:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>destRow, j</sub> = destC * MA<sub>destRow, j</sub>+ srceC * MA<sub>srceRow, j</sub>,&nbsp;&nbsp;j=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_add">MF_Rows_add</a>,&nbsp;&nbsp; <a href="#Rows_Cadd">MF_Rows_Cadd</a>,&nbsp;&nbsp; <a href="#chap8">Kap.&nbsp;8</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_max"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_max</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_max</b></font></td>
<td><font size="+1"><b>ME_Rows_max</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_max</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_max</b></font></td>
<td><font size="+1"><b>MCE_Rows_max</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>store the maxima of all individual rows in a column vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_max( fVector Y, fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_max( Y:fVector; MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The maximum value of each row <I>i</I> is stored as the element Y<sub>i</sub> for i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_absmax">MF_Rows_absmax</a>,&nbsp;&nbsp; <a href="#Rows_min">MF_Rows_min</a>,&nbsp;&nbsp; <a href="#Cols_max">MF_Cols_max</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_min"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_min</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_min</b></font></td>
<td><font size="+1"><b>ME_Rows_min</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_min</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_min</b></font></td>
<td><font size="+1"><b>MCE_Rows_min</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>store the minima of all individual rows in a column vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_min( fVector Y, fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_min( Y:fVector; MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The smallest or most negative element of each row <I>i</I> is stored as the element Y<sub>i</sub> for i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_absmin">MF_Rows_absmin</a>,&nbsp;&nbsp; <a href="#Rows_max">MF_Rows_max</a>,&nbsp;&nbsp; <a href="#Cols_min">MF_Cols_min</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_prod"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_prod</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_prod</b></font></td>
<td><font size="+1"><b>ME_Rows_prod</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_prod</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_prod</b></font></td>
<td><font size="+1"><b>MCE_Rows_prod</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>products over all elements of each individual row, stored in a column vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_prod(fVector Y, fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_prod(Y:fVector; MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = prod( MA<sub>i,j</sub>, j=0,...,len-1),&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_runprod">MF_Rows_runprod</a>,&nbsp;&nbsp; <a href="#Rows_sum">MF_Rows_sum</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_reflect"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_reflect</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_reflect</b></font></td>
<td><font size="+1"><b>ME_Rows_reflect</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Derive the second halves of all rows from their first halves by reflection at the vertical line through the center of the matrix.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_reflect( fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_reflect( MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i, len-j-1</sub> = MA<sub>i, j</sub>,&nbsp;&nbsp;i=0,...,ht-1;&nbsp;&nbsp;j=0,...,(len-1)/2;</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_rotate">MF_Rows_rotate</a>,&nbsp;&nbsp; <a href="#Cols_reflect">MF_Cols_reflect</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_rotate"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_rotate</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_rotate</b></font></td>
<td><font size="+1"><b>ME_Rows_rotate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_rotate</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_rotate</b></font></td>
<td><font size="+1"><b>MCE_Rows_rotate</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>rotate all rows by a specified number of positions; thereby, whole columns are moved</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_rotate( fMatrix MA, unsigned ht, unsigned len, int pos );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_rotate( MA:fMatrix; ht, len:UInt; pos:Integer );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,j</sub> = MA<sub>i, len-pos+j</sub>,&nbsp;&nbsp;&nbsp;j=0,..,pos-1
<BR>MA<sub>i,j</sub> = MA<sub>i, j-pos</sub>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j=pos,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_reflect">MF_Rows_reflect</a>,&nbsp;&nbsp; <a href="#Cols_rotate">MF_Cols_rotate</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_runprod"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_runprod</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_runprod</b></font></td>
<td><font size="+1"><b>ME_Rows_runprod</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_runprod</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_runprod</b></font></td>
<td><font size="+1"><b>MCE_Rows_runprod</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>running product over row elements</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_runprod( fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_runprod( MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>For all rows separately, each element is the product of itself and all preceding elements. This function should be used with care: overflow is easily reached, and underflow may lead to all elements from a certain position on being zero.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_prod">MF_Rows_prod</a>,&nbsp;&nbsp; <a href="#Cols_runprod">MF_Cols_runprod</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_runsum"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_runsum</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_runsum</b></font></td>
<td><font size="+1"><b>ME_Rows_runsum</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_runsum</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_runsum</b></font></td>
<td><font size="+1"><b>MCE_Rows_runsum</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>running sum over row elements</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_runsum( fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_runsum( MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>For all rows separately, each element is the sum of itself and all preceding elements.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_sum">MF_Rows_sum</a>,&nbsp;&nbsp; <a href="#Cols_runsum">MF_Cols_runsum</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_sub"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_sub</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_sub</b></font></td>
<td><font size="+1"><b>ME_Rows_sub</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_sub</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_sub</b></font></td>
<td><font size="+1"><b>MCE_Rows_sub</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>make one row the difference of itself and another row</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_sub( fMatrix MA, unsigned ht, unsigned len, unsigned destRow, unsigned sourceRow );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_sub( MA:fMatrix; ht, len, destRow, sourceRow:UInt; );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>destRow, j</sub> -= MA<sub>sourceRow, j</sub>,&nbsp;&nbsp;i=0,...,len-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_add">MF_Rows_add</a>,&nbsp;&nbsp; <a href="#Rows_Cadd">MF_Rows_Cadd</a>,&nbsp;&nbsp; <a href="#chap8">Kap.&nbsp;8</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Rows_sum"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Rows_sum</b></font>
</td><td width="33%"><font size="+1"><b>MD_Rows_sum</b></font></td>
<td><font size="+1"><b>ME_Rows_sum</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Rows_sum</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Rows_sum</b></font></td>
<td><font size="+1"><b>MCE_Rows_sum</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>sums over all elements of each individual row, stored in a column vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Rows_sum( fVector Y, fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Rows_sum( Y:fVector; MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y<sub>i</sub> = sum( MA<sub>i,j</sub>, j=0,...,len-1),&nbsp;&nbsp;i=0,...,ht-1</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Rows_runsum">MF_Rows_runsum</a>,&nbsp;&nbsp; <a href="#Rows_prod">MF_Rows_prod</a>,&nbsp;&nbsp; <a href="#chap7">Kap.&nbsp;7</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="safeSolve"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_safeSolve</b></font>
</td><td width="33%"><font size="+1"><b>MD_safeSolve</b></font></td>
<td><font size="+1"><b>ME_safeSolve</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>solve a linear system MA * X = B; in case the system is singular, get one solution out of the infinite solution space</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
int MF_safeSolve( fVector X, fMatrix MA, fVector B, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_safeSolve( X:fVector; MA:fMatrix; B:fVector; len:UInt ):Integer;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><I>MF_safeSolve</I> is similar to <I><a href="#solve">MF_solve</a></I> with the difference that, in case there is no unique solution of the linear system (i.e., LU decomposition fails), singular value decomposition is employed to obtain at least one solution out of the infinite solution space. Recall that the problem with singular linear systems is not that they don't have a solution, but rather that they are under-determined and have infinitely many solutions. In other words, one or more elements of the solution vector can be chosen arbitrarily. This is what <I>MF_safeSolve</I> does, with the additional constraint that the &quot;smallest&quot; solution vector in the least-squares sense is determined.
<P>A return value of 0 indicates success via LUD, 1 signals success via SVD, and -1 is returned in the very rare case that even SVD fails.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#solve">MF_solve</a>,&nbsp;&nbsp; <a href="#chap10">Kap.&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="setDensityBounds"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="90%"><font size="+1"><b>M_setDensityBounds</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Calculate a color scale for color density plots</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Mgraph.h&gt;<BR>
void M_setDensityBounds( extended zmin, extended zmax, COLORREF mincolor, COLORREF maxcolor );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses Mgraph;<BR>
procedure M_setDensityBounds( zmin, zmax: Extended; mincolor, maxcolor: COLORREF );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A color scale is calculated between the colors <I>mincolor</I> and <I>maxcolor</I>, corresponding to <I>zmin</I> and <I>zmax</I>. In any following <I><a href="#xyzDataDensityMap">MF_xyzDataDensityMap</a></I> or <I><a href="#zDataDensityMap">MF_zDataDensityMap</a></I> plot, the <I>z</I> values will be translated into colors by interpolation between the extreme values set by <I>M_setDensityBounds</I>. You will rarely call this function directly. It is internally called by all functions of the <I><a href="#xyzAutoDensityMap">MF_xyzAutoDensityMap</a></I> and <I><a href="#zAutoDensityMap">MF_zAutoDensityMap</a></I> families.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#setDensityMapBounds">M_setDensityMapBounds</a>,&nbsp;&nbsp; <a href="#findDensityMapBounds">M_findDensityMapBounds</a>,&nbsp;&nbsp; <a href="#chap15">Kap.&nbsp;15</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="setDensityMapBounds"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="90%"><font size="+1"><b>M_setDensityMapBounds</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Set a color scale and draw an X-Y coordinate system for matrix color-density plots</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Mgraph.h&gt;<BR>
void M_setDensityMapBounds( extended xmin, extended xmax, extended ymin, extended ymax, extended zmin, extended zmax, COLORREF mincolor, COLORREF maxcolor );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses Mgraph;<BR>
procedure M_setDensityMapBounds( xmin, xmax, ymin, ymax, zmin, zmax: Extended; mincolor, maxcolor: COLORREF );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Similarly to the function <I><a href="FUNCREF.HTM#drawAxes">V_drawAxes</a></I> for X-Y vector plots, this function calculates a color scale from the parameters mincolor, maxcolor, zmin and zmax, and prepares an X-Y coordinate system with the <I>x</I> and <I>y</I> ranges specified by <I>xmin, xmax, ymin</I>, and <I>ymax</I> for color-density plots of matrices. Unlike <I><a href="#findDensityMapBounds">M_findDensityMapBounds</a></I>, no adjustment of the <I>x</I> and <I>y</I> ranges is made. 
<P>The user will rarely call this function himself. It is internally called by all functions of the <I><a href="#xyzAutoDensityMap">MF_xyzAutoDensityMap</a></I> and <I><a href="#zAutoDensityMap">MF_zAutoDensityMap</a></I> families.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#xyzAutoDensityMap">MF_xyzAutoDensityMap</a>,&nbsp;&nbsp; <a href="#zAutoDensityMap">MF_zAutoDensityMap</a>,&nbsp;&nbsp; <a href="#chap15">Kap.&nbsp;15</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="setLinfitNeglect"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_setLinfitNeglect</b></font>
</td><td width="33%"><font size="+1"><b>VD_setLinfitNeglect</b></font></td>
<td><font size="+1"><b>VE_setLinfitNeglect</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>define significance threshold for data fitting to linear models</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void VF_setLinfitNeglect( float Thresh );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure VF_setLinfitNeglect( Thresh:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>As described in connection with <I><a href="#linfit">VF_linfit</a></I>, this function allows to define a significance threshold below which fit parameters <I>a<sub>i</sub></I> are neglected. The default of this threshold is 4*FLT_EPSILON,&nbsp;&nbsp;8*DLB_EPSILON,&nbsp;&nbsp;or 16*LDBL_EPSILON. The current threshold can be retrieved by <I><a href="#getLinfitNeglect">VF_getLinfitNeglect</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#getLinfitNeglect">VF_getLinfitNeglect</a>,&nbsp;&nbsp; <a href="#linfit">VF_linfit</a>,&nbsp;&nbsp; <a href="#chap13">Kap.&nbsp;13</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="setNonlinfitOptions"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>VF_setNonlinfitOptions</b></font>
</td><td width="33%"><font size="+1"><b>VD_setNonlinfitOptions</b></font></td>
<td><font size="+1"><b>VE_setNonlinfitOptions</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>set options for the nonlinear fitting routines</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void VF_setNonlinfitOptions( VF_NONLINFITOPTIONS *Options );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure VF_setNonlinfitOptions( Options: VF_NONLINFITOPTIONS );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The nonlinear fitting routines like <I><a href="#nonlinfit">VF_nonlinfit</a></I> offer the user a lot of different options, packed into a structure <I><a href="#chap13_3NONLINFITOPTIONS">VF_NONLINFITOPTIONS</a></I> (<I>VD_NONLINFITOPTIONS</I> and <I>VE_NONLINFITOPTIONS</I> for the higher accuracy data-types). These options may be set by the function <I>V_setNonlinfitOptions</I>. To retrieve current settings, use <I><a href="#getNonlinfitOptions">V_getNonlinfitOptions</a></I>. The options set with this function are valid for <B>all</B> fitting-functions of the same accuracy level. Thus, e.g., <I>VD_setNonlinfitOptions</I> sets the options governing <I><a href="#nonlinfit">VD_nonlinfit</a></I>,&nbsp;&nbsp;<I><a href="#multiNonlinfit">VD_multiNonlinfit</a></I>,&nbsp;&nbsp;<I><a href="#Mnonlinfit">MD_nonlinfit</a></I>,&nbsp;&nbsp;<I><a href="#MmultiNonlinfit">MD_multiNonlinfit</a></I> and their siblings with data-weighting (&quot;wW&quot; versions).</td></tr>
<tr valign="TOP">
<td>Example C/C++</td><td><font face="courier new">VD_NONLINFITOPTIONS Opt;
<BR>VD_getNonlinfitOptions( &Opt );
<BR>Opt.FigureOfMerit = 0; // choose least-square fitting
<BR>Opt.AbsTolChi = 1.e-6;
<BR>Opt.FracTolChi = 1.e-3; // make the fit fast, but not very accurate
<BR>Opt.LevelOfMethod = 3; // choose alternating Levenberg-Marquardt and Downhill-Simplex runs
<BR>VD_setNonlinfitOptions( &Opt );</font></td></tr>
<tr valign="TOP">
<td>Example Pascal/Delphi</td><td><font face="courier new">Opt: VD_NONLINFITOPTIONS;
<BR>VD_getNonlinfitOptions(Opt );
<BR>Opt.FigureOfMerit := 0; (* choose least-square fitting *)
<BR>Opt.AbsTolChi := 1.e-6;
<BR>Opt.FracTolChi := 1.e-3; (* make the fit fast, but not very accurate *)
<BR>Opt.LevelOfMethod := 3; (* choose alternating Levenberg-Marquardt and Downhill-Simplex runs *)
<BR>VD_setNonlinfitOptions(Opt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#chap13_3">Kap.&nbsp;13.3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="setWriteFormat"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_setWriteFormat</b></font>
</td><td width="33%"><font size="+1"><b>MD_setWriteFormat</b></font></td>
<td><font size="+1"><b>ME_setWriteFormat</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_setWriteFormat</b></font></td>
<td width="33%"><font size="+1"><b>MCD_setWriteFormat</b></font></td>
<td><font size="+1"><b>MCE_setWriteFormat</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Definition of the format to be used by <I><a href="#write">M?_write</a></I>: C/C++ only!</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_setWriteFormat( char *FormatString );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td>This function does not exist.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>These functions are identical to the <I><a href="FUNCREF.TXT#setWriteformat">VF_setWriteFormat</a></I> family. 
<BR>The number format with which the <I><a href="#write">M?_write</a></I> functions print matrix elements into a stream can be adjusted by means of this function. When defining a write format, one should always be aware of the restrictions imposed by the read functions (not all formats you can write will be read correcly, see <I><a href="#read">MF_read</a></I>).
<P><I>MF_setWriteFormat</I> should not be used for the definition of whitespace between the columns. This is the task of <I><a href="#setWriteSeparate">MF_setWriteSeparate</a></I>.
<P>For details about the formats used for each of the various data types, please refer to the following table. The last column of this table gives the maximum length of the format string.
<P><table border width="100%">
<tr valign="top"><td>Version</td><td>Standard Format</td><td>Alternative Example</td><td>max. length</td></tr>
<tr valign="top"><td><i>MF_</i></td><td>&quot;% 11.8e&quot;</td><td>&quot;% 8.4f&quot;</td><td>16</td></tr>
<tr valign="top"><td><i>MD_</i></td><td>&quot;% 19.16le&quot;</td><td>&quot;% 16.8lf&quot;</td><td>16</td></tr>
<tr valign="top"><td><i>ME_</i></td><td>&quot;% 22.19Le&quot;</td><td>&quot;% 22.19LG&quot;</td><td>16</td></tr>
<tr valign="top"><td><i>MCF_</i></td><td>&quot;% 11.8e, % 11.8e&quot;</td><td>&quot;{% 8.4f, % 8.4f}&quot;</td><td>32</td></tr>
<tr valign="top"><td><i>MCD_</i></td><td>&quot;% 19.16le, % 19.16le&quot;</td><td>&quot;{% 19.16lE % 19.16lE}&quot;</td><td>32</td></tr>
<tr valign="top"><td><i>MCE_</i></td><td>&quot;% 22.19Le, % 22.19Le&quot;</td><td>&quot;{% 22.19Lg % 22.19Lg}&quot;</td><td>32</td></tr>
</table>
</td></tr></table></td></tr><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>Format strings longer than the maximum length specified in the above table lead to a program abort with the error message &quot;Invalid Parameter(s)&quot;.
<BR>The contents of the format string is not checked. So you have to be very careful to specify a format which is valid for the respective data type.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#setWriteSeparate">MF_setWriteSeparate</a>,&nbsp;&nbsp; <a href="#write">MF_write</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#write">VF_write</a>,&nbsp;&nbsp; <a href="#read">MF_read</a>,&nbsp;&nbsp; <a href="#chap14">Kap.&nbsp;14</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="setWriteSeparate"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_setWriteSeparate</b></font>
</td><td width="33%"><font size="+1"><b>MD_setWriteSeparate</b></font></td>
<td><font size="+1"><b>ME_setWriteSeparate</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_setWriteSeparate</b></font></td>
<td width="33%"><font size="+1"><b>MCD_setWriteSeparate</b></font></td>
<td><font size="+1"><b>MCE_setWriteSeparate</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>define a character string used to separate columns in the <a href="#write">M?_write</a> functions</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_setWriteSeparate( char *SepString );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_setWriteSeparate( SepString:PChar );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>These functions are identical to the functions of the <I><a href="FUNCREF.HTM#setNWriteSeparate">VF_setNWriteSeparate</a></I> family. They are used to define the character string to be inserted between the columns of a table written by <I><a href="#write">MF_write</a></I>. <I>MF_setWriteSeparate</I> does not influence the end of each line which is always a line-feed character ('\n' for C/C++ and #13 for Pascal/Delphi).
<BR>SepString may contain up to twelve characters. The default setting is a single tab character (&quot;\t&quot; for C/C++ and #9 for Pascal/Delphi).
</td></tr></table></td></tr><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>In the case of SepString longer than twelve characters, the program is aborted with the error message &quot;Invalid Parameter(s)&quot;.
<BR>The contents of SepString is not checked.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#setWriteFormat">MF_setWriteFormat</a>,&nbsp;&nbsp; <a href="#write">MF_write</a>,&nbsp;&nbsp; <a href="#read">MF_read</a>,&nbsp;&nbsp; <a href="#chap14">Kap.&nbsp;14</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="solve"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_solve</b></font>
</td><td width="33%"><font size="+1"><b>MD_solve</b></font></td>
<td><font size="+1"><b>ME_solve</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_solve</b></font></td>
<td width="33%"><font size="+1"><b>MCD_solve</b></font></td>
<td><font size="+1"><b>MCE_solve</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>solve a linear system</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
int MF_solve( fVector X, fMatrix MA, fVector B, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_solve( X:fVector; MA:fMatrix; B:fVector; len:UInt ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function solves the system MA * X = B of simultaneous linear equations, using LU decomposition. It works well in all cases where there is one unique solution. If successful, it returns FALSE (0).
<BR>If, on the other hand, the system is ill-determined, which happens in all cases where one or more of the equations are linear combinations of other equations of the same system, the resulting matrix becomes singular and the function fails with an error message, returning TRUE (1).
<BR>To avoid outright failure in an application where ill-determined matrices might occur, you should use
<I><a href="#LUDsetEdit">MF_LUDsetEdit</a></I> to define a minimum &quot;pivot&quot; for the LU decomposition process. If you do so, <I>MF_solve</I> will always yield a &quot;more or less&quot; meaningful solution and returns always FALSE (0). Then, a call to <I><a href="#LUDresult">MF_LUDresult</a></I> will tell you if pivot-editing has actually been necessary.
<BR>Alternatively, you might switch to <I><a href="#safeSolve">MF_safeSolve</a></I> or <I><a href="#solveBySVD">MF_solveBySVD</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if the linear system could by solved; TRUE (1) in the case of a singular system without pivot-editing</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#LUdecompose">MF_LUdecompose</a>,&nbsp;&nbsp; <a href="#inv">MF_inv</a>,&nbsp;&nbsp; <a href="#chap10">Kap.&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="solveBySVD"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_solveBySVD</b></font>
</td><td width="33%"><font size="+1"><b>MD_solveBySVD</b></font></td>
<td><font size="+1"><b>ME_solveBySVD</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>solve a possibly over- or underdetermined linear system by singular value decomposition</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
int MF_solveBySVD( fVector X, fMatrix MA, fVector B, unsigned htA, unsigned lenA );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_solveBySVD( X:fVector; MA:fMatrix; B:fVector; htA, lenA:UInt ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The system MA * X = B of simultaneous linear equations is solved for X, using Singular Value Decomposition. Here, underdetermined systems do not lead to an error. Rather, you get one particular solution out of the solution space. If you have more equations than unknowns, i.e., in the case of an overdetermined system, the solution vector contains a least-square &quot;compromise&quot; between the equations.
<BR>The function should always return FALSE (0). Only in the very rare case of SVD failure, TRUE (1) is returned. The length of the desired solution vector, sizX must be equal to the width of the input matrix, lenA, whereas the length of the right-hand-side vector, sizB must be equal to htA.
<P>The threshold for singular-value editing should be set using <I><a href="#SVDsetEdit">MF_SVDsetEdit</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>usually FALSE (0); only in the very rare case of failure, TRUE (1)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#SVdecompose">MF_SVdecompose</a>,&nbsp;&nbsp; <a href="#solve">MF_solve</a>,&nbsp;&nbsp; <a href="#chap10">Kap.&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="spectrum"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_spectrum</b></font>
</td><td width="33%"><font size="+1"><b>MD_spectrum</b></font></td>
<td><font size="+1"><b>ME_spectrum</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>spatial frequency spectrum</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_spectrum( fMatrix MSpec, unsigned htSpec, unsigned lenSpec, fMatrix MX, unsigned htX, unsigned lenX, fMatrix MWin );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_spectrum( MSpec:fMatrix; htSpec, lenSpec:UInt; MX:fMatrix; htX, lenX:UInt; MWin:fMatrix );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The data set MX is analyzed for the mean square amplitude of its spatial frequency spectrum. The result is stored in MSpc.
<BR>Internally, the spectrum is calculated by dividing the input data into overlapping segments, similarly to the one-dimensional case described for <I><a href="FUNCREF.HTM#spectrum">VF_spectrum</a></I>.
<BR>MWin is a window that is applied to the data segments. Three functions are available that give suitable
Windows: <I><a href="#Welch">MF_Welch</a></I>,&nbsp;&nbsp; </I><a href="#Parzen">MF_Parzen</a></I>, and <I><a href="#Hanning">MF_Hanning</a></I>. A square window is available by setting all matrix elements equal to 1.0 (<font face="courier new">MF_equC( MWin, htWin, lenWin, 1.0 );</font>&nbsp;), but this is not recommended.
<BR>htSpec and lenSpec must be integer powers of 2.
<BR>MSpec has [htSpec+1][lenSpec+1] elements (!), and htX &gt;= n*htSpec, lenX &gt;= n*lenSpec, htWin = 2*htSpec, lenWin = 2*lenSpec.
<P>About special versions with the prefixes <i>MFs_</i> and <I>MFl_</I>, consult <a href="HANDBOOK.HTM#chap4_8">Kap.&nbsp;4.8 of HANDBOOk.HTM.</a></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If either htSpec or lenSpec is not a power of 2, <I><a href="FUNCREF.HTM#FFT">VF_FFT</a></I> (on which <I>MF_spectrum</I> relies) complains &quot;Size must be an integer power of 2&quot; and the program is aborted. If MSpc overwrites MX or MWin, an error message &quot;Vectors/matrices must not be identical&quot; is generated and the program aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#FFT">MF_FFT</a>,&nbsp;&nbsp; <a href="#convolve">MF_convolve</a>,&nbsp;&nbsp; <a href="#autocorr">MF_autocorr</a>,&nbsp;&nbsp; <a href="#xcorr">MF_xcorr</a>,&nbsp;&nbsp; <a href="#filter">MF_filter</a>,&nbsp;&nbsp; <a href="#chap12">Kap.&nbsp;12</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="sqrt"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MFsym_sqrt</b></font>
</td><td width="33%"><font size="+1"><b>MDsym_sqrt</b></font></td>
<td><font size="+1"><b>MEsym_sqrt</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Square root of a symmetric, positive definite matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
int MFsym_sqrt( fMatrix MB, fMatrix MA, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MFsym_sqrt( MB, MA:fMatrix; len:UInt ):IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The square-root of a symmetric, positive definite matrix is calculated, so that MB * MB = MA is satisfied. Please note that non-symmetric matrices or matrices which are not positive definite may or may not have existing square-roots, too. The present algorithm, however, is restricted to the most simple case where a square-root always exists. It uses eigenvalues and eigenvectors and fails whenever a negative eigenvalue is encountered, indicating an input matrix which is not positive definite. In the latter case, an error message is displayed and the result is calculated with zero substituted for the negative eigenvalue. This result may still be useful, namely if the negative eigenvalue is very small.  
<P>A return value of FALSE or 0 indicates success, whereas a non-zero return value indicates that the input matrix did not meet the condition of being symmetric and positive definite.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>FALSE (0), if the matrix square-root could be calculated; otherwise TRUE (1)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#solve">MF_solve</a>,&nbsp;&nbsp; <a href="#chap10">Kap.&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="store"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_store</b></font>
</td><td width="33%"><font size="+1"><b>MD_store</b></font></td>
<td><font size="+1"><b>ME_store</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_store</b></font></td>
<td width="33%"><font size="+1"><b>MCD_store</b></font></td>
<td><font size="+1"><b>MCE_store</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>store a matrix in binary format into a stream</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_store( FILE *str, fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_store( var Stream:FILE; MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The matrix MA of ht*len elements is written to <I>stream</I> in binary format. The stream must be already open for binary write operations.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#recall">MF_recall</a>,&nbsp;&nbsp; <a href="#chap14">Kap.&nbsp;14</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="subM"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_subM</b></font>
</td><td width="33%"><font size="+1"><b>MD_subM</b></font></td>
<td><font size="+1"><b>ME_subM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MFs_subM</b></font></td>
<td width="33%"><font size="+1"><b>MDs_subM</b></font></td>
<td><font size="+1"><b>MEs_subM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_subM</b></font></td>
<td width="33%"><font size="+1"><b>MCD_subM</b></font></td>
<td><font size="+1"><b>MCE_subM</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>element-wise subtraction of two matrices</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_subM( fMatrix MC, fMatrix MA, fMatrix MB, unsigned ht, unsigned len );<BR>
void MFs_subM( fMatrix MC, fMatrix MA, fMatrix MB, unsigned ht, unsigned len, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_subM( MC, MA, MB:fMatrix; ht, len:UInt );<BR>
procedure MFs_subM( MC, MA, MB:fMatrix; ht, len:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal version: MC<sub>ij</sub> = MA<sub>ij</sub> - MB<sub>ij</sub>
<BR>scaled version: MC<sub>ij</sub> = C * (MA<sub>ij</sub> - MB<sub>ij</sub>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#subMT">MF_subMT</a>,&nbsp;&nbsp; <a href="#addM">MF_addM</a>,&nbsp;&nbsp; <a href="#chap9">Kap.&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="subMT"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_subMT</b></font>
</td><td width="33%"><font size="+1"><b>MD_subMT</b></font></td>
<td><font size="+1"><b>ME_subMT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MFs_subMT</b></font></td>
<td width="33%"><font size="+1"><b>MDs_subMT</b></font></td>
<td><font size="+1"><b>MEs_subMT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_subMT</b></font></td>
<td width="33%"><font size="+1"><b>MCD_subMT</b></font></td>
<td><font size="+1"><b>MCE_subMT</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>subtract the transpose of one matrix from another matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_subMT( fMatrix MC, fMatrix MA, fMatrix MB, unsigned ht, unsigned len );<BR>
void MFs_subMT( fMatrix MC, fMatrix MA, fMatrix MB, unsigned ht, unsigned len, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_subMT( MC, MA, MB:fMatrix; ht, len:UInt );<BR>
procedure MFs_subMT( MC, MA, MB:fMatrix; ht, len:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal version: MC<sub>i,j</sub> = MA<sub>i,j</sub> - MB<sup>T</sup><sub>j,i</sub>
<BR>scaled version: MC<sub>i,j</sub> = C * (MA<sub>i,j</sub> - MB<sup>T</sup><sub>j,i</sub>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#subM">MF_subM</a>,&nbsp;&nbsp; <a href="#addM">MF_addM</a>,&nbsp;&nbsp; <a href="subrMT">MF_subrMT</a>,&nbsp;&nbsp; <a href="#chap9">Kap.&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="subrMT"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_subrMT</b></font>
</td><td width="33%"><font size="+1"><b>MD_subrMT</b></font></td>
<td><font size="+1"><b>ME_subrMT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MFs_subrMT</b></font></td>
<td width="33%"><font size="+1"><b>MDs_subrMT</b></font></td>
<td><font size="+1"><b>MEs_subrMT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_subrMT</b></font></td>
<td width="33%"><font size="+1"><b>MCD_subrMT</b></font></td>
<td><font size="+1"><b>MCE_subrMT</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>reverse subtraction: subtract one matrix from the transpose of another</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_subrMT( fMatrix MC, fMatrix MA, fMatrix MB, unsigned ht, unsigned len );<BR>
void MFs_subrMT( fMatrix MC, fMatrix MA, fMatrix MB, unsigned ht, unsigned len, float C );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_subrMT( MC, MA, MB:fMatrix; ht, len:UInt );<BR>
procedure MFs_subrMT( MC, MA, MB:fMatrix; ht, len:UInt; C:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>normal version: MC<sub>i,j</sub> = MB<sup>T</sup><sub>j,i</sub> - MA<sub>i,j</sub>
<BR>scaled version: MC<sub>i,j</sub> = C * (MB<sup>T</sup><sub>j,i</sub> - MA<sub>i,j</sub>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#addM">MF_addM</a>,&nbsp;&nbsp; <a href="subMT">MF_subMT</a>,&nbsp;&nbsp; <a href="#chap9">Kap.&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="submatrix"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_submatrix</b></font>
</td><td width="33%"><font size="+1"><b>MD_submatrix</b></font></td>
<td><font size="+1"><b>ME_submatrix</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_submatrix</b></font></td>
<td width="33%"><font size="+1"><b>MCD_submatrix</b></font></td>
<td><font size="+1"><b>MCE_submatrix</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>extract a submatrix from a (larger) matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_submatrix( fMatrix MSub, unsigned subHt, unsigned subLen, fMatrix MSrce, unsigned srceHt, unsigned srceLen, unsigned firstRowInCol, unsigned sampInCol, unsigned firstColInRow, unsigned sampInRow );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_submatrix( MSub:fMatrix; subHt, subLen:UInt; MSrce:fMatrix; srceHt, srceLen:UInt; firstRowInCol, sampInCol, firstColInRow, sampInRow:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MSub<sub>i, j</sub> = MSrce<sub>i*sampInCol+firstRowInCol, j*sampInRow+firstColInRow</sub></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="FUNCREF.HTM#subvector">VF_subvector</a>,&nbsp;&nbsp; <a href="#Row_extract">MF_Row_extract</a>,&nbsp;&nbsp; <a href="#submatrix_equM">MF_submatrix_equM</a>,&nbsp;&nbsp; <a href="#chap5">Kap.&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="submatrix_equM"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_submatrix_equM</b></font>
</td><td width="33%"><font size="+1"><b>MD_submatrix_equM</b></font></td>
<td><font size="+1"><b>ME_submatrix_equM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_submatrix_equM</b></font></td>
<td width="33%"><font size="+1"><b>MCD_submatrix_equM</b></font></td>
<td><font size="+1"><b>MCE_submatrix_equM</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>distribute the elements of a matrix to a submatrix of another (larger) matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_submatrix_equM( fMatrix MDest, unsigned destHt, unsigned destLen, unsigned firstRowInCol, unsigned sampInCol, unsigned firstColInRow, unsigned sampInRow, fMatrix MSrce, unsigned srceHt, unsigned srceLen );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_submatrix_equM( MDest:fMatrix; destHt, destLen, firstRowInCol, sampInCol, firstColInRow, sampInRow:UInt;
MSrce:fMatrix; srceHt, srceLen:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MDest<sub>i*sampInCol+firstRowInCol, j*sampInRow+firstColInRow</sub> = MSrce<sub>i, j</sub>
<BR>This function does the inverse of <I><a href="#submatrix">MF_submatrix</a></I></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="FUNCREF.HTM#subvector">VF_subvector</a>,&nbsp;&nbsp; <a href="#Row_equV">MF_Row_equV</a>,&nbsp;&nbsp; <a href="#submatrix">MF_submatrix</a>,&nbsp;&nbsp; <a href="#chap5">Kap.&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="SVdecompose"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_SVdecompose</b></font>
</td><td width="33%"><font size="+1"><b>MD_SVdecompose</b></font></td>
<td><font size="+1"><b>ME_SVdecompose</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>Singular Value Decomposition</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
int MF_SVdecompose( fMatrix MU, fMatrix MV, fVector W, fMatrix MA, unsigned htA, unsigned lenA );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_SVdecompose( MU, MV:fMatrix; W:fVector; MA:fMatrix; htA, lenA:UInt ): IntBool;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The matrix MA of dimensions [ht, len] is decomposed into a product<BR>
MA = MU * MW * MV<sup>T</sup>,<BR>
where MU has the dimensions [max(ht,len), len]. MW is a diagonal matrix with all elements positive or zero. Actually, only the diagonal of this matrix is stored in the vector W of size [len], MV, finally, is a square matrix [len, len]. Both MU and MV are orthogonal: 
<BR>MU<sup>T</sup> * MU = MV<sup>T</sup> * MV = (1).
Due to these orthogonality relations, the solution of a linear system MA * X = B is straightforward, once MA has been singular-value decomposed:
<BR>X = MV * W<sup>-1</sup> * MU<sup>T</sup>
<BR>(This equation must be evaluated from right to left.) As MU and MV are orthogonal, only W must explicitly be inverted. This, however, is again easy, as W is diagonal, and the inverse of a diagonal matrix consists of the inverse of the diagonal elements. This is the important point which makes SVD so useful, because it provides both a diagnose and a cure for singularities. If any element of W is very small compared to the largest element, this corresponds to a singularity (at least in the numerical sense, where dividing by extremely small numbers is almost as bad as dividing by zero). A singularity means that the underlying linear system is under-determined. This, in turn, means that one can arbitrarily choose one particular solution. Specifically, one may choose W<sup>-1</sup><sub>ii</sub> = 0 for very small W<sub>ii</sub>, which is one of the rare cases where it makes sense to set the result of a division by (near-)zero to zero instead of infinity. This reduction of the dimension by &quot;Singular Value editing&quot; is the crucial point in all functions relying on SVD, like <I><a href="#SVsolve">MF_SVsolve</a></I>,&nbsp;&nbsp;<I><a href="#safeSolve">MF_safeSolve</a></I>),&nbsp;&nbsp;<I><a href="#linfit">VF_linfit</a></I> and others. The editing threshold is set by <I><a href="#SVDsetEdit">MF_SVDsetEdit</a></I>.
<P>This function may not be called while the FPU is set to reduced accuracy, or else it might fail to achieve convergence. See <I><a href="FUNCREF.HTM#setFPAccuracy">V_setFPAccuracy</a></I>.
<P>If you compare results of <I>MF_SVdecompose</I> with SVD-routines of other vendors, please note the following points:
<OL><LI><I>MF_SVdecompose</I> itself does not perform a dimension reduction (replacement of small singular values by 0), but leaves this step to following functions or to manual inspection by the user. 
<LI>Singular values can be permutated, if the same permutation is also applied to the corresponding columns of both MU and MV. Sometimes, this property of SVD is exploited to bring the singular values into a certain (for example, into descending) order. As the price for this increased beauty is an increased work-load, <I>MF_SVdecompose</I> keeps the singular values in arbitrary order.
<LI>The sign of a singular value may be exchanged if the corresponding column of MV is also multiplied by -1. <I>MF_SVdecompose</I> uses this property to make all non-vanishing singular values positive.</OL></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#SVsolve">MF_SVsolve</a>,&nbsp;&nbsp; <a href="#safeSolve">MF_safeSolve</a>,&nbsp;&nbsp; <a href="#solveBySVD">MF_solveBySVD</a>,&nbsp;&nbsp; <a href="#chap10">chapter10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="SVDgetEdit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_SVDgetEdit</b></font>
</td><td width="33%"><font size="+1"><b>MD_SVDgetEdit</b></font></td>
<td><font size="+1"><b>ME_SVDgetEdit</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>retrieve current editing threshold for Singular Value backsubstitution</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
float MF_SVDgetEdit( void );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
function MF_SVDgetEdit: Single;</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function returns the current Singular Value editing threshold. The SV editing threshold may be modified by <I><a href="#SVDsetEdit">MF_SVDsetEdit</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Return value</td><td>current SV editing threshold</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#SVdecompose">MF_SVdecompose</a>,&nbsp;&nbsp; <a href="#SVsolve">MF_SVsolve</a>,&nbsp;&nbsp; <a href="#chap10">Kap.&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="SVDsetEdit"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_SVDsetEdit</b></font>
</td><td width="33%"><font size="+1"><b>MD_SVDsetEdit</b></font></td>
<td><font size="+1"><b>ME_SVDsetEdit</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>set the Singular Value editing threshold</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_SVDsetEdit( float Thresh );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_SVDsetEdit( Thresh:Single );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>As described in connection with <I><a href="#SVdecompose">MF_SVdecompose</a></I> and <I><a href="#SVsolve">MF_SVsolve</a></I>, the crucial point in using functions which rely on Singular Value Decomposition is the Singular Value editing step. By default, the SV editing threshold is 4*FLT_EPSILON,&nbsp;&nbsp;8*DBL_EPSILON, or 16*LDBL_EPSILON. You may change these values by calling <I>MF_SVDsetEdit</I>. To retrieve the current SV editing threshold, call <I><a href="#SVDgetEdit">MF_SVDgetEdit</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#SVdecompose">MF_SVdecompose</a>,&nbsp;&nbsp; <a href="#SVsolve">MF_SVsolve</a>,&nbsp;&nbsp; <a href="#chap10">Kap.&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="SVsolve"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_SVsolve</b></font>
</td><td width="33%"><font size="+1"><b>MD_SVsolve</b></font></td>
<td><font size="+1"><b>ME_SVsolve</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>solve a system of linear equations, given its Singular Value decomposed form</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_SVsolve( fVector X, fMatrix MU, fMatrix MV, fVector W, fVector B, unsigned htU, unsigned lenU );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_SVsolve( X:fVector; MU, MV:fMatrix; W, B:fVector; htU, lenU:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td><I>MF_SVsolve</I> solves an SV-decomposed set of linear equations; sometimes this process is also called Singular Value Backsubstitution. In this function, at first W is edited such that elements smaller than a threshold are set to zero. Then, in the backsubstitution process, which involves divisions by the elements of W, any divisions by W<sub>i</sub> = 0 are replaced by setting the result to 0. You can choose the editing threshold by calling <I><a href="#SVDsetEdit">MF_SVDsetEdit</a></I>. If you prefer to inspect and edit W yourself before calling <I><a href="#SVsolve">MF_SVsolve</a></I>, you can call <I><a href="#SVDsetEdit">MF_SVDsetEdit</a></I> with the argument 0.0, thereby switching off the automatic SV editing.
<P>The parameters lenU = lenA and htU = max( lenA, htA ) are the same as fed into <I><a href="#SVdecompose">MF_SVdecompose</a></I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#SVdecompose">MF_SVdecompose</a>,&nbsp;&nbsp; <a href="#solveBySVD">MF_solveBySVD</a>,&nbsp;&nbsp; <a href="#chap10">Kap.&nbsp;10</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="TmulM"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_TmulM</b></font>
</td><td width="33%"><font size="+1"><b>MD_TmulM</b></font></td>
<td><font size="+1"><b>ME_TmulM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_TmulM</b></font></td>
<td width="33%"><font size="+1"><b>MCD_TmulM</b></font></td>
<td><font size="+1"><b>MCE_TmulM</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply the transpose of one matrix by another matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_TmulM( fMatrix MC, fMatrix MA, fMatrix MB, unsigned htA, unsigned lenA, unsigned lenB );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_TmulM( MC, MA, MB:fMatrix; htA, lenA, lenB:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MC = MA<sup>T</sup> * MB
<BR>htA, lenA, and lenB must be specified; the other dimensions are implicitly given as: htB = htA, lenC = lenB, htC = lenA. htA and lenA refer to the original, un-transposed input matrix.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#mulM">MF_mulM</a>,&nbsp;&nbsp; <a href="#mulMT">MF_mulMT</a>,&nbsp;&nbsp; <a href="#chap9">Kap.&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="TmulMdia"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_TmulMdia</b></font>
</td><td width="33%"><font size="+1"><b>MD_TmulMdia</b></font></td>
<td><font size="+1"><b>ME_TmulMdia</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_TmulMdia</b></font></td>
<td width="33%"><font size="+1"><b>MCD_TmulMdia</b></font></td>
<td><font size="+1"><b>MCE_TmulMdia</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply the transpose of a general matrix by a diagonal matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_TmulMdia( fMatrix MC, fMatrix MA, fVector MBDia, unsigned htA, unsigned lenA );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_TmulMdia( MC, MA:fMatrix; MBDia:fVector; htA, lenA:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MC = MA<sup>T</sup> * MBDia
<BR>htA and lenA must be specified. They refer to the original, un-transposed input matrix. Implicitly, sizB = htA.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#dia_mulM">MFdia_mulM</a>,&nbsp;&nbsp; <a href="#chap9">Kap.&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="TmulMT"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_TmulMT</b></font>
</td><td width="33%"><font size="+1"><b>MD_TmulMT</b></font></td>
<td><font size="+1"><b>ME_TmulMT</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_TmulMT</b></font></td>
<td width="33%"><font size="+1"><b>MCD_TmulMT</b></font></td>
<td><font size="+1"><b>MCE_TmulMT</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply the transpose of one matrix by the transpose of another</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_TmulMT( fMatrix MC, fMatrix MA, fMatrix MB, unsigned htA, unsigned lenA, unsigned htB );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_TmulMT( MC, MA, MB:fMatrix; htA, lenA, htB:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MC = MA<sup>T</sup> * MB<sup>T</sup>
<BR>htA, lenA, and htB must be specified; the other dimensions are implicitly given as: lenB = htA, lenC = htB, htC = lenA. All dimensions refer to the original, un-transposed input matrices.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#mulM">MF_mulM</a>,&nbsp;&nbsp; <a href="#TmulM">MF_TmulM</a>,&nbsp;&nbsp; <a href="#mulMT">MF_mulMT</a>,&nbsp;&nbsp; <a href="#chap9">Kap.&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="TmulV"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_TmulV</b></font>
</td><td width="33%"><font size="+1"><b>MD_TmulV</b></font></td>
<td><font size="+1"><b>ME_TmulV</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_TmulV</b></font></td>
<td width="33%"><font size="+1"><b>MCD_TmulV</b></font></td>
<td><font size="+1"><b>MCE_TmulV</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>multiply the transpose of a matrix by a column vector</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_TmulV( fVector Y, fMatrix MA, fVector X, unsigned htA, unsigned lenA );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_TmulV( Y:fVector; MA:fMatrix; X:fVector; htA, lenA:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Y = MA<sup>T</sup> * X
<BR>The dimensions htA and lenA refer to the original (rather than the intermediate transposed) matrix MA; the dimensions of X and Y are implicitly given by the matrix dimensions: sizX = htA, sizY = lenA.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#mulV">MF_mulV</a>,&nbsp;&nbsp; <a href="#VmulM">VF_mulM</a>,&nbsp;&nbsp; <a href="#chap9">Kap.&nbsp;9</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="transpose"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_transpose</b></font>
</td><td width="33%"><font size="+1"><b>MD_transpose</b></font></td>
<td><font size="+1"><b>ME_transpose</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_transpose</b></font></td>
<td width="33%"><font size="+1"><b>MCD_transpose</b></font></td>
<td><font size="+1"><b>MCE_transpose</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>transpose of a matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_transpose( fMatrix MTr, fMatrix MA, unsigned htTr, unsigned lenTr );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_transpose( MTr, MA:fMatrix; htTr, lenTr:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MTr<sub>i,j</sub> = MA<sub>j,i</sub>
<BR>The dimensions fed into this function, htTr and lenTr, refer to the transposed matrix rather than to the input matrix.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#hermconj">MCF_hermconj</a>,&nbsp;&nbsp; <a href="#mulMT">MF_mulMT</a>,&nbsp;&nbsp; <a href="#chap9">Kap.&nbsp;9</a>,&nbsp;&nbsp; <a href="#chap5">Kap.&nbsp;5</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Trd_equM"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Trd_equM</b></font>
</td><td width="33%"><font size="+1"><b>MD_Trd_equM</b></font></td>
<td><font size="+1"><b>ME_Trd_equM</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Trd_equM</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Trd_equM</b></font></td>
<td><font size="+1"><b>MCE_Trd_equM</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>initialize the tridiagonal part of a matrix with the three vectors contained in a compacted tradiagonal matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Trd_equM( fMatrix MA, fMatrix MTrd, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Trd_equM( MA, MTrd:fMatrix; len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>Row 0 of MTrd is copied into the first diagonal above the main diagonal of the square matrix MA. Row 1 of MTrd goes into the main diagonal of MA, and Row 2 of MTrd into the first diagonal below the main diagonal of MA. See <a href="#chap1_2">Kap.&nbsp;1.2</a> for details about the storing of tridiagonal matrices.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_equV">MF_Dia_equV</a>,&nbsp;&nbsp; <a href="#Trd_extract">MF_Trd_extract</a>,&nbsp;&nbsp; <a href="#chap2">Kap.&nbsp;2</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Trd_extract"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Trd_extract</b></font>
</td><td width="33%"><font size="+1"><b>MD_Trd_extract</b></font></td>
<td><font size="+1"><b>ME_Trd_extract</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_Trd_extract</b></font></td>
<td width="33%"><font size="+1"><b>MCD_Trd_extract</b></font></td>
<td><font size="+1"><b>MCE_Trd_extract</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>extract the tridiagonal part from a general matrix and store it into a compacted tridiagonal matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Trd_extract( fMatrix MTrd, fMatrix MA, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Trd_extract( MTrd, MA:fMatrix; len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The first diagonal above the main diagonal of the square matrix MA is copied into Row 0 of MTrd. The main diagonal of MA goes into Row1 of MTrd, and the first diagonal below the main diagonal of MA is copied into Row 2 of MTrd. See <a href="#chap1_2">Kap.&nbsp;1.2</a> for details about the storing of tridiagonal matrices.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Dia_extract">MF_Dia_extract</a>,&nbsp;&nbsp; <a href="#Trd_equM">MF_Trd_equM</a>,&nbsp;&nbsp; <a href="#chap2">Kap.&nbsp;2</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="UequL"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_UequL</b></font>
</td><td width="33%"><font size="+1"><b>MD_UequL</b></font></td>
<td><font size="+1"><b>ME_UequL</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_UequL</b></font></td>
<td width="33%"><font size="+1"><b>MCD_UequL</b></font></td>
<td><font size="+1"><b>MCE_UequL</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>copy lower-diagonal elements into upper-diagonal by index-reflection, so as to get a symmetric matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_UequL( fMatrix MA, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_UequL( MA:fMatrix; len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,j</sub> = MA<sub>j,i</sub>,&nbsp;&nbsp;i &lt; j</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#LequU">MF_LequU</a>,&nbsp;&nbsp; <a href="#chap3">Kap.&nbsp;3</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="Welch"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_Welch</b></font>
</td><td width="33%"><font size="+1"><b>MD_Welch</b></font></td>
<td><font size="+1"><b>ME_Welch</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>two-dimensional Welch window for use in spatial frequency analysis</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_Welch( fMatrix MA, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_Welch( MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>MA<sub>i,j</sub> = (1 - ( (i - 0.5*(ht - 1)) / (0.5*(ht + 1)) )<sup>2</sup>) * (1 - ( (j - 0.5*(len - 1)) / (0.5*(len + 1)) )<sup>2</sup>)</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#Parzen">MF_Parzen</a>,&nbsp;&nbsp; <a href="#Hanning">MF_Hanning</a>,&nbsp;&nbsp; <a href="#spectrum">MF_spectrum</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="write"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_write</b></font>
</td><td width="33%"><font size="+1"><b>MD_write</b></font></td>
<td><font size="+1"><b>ME_write</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_write</b></font></td>
<td width="33%"><font size="+1"><b>MCD_write</b></font></td>
<td><font size="+1"><b>MCE_write</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>write a matrix in ASCII format into a stream</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_write( FILE *stream, fMatrix X, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
{Delphi version:}<BR>
&nbsp;&nbsp;procedure MF_write( var Stream:TextFile; MA:fMatrix; ht, len:UInt );<BR>
{Turbo Pascal version:}<BR>
&nbsp;&nbsp;procedure MF_write( var Stream:Text; MA:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The matrix MA with <I>len</I> columns and <I>ht</I> rows is written to <I>stream</I> in ASCII format. <I>stream</I> must already be open for write operations in text format.
<P>The number format and the separation between columns may be specified using <I><a href="#setWriteFormat">MF_setWriteFormat</a></I> (C/C++ only) and <I><a href="#setWriteSeparate">MF_setWriteSeparate</a></I>, respectively. See these functions for details.
<P>Storing data in ASCII format is useful if the data have to be readable by human eyes, or if they are to be exported into other programs which are not able to read machine-format numbers. If avoidable, these functions should not be used for the storage of intermediate results that later have again to be read in. Instead, the function pairs of the <I><a href="#store">MF_store</a></I> / <I><a href="#recall">MF_recall</a></I> family are recommended for the following reasons: conversion into ASCII format is slow, may lead to round-off errors, and requires much more disk memory than storage in machine format.
</td></tr></table></td></tr><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>none</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#setWriteFormat">MF_setWriteFormat</a>,&nbsp;&nbsp; <a href="#setWriteSeparate">MF_setWriteSeparate</a>,&nbsp;&nbsp; <a href="#read">MF_read</a>,&nbsp;&nbsp; <a href="#store">MF_store</a>,&nbsp;&nbsp; <a href="#print">MF_print</a>,&nbsp;&nbsp; <a href="#chap14">Kap.&nbsp;14</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="xcorr"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_xcorr</b></font>
</td><td width="33%"><font size="+1"><b>MD_xcorr</b></font></td>
<td><font size="+1"><b>ME_xcorr</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>spatial cross-correlation function</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;MFstd.h&gt;<BR>
void MF_xcorr( fMatrix MC, fMatrix MA, fMatrix MB, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd;<BR>
procedure MF_xcorr( MC, MA, MB:fMatrix; ht, len:UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The spatial cross-correlation function (SCCF) of MA and MB is calculated and stored in MC in wrap-around order in both dimensions: The row elements MC<sub>i,0</sub> to MC<sub>i,len/2-1</sub> contain the SCCF for zero and positive x lags. Beginning with the most negative lag in MC<sub>i,len/2+1</sub>, the elements up to MC<sub>i,len-1</sub> contain the SCCF for negative lags. Since this function assumes MA and MB to be periodic, the SCCF for the most positive lag is identical to the SCCF for the most negative lag. This element is stored as MC<sub>i,len/2</sub>.
<BR>Similarly, the column elements MC<sub>0,j</sub> to MC<sub>len/2-1,j</sub> contain the SCCF for zero and positive y lags. Beginning with the most negative lag in MC<sub>len/2+1,j</sub>, the elements up to MC<sub>len-1,j</sub> contain the SCCF for negative lags.
<BR>To get the SCCF into normal order, you may call
<BR><font face="courier new"> <a href="#Rows_rotate">MF_Rows_rotate</a>( MC, ht, len, len/2 );
<BR><a href="#Cols_rotate">MF_Cols_rotate</a>( MC, ht, len, ht/2 );</font>
<BR>After that, the zero point is at the position MC<sub>ht/2,len/2</sub>.
<BR>In case MA or MB are non-periodic, you should avoid end effects by the methods described in connection with <I><a href="#convolve">MF_convolve</a></I>.
<BR>All three matrices involved have the same dimensions. Both <I>ht</I> and <I>len</I> must be integer powers of 2.
<BR>About special versions with the prefixes <I>MFl_</I> and <I>MFs_</I>, consult <a href="HANDBOOK.HTM#chap4_8">Kap.&nbsp;4.8 of HANDBOOK.HTM</a>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Error handling</td><td>If either len or ht is not a power of 2, <I><a href="FUNCREF.HTM#FFT">VF_FFT</a></I> (on which <I>MF_xcorr</I> is based) complains &quot;Size must be an integer power of 2&quot; and the program is aborted.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#autocorr">MF_autocorr</a>,&nbsp;&nbsp; <a href="#chap12">Kap.&nbsp;12</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="xyzAutoDensityMap"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_xyzAutoDensityMap</b></font>
</td><td width="33%"><font size="+1"><b>MD_xyzAutoDensityMap</b></font></td>
<td><font size="+1"><b>ME_xyzAutoDensityMap</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>draw an X-Y coordinate system and plot a color-density map for z = f( x, y ) into it</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Mgraph.h&gt;<BR>
void MF_xyzAutoDensityMap( fVector X, fVector Y, fMatrix MZ, unsigned ht, unsigned len, COLORREF mincolor, COLORREF maxcolor );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses Mgraph;<BR>
procedure MF_xyzAutoDensityMap( X, Y:fVector; MZ:fMatrix; ht, len: UInt; mincolor, maxcolor: COLORREF );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>A Cartesian coordinate system is drawn with automatic scaling of the axes and the matrix MZ is plotted as a color-density map against the vectors X and Y. Prior to calling <I>MF_xyzAutoDensityMap</I>, the plotting routines have to be initialized by <I><a href="FUNCREF.HTM#initGraph">V_initGraph</a></I> (for DOS programs) or <I><a href="FUNCREF.HTM#initPlot">V_initPlot</a></I> (DOS or Windows programs).
<P>The font of the axis tick labels is the actual text font. In DOS programs (Borland C++ or Pascal), it may be changed by calling <I>settextstyle</I> before calling <I>MF_xyzAutoDensityMap</I>. In Windows programs (both 16-bit and 32-bit), the font of the current device context is used.
<P>All MZ values will be translated into colors by linear interpolation between the parameters <I>mincolor</I> and <I>maxcolor</I>.
<BR><U>DOS:</U>&nbsp;&nbsp; The data type COLORREF is <B>unsigned</B>. See the Borland C++ or TurboPascal function <i>setcolor</i> for a description of the colors available in the various graphics modes. 
<BR><U>Windows:</U> The data type COLORREF is <B>unsigned long</B>. The colors BLACK, BLUE, GREEN, CYAN, RED, MAGENTA, BROWN, LIGHTGRAY, DARKGRAY, LIGHTBLUE, LIGHTGREEN, LIGHTCYAN, LIGHTRED, LIGHTMAGENTA, YELLOW, and WHITE are defined in &lt;Vgraph.h&gt; (or the unit Vgraph) by analogy with the COLORS defined for DOS in &lt;graphics.h&gt; (or the unit Graph) for the BGI routines. Thereby, portability between DOS and Windows programs is improved. For programs designed to run exclusively under Windows, it is nevertheless recommended to use fine-tuned colors defined by the RGB macro, instead of the predefined colors.
<P>If you wish to define the boudaries of the coordinate system differently, instead of relying on the automatic range detection and scaling, you may call first <I><a href="#setDensityMapBounds">M_setDensityMapBounds</a></I> or (for preserved automatic scaling, but with arbitrary x and y ranges) <I><a href="#findDensityMapBounds">MF_findDensityMapBounds</a></I>. Subsequently, call <I><a href="#xyzDataDensityMap">MF_xyzDataDensityMap</a></I> instead of <I>MF_xyzAutoDensityMap</I>.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#zAutoDensityMap">MF_zAutoDensityMap</a>,&nbsp;&nbsp; <a href="#xyzDataDensityMap">MF_xyzDataDensityMap</a>,&nbsp;&nbsp; <a href="FUNCREF.HTM#xyAutoPlot">VF_xyAutoPlot</a>,&nbsp;&nbsp; <a href="#chap15">Kap.&nbsp;15</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="xyzDataDensityMap"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_xyzDataDensityMap</b></font>
</td><td width="33%"><font size="+1"><b>MD_xyzDataDensityMap</b></font></td>
<td><font size="+1"><b>ME_xyzDataDensityMap</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>plot a color density map z = f( x, y ) into an existing coordinate system with a previously defined color scale</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Mgraph.h&gt;<BR>
void MF_xyzDataDensityMap( fVector X, fVector Y, fMatrix MZ, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses Mgraph;<BR>
procedure MF_xyzDataDensityMap( X, Y:fVector; MZ:fMatrix; ht, len: UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>The matrix MZ is plotted against the vectors X and Y into a coordinate system which has to be created by a previous call to <I><a href="#setDensityMapBounds">MF_setDensityMapBounds</a></I> or (for automatic scaling) <I><a href="#findDensityMapBounds">MF_findDensityMapBounds</a></I>. To perform the plot with automatic range checking and axis scaling, call <I><a href="#xyzAutoDensityMap">MF_xyzAutoDensityMap</a></I> instead.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#zDataDensityMap">MF_zDataDensityMap</a>,&nbsp;&nbsp; <a href="#xyzAutoDensityMap">MF_xyzAutoDensityMap</a>,&nbsp;&nbsp; <a href="#chap15">Kap.&nbsp;15</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="zAutoDensityMap"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_zAutoDensityMap</b></font>
</td><td width="33%"><font size="+1"><b>MD_zAutoDensityMap</b></font></td>
<td><font size="+1"><b>ME_zAutoDensityMap</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>plot a color density map of a matrix against the indices over its dimensions</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Mgraph.h&gt;<BR>
void MF_zAutoDensityMap( fMatrix MZ, unsigned ht, unsigned len, COLORREF mincolor, COLORREF maxcolor );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses Mgraph;<BR>
procedure MF_xyzDataDensityMap( X, Y:fVector; MZ:fMatrix; ht, len: UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function is similar to <I><a href="#xyzAutoDensityMap">MF_xyzAutoDensityMap</a></I>, but here MZ is plotted against the indices of its dimensions instead of explicit X and Y values.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#xyzAutoDensityMap">MF_xyzAutoDensityMap</a>,&nbsp;&nbsp; <a href="#chap15">Kap.&nbsp;15</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="zDataDensityMap"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_zDataDensityMap</b></font>
</td><td width="33%"><font size="+1"><b>MD_zDataDensityMap</b></font></td>
<td><font size="+1"><b>ME_zDataDensityMap</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>plot a color-density map of a matrix into an existing coordinate system whose axes comprise the range of the indices of the matrix dimensions</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td><font face="courier new">#include &lt;Mgraph.h&gt;<BR>
void MF_zDataDensityMap( fMatrix MZ, unsigned ht, unsigned len );</font></td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses Mgraph;<BR>
procedure MF_xyzDataDensityMap( X, Y:fVector; MZ:fMatrix; ht, len: UInt );</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function is similar to <I><a href="#xyzDataDensityMap">MF_xyzDataDensityMap</a></I>, but here MZ is plotted against the indices of its dimensions instead of explicit X and Y values.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#xyzDataDensityMap">MF_xyzDataDensityMap</a>,&nbsp;&nbsp; <a href="#xyzAutoDensityMap">MF_xyzAutoDensityMap</a>,&nbsp;&nbsp; <a href="#chap15">Kap.&nbsp;15</a></td></tr></table></td></tr>
</table>

<P>&nbsp;<a name="2DArrayToMatrix"></a>
<table border width="100%"><tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MF_2DArrayToMatrix</b></font>
</td><td width="33%"><font size="+1"><b>MD_2DArrayToMatrix</b></font></td>
<td><font size="+1"><b>ME_2DArrayToMatrix</b></font></td></tr></table>
<table width="100%"><tr valign="TOP">
<td width="33%"><font size="+1"><b>MCF_2DArrayToMatrix</b></font></td>
<td width="33%"><font size="+1"><b>MCD_2DArrayToMatrix</b></font></td>
<td><font size="+1"><b>MCE_2DArrayToMatrix</b></font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Function</td><td>convert 2D-array of Delphi 4 or higher into <I>OptiVec</I> matrix</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Syntax C/C++</td><td>N.A.</td></tr>
<tr valign="TOP"><td>Pascal/Delphi</td><td><font face="courier new">uses MFstd, VecLib;<BR>
type  fArray  = array of Single;<BR>
type  f2DArray  = array of fArray;<BR>
procedure    MF_2DArrayToMatrix( MF:fMatrix; DelphiArr:f2DArray; ht,len:UInt);</font></td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">Description</td><td>This function is necessary only for Delphi 4 or higher. (Previous versions of Borland Pascal/Delphi did not support dynamically allocated matrices.) It converts two-dimensional Delphi arrays into <I>OptiVec</I> matrices. Note that, unlike static Pascal/Delphi matrices, the dynamic matrices of Delphi 4+ cannot directly be passed to <I>OptiVec</I> functions, but have to be converted first.</td></tr></table></td></tr>
<tr valign="TOP"><td width="100%"><table width="100%"><tr valign="TOP">
<td width="15%">See also</td><td><a href="#MatrixTo2DArray">MF_MatrixTo2DArray</a>,&nbsp;&nbsp; <a href="#chap1_4">Kap.&nbsp;1.4</a></td></tr></table></td></tr>
</table>

<P ALIGN="RIGHT"><A HREF="#TOC">Back to Table of Contents</A></P>

<P><H1><HR width="100%">E N D </H1>
Copyright for <i>OptiVec</i> software and documentation
<BR>&copy; 1996-2001 <I>OptiCode</I> - Dr. Martin Sander Software Dev.
<BR>All rights reserved!
</body>
</html>
